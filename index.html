<!DOCTYPE html>
<!--
    LOBALI - Elite Procrastination Management - ◊û◊©◊§◊ó◊™ ◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™
    
    ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊í◊®◊°◊ê◊ï◊™:
    v9.4 (10/02/2026) - üßπ PWA Clean: ◊†◊ô◊ß◊ï◊ô ◊®◊¢◊ú◊ô◊ù - Service Worker ◊ó◊°◊ô◊ü ◊©◊í◊ô◊ê◊ï◊™, ◊ë◊ì◊ô◊ß◊™ response.type!
    v9.3 (10/02/2026) - üîß PWA Fix: ◊™◊ô◊ß◊ï◊ü Service Worker - ◊°◊ô◊†◊ï◊ü chrome-extension, mobile-web-app-capable!
    v9.2 (10/02/2026) - üì± PWA Support: ◊î◊§◊ô◊õ◊î ◊ú◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊û◊™◊ß◊†◊™! manifest, service worker, ◊ê◊ô◊ô◊ß◊ï◊†◊ô◊ù!
    v9.1 (10/02/2026) - üë∂ Ann Promotion: ◊ê◊ü ◊¢◊ï◊ì◊õ◊†◊î ◊ú"◊°◊û◊†◊õ"◊ú◊ô◊™ ◊™◊§◊¢◊ï◊ú"! ◊ß◊ô◊ì◊ï◊ù ◊®◊ê◊ï◊ô!
    v9.0 (10/02/2026) - üîí Personal Fix: "◊û◊©◊ô◊û◊ï◊™ ◊¢◊¶◊û◊ê◊ô◊ï◊™" ◊û◊¶◊ô◊í ◊®◊ß ◊û◊©◊ô◊û◊ï◊™ ◊©◊ú◊ô! ◊ú◊ê ◊©◊ú ◊ê◊ó◊®◊ô◊ù!
    v8.9 (10/02/2026) - üî¢ Count Fix: ◊°◊§◊ô◊®◊™ ◊î◊û◊©◊ô◊û◊ï◊™ ◊ë◊õ◊®◊ò◊ô◊°◊ô◊ï◊™ ◊™◊ï◊ß◊†◊î! ◊ú◊ê ◊°◊ï◊§◊®◊ï◊™ ◊û◊©◊ô◊û◊ï◊™ ◊©◊î◊ï◊©◊ú◊û◊ï!
    v8.8 (10/02/2026) - üîß My Tasks Fix: ◊û◊©◊ô◊û◊ï◊™ ◊©◊î◊ï◊©◊ú◊û◊ï (◊õ◊ï◊ú◊ú recurring!) ◊ú◊ê ◊û◊ï◊§◊ô◊¢◊ï◊™ ◊ô◊ï◊™◊® ◊ë"◊û◊©◊ô◊û◊ï◊™ ◊©◊ú◊ô"!
    v8.7 (10/02/2026) - üîß Bottom Fix: ◊™◊ô◊ß◊ï◊ü "◊î◊ó◊ú◊ß◊î ◊ú◊û◊ò◊î" - ◊¢◊õ◊©◊ô◊ï ◊ô◊®◊ô◊ì◊î ◊ú◊°◊ï◊£ ◊î◊®◊©◊ô◊û◊î ◊¢◊ï◊ë◊ì◊™ ◊û◊ï◊©◊ú◊ù!
    v8.6 (10/02/2026) - üóëÔ∏è Delete Shopping: ◊î◊ï◊°◊§◊™ ◊õ◊§◊™◊ï◊® ◊û◊ó◊ô◊ß◊î ◊ú◊ß◊†◊ô◊ï◊™! ◊õ◊û◊ï ◊ë◊û◊©◊ô◊û◊ï◊™ - ◊®◊ß ◊ú-Admin!
    v8.5 (10/02/2026) - ‚è±Ô∏è Extra Safe: long-press ◊î◊ï◊ê◊®◊ö ◊ú-2 ◊©◊†◊ô◊ï◊™ ◊û◊ú◊ê◊ï◊™!
    v8.4 (10/02/2026) - ‚è±Ô∏è Timing Perfect: long-press 0.5 ◊©◊†◊ô◊ï◊™ + ◊í◊®◊ô◊®◊î ‚Üë ◊ú◊®◊ê◊© / ‚Üì ◊ú◊°◊ï◊£!
    v8.3 (10/02/2026) - üéØ Perfect Reordering: ◊ú◊ó◊ô◊¶◊î + ◊í◊®◊ô◊®◊î ◊ê◊†◊õ◊ô◊™! ◊í◊ú◊ô◊ú◊î ◊®◊í◊ô◊ú◊î ◊¢◊ï◊ë◊ì◊™ ◊™◊û◊ô◊ì!
    v8.2 (10/02/2026) - üéØ Critical Fix: ◊í◊ú◊ô◊ú◊î vs ◊î◊ó◊ú◊ß◊î ◊™◊ï◊ß◊ü! preventDefault ◊®◊ß ◊ë◊î◊ó◊ú◊ß◊î!
    v8.1 (10/02/2026) - üéØ UX Perfect: ◊õ◊§◊™◊ï◊® ◊î◊ï◊°◊£ ◊û◊™◊ó◊™ ◊ú◊ê◊†◊©◊ô◊ù, "◊ú◊ó◊• ◊ú◊ë◊ó◊ô◊®◊î:", ◊í◊ô◊ë◊ï◊ô ◊†◊ô◊ô◊ì ◊û◊©◊ï◊§◊®!
    v8.0 (09/02/2026) - üíú LOBALI Rebranding: ◊û◊°◊ö ◊î◊™◊ó◊ë◊®◊ï◊™ ◊ó◊ì◊© ◊¢◊ù ◊ú◊ï◊í◊ï L, ◊õ◊ú ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊†◊©◊ê◊®◊î ◊ñ◊î◊î!
    v6.1 (09/02/2026) - üé® UX Revolution: Input+◊õ◊§◊™◊ï◊® ◊ë◊©◊ï◊®◊î ◊ê◊ó◊™, Long-press (2 ◊©◊†◊ô◊ï◊™) ◊ú◊û◊¢◊ú◊î/◊ú◊û◊ò◊î, ◊û◊ó◊ô◊ß◊™ üí¨üìå, ◊î◊ï◊°◊§◊™ (◊ô◊ï◊¶◊®)!
    v6.0 (09/02/2026) - üéØ Complete Fix: ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù (modal z-index), ◊û◊©◊ô◊û◊ï◊™ ◊¢◊¶◊û◊ê◊ô◊ï◊™ ◊ë◊§◊ô◊ú◊ò◊®, ◊ê◊ô◊ô◊ß◊ï◊†◊ô◊ù ◊ß◊ò◊†◊ô◊ù, responsive!
    v5.6 (09/02/2026) - üîß Major Fixes: Swipe ‚Üë‚Üì ◊¢◊ï◊ë◊ì, ◊™◊ê◊®◊ô◊ö ◊î◊©◊ú◊û◊î, ◊ë◊ô◊ò◊ï◊ú ◊°◊ô◊°◊û◊î ◊ú◊ó◊í◊ô, ◊í◊ô◊ë◊ï◊ô ◊ë◊û◊ï◊ë◊ô◊ô◊ú!
    v5.5 (09/02/2026) - üîß Bug Fixes: ◊™◊ô◊ß◊ï◊ü ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù + Google Calendar ◊ê◊ô◊®◊ï◊¢ ◊ú◊©◊¢◊î ◊ê◊ó◊™ ◊ë◊û◊ß◊ï◊ù ◊õ◊ú ◊î◊ô◊ï◊ù!
    v5.4 (09/02/2026) - üè∑Ô∏è Version Display: ◊û◊°◊§◊® ◊í◊®◊°◊î ◊û◊ï◊¶◊í ◊ë◊û◊°◊ö ◊î◊™◊ó◊ë◊®◊ï◊™ ◊ï◊ë-Header!
    v5.3 (09/02/2026) - üë• User Management: ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù ◊û◊ú◊ê - ◊î◊ï◊°◊£, ◊¢◊®◊ï◊ö, ◊û◊ó◊ß ◊û◊©◊™◊û◊©◊ô◊ù!
    v5.2 (09/02/2026) - ‚ö° Quick Add Task: ◊ß◊ê◊®◊ì ◊î◊ï◊°◊§◊™ ◊û◊©◊ô◊û◊î ◊û◊î◊ô◊®◊î ◊ó◊ñ◊® ◊ú◊û◊°◊ö! ◊ë◊ó◊® ◊ê◊ì◊ù ◊ï◊î◊ï◊°◊£ ◊ë◊ß◊ú◊ô◊ß
    v5.1 (09/02/2026) - üìÖ Google Calendar Integration: ◊õ◊§◊™◊ï◊® "◊î◊ï◊°◊£ ◊ú◊ô◊ï◊û◊ü" ◊ú◊û◊©◊ô◊û◊ï◊™ ◊¢◊ù ◊™◊ê◊®◊ô◊ö!
    v5.0 (09/02/2026) - üåü Bottom Nav Revolution: 3 ◊û◊°◊õ◊ô◊ù ◊†◊§◊®◊ì◊ô◊ù (üìãüõíüìä), Swipe ◊í◊ù ◊ú◊û◊©◊ô◊û◊ï◊™, ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î ◊†◊§◊®◊ì◊™
    v4.2 (09/02/2026) - üëÜ Swipe Perfect: ‚Üê ◊†◊ß◊†◊î, ‚Üí ◊ë◊ô◊ò◊ï◊ú (◊ë◊ú◊ô ◊ê◊ô◊©◊ï◊®!), ‚Üë ◊î◊¢◊ú◊ê◊î, ‚Üì ◊î◊ï◊®◊ì◊î
    v4.1 (09/02/2026) - üé® Professional Design: ◊¢◊ô◊¶◊ï◊ë ◊†◊ß◊ô, Swipe Actions (‚Üê‚Üí‚Üë), ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù, ◊®◊©◊ï◊û◊î ◊†◊ß◊†◊™◊î ◊¢◊ù ◊ß◊ï
    v4.0 (09/02/2026) - üöÄ Mobile First Revolution: Header ◊ì◊ß (50px), FAB ◊¶◊£, "◊î◊û◊©◊ô◊û◊ï◊™ ◊©◊ú◊ô" ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú, ◊¢◊ô◊¶◊ï◊ë ◊û◊ï◊ì◊®◊†◊ô
    v3.4 (09/02/2026) - ◊¢◊ô◊¶◊ï◊ë ◊°◊ï◊§◊® ◊ß◊ï◊û◊§◊ß◊ò◊ô: ◊©◊ï◊®◊î ◊ê◊ó◊™ ◊ì◊ß◊î (◊í◊ù ◊û◊©◊ô◊û◊ï◊™ ◊ï◊í◊ù ◊ß◊†◊ô◊ï◊™, ◊õ◊ï◊ú◊ú ◊û◊ï◊ë◊ô◊ô◊ú)
    v3.3 (09/02/2026) - ◊¢◊ô◊¶◊ï◊ë ◊ß◊ï◊û◊§◊ß◊ò◊ô: ◊©◊ï◊®◊ï◊™ ◊ì◊ß◊ï◊™ ◊ú◊§◊®◊ô◊ò◊ô ◊ß◊†◊ô◊ô◊î (◊©◊ï◊®◊î ◊ê◊ó◊™ ◊¢◊ù ◊õ◊ú ◊î◊û◊ô◊ì◊¢)
    v3.2 (09/02/2026) - ◊™◊ô◊ß◊ï◊ü ◊ë◊ê◊í: ◊î◊°◊™◊®◊™ ◊õ◊§◊™◊ï◊®◊ô ◊û◊ó◊ô◊ß◊ï◊™/◊í◊ô◊ë◊ï◊ô/◊©◊ó◊ñ◊ï◊® ◊û◊õ◊ï◊ú◊ù ◊ó◊ï◊• ◊û◊ó◊í◊ô
    v3.1 (09/02/2026) - ◊°◊ô◊°◊û◊î ◊ú◊ó◊í◊ô (cochag12), ◊í◊ô◊ë◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊®◊ß ◊ë◊û◊ó◊©◊ë
    v3.0 (08/02/2026) - ◊™◊ô◊ß◊ï◊ü: ◊û◊†◊î◊ú◊ô◊ù ◊®◊ï◊ê◊ô◊ù ◊õ◊ú ◊î◊û◊©◊ô◊û◊ï◊™, ◊û◊©◊ô◊û◊ï◊™ ◊û◊ó◊ñ◊ï◊®◊ô◊ï◊™ (◊ô◊ï◊û◊ô/◊©◊ë◊ï◊¢◊ô)
    v2.7 (08/02/2026) - ◊õ◊§◊™◊ï◊®◊ô ◊û◊ó◊ô◊ß◊ï◊™/◊í◊ô◊ë◊ï◊ô/◊©◊ó◊ñ◊ï◊® ◊®◊ß ◊ú◊ó◊í◊ô (◊ú◊ê ◊ú◊ú◊ô◊ê◊™)
    v2.6 (08/02/2026) - ◊ß◊ú◊ô◊ß ◊¢◊ú ◊û◊©◊™◊û◊© ◊ë◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊û◊¢◊ë◊® ◊ú◊û◊©◊ô◊û◊ï◊™ ◊©◊ú◊ï, ◊ó◊ô◊§◊ï◊© ◊í◊ù ◊ú◊§◊ô ◊©◊ù
    v2.5 (08/02/2026) - ◊ó◊ô◊§◊ï◊© ◊û◊©◊ô◊û◊ï◊™ ◊ú◊§◊ô ◊©◊ù ◊ê◊ï ◊™◊ô◊ê◊ï◊®
    v2.4 (08/02/2026) - ◊™◊ô◊ß◊ï◊ü ◊ë◊ê◊í: ◊û◊©◊ô◊û◊ï◊™ ◊¢◊¶◊û◊ê◊ô◊ï◊™ ◊ú◊ê ◊†◊®◊ê◊ï◊™ ◊ú◊û◊ô ◊©◊ú◊ê ◊ê◊û◊ï◊®
    v2.3 (08/02/2026) - ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™ ◊û◊§◊ï◊®◊ò◊ï◊™ ◊®◊ß ◊ú◊û◊†◊î◊ú◊ô◊ù, ◊ú◊©◊ï◊†◊ô◊ï◊™ ◊û◊©◊ô◊û◊ï◊™/◊ß◊†◊ô◊ï◊™
    v2.2 (08/02/2026) - ◊û◊°◊§◊ï◊® ◊ë◊ò◊ê◊ë◊ô◊ù, ◊î◊°◊®◊™ ◊§◊ô◊ú◊ò◊® '◊î◊õ◊ú', ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú ◊ú◊û◊û◊™◊ô◊†◊ï◊™
    v2.1 (08/02/2026) - ◊®◊©◊ô◊û◊î ◊û◊°◊ï◊ì◊®◊™ ◊¢◊ù ◊û◊°◊§◊ï◊®, ◊ó◊ô◊§◊ï◊© ◊û◊ï◊¶◊®◊ô◊ù, ◊õ◊ï◊õ◊ë◊ô ◊©◊ë◊ï◊¢ ◊®◊ß ◊ú◊ó◊í◊ô
    v2.0 (08/02/2026) - Firebase Realtime Database - ◊°◊†◊õ◊®◊ï◊ü ◊ë◊ñ◊û◊ü ◊ê◊û◊™
    v1.6 (◊ß◊ï◊ì◊ù)      - ◊í◊®◊°◊î ◊û◊ß◊ï◊®◊ô◊™ ◊¢◊ù localStorage
-->
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOBALI v9.4 - Elite Procrastination Management üíú</title>
    
    <!-- Version Info -->
    <meta name="version" content="9.4">
    <meta name="last-updated" content="2026-02-10">
    <meta name="sync" content="firebase-realtime">
    <meta name="changelog" content="PWA Clean: ◊†◊ô◊ß◊ï◊ô ◊®◊¢◊ú◊ô◊ù - Service Worker ◊ó◊°◊ô◊ü ◊©◊í◊ô◊ê◊ï◊™! üßπ">
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="LOBALI">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700;800&family=Varela+Round&family=Alef:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-liat: #E91E63;
            --color-hagai: #2196F3;
            --color-maya: #00BCD4;
            --color-ariel: #4CAF50;
            --color-ann: #FF9800;
            
            --bg-main: #F5F5F5;
            --bg-card: #FFFFFF;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border-color: #E0E0E0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 2px 6px rgba(0,0,0,0.15);
            --shadow-lg: 0 4px 12px rgba(0,0,0,0.18);
            
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rubik', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 0;
            position: relative;
            overflow-x: hidden;
        }
            z-index: 0;
            animation: float 20s ease-in-out infinite;
        }
        
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            to {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-bottom: 100px;
            position: relative;
            z-index: 1;
        }
        
        /* Header */
        header {
            background: white;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .header-compact {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .user-info-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .user-avatar-small {
            font-size: 1.5rem;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .user-details-compact {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        
        .user-name-small {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .user-role-small {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        /* Version Badges */
        .version-badge-header {
            display: inline-block;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            padding: 2px 8px;
            border-radius: 10px;
            margin-top: 2px;
        }
        
        .version-badge-login {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, #6366F1, #8B5CF6);
            padding: 8px 16px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            z-index: 10;
        }
        
        .header-actions-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sync-compact {
            display: flex;
            align-items: center;
            padding: 4px;
        }
        
        .btn-icon-only {
            padding: 6px 10px;
            border: none;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
        }
        
        .btn-icon-only:hover {
            background: rgba(0,0,0,0.1);
            transform: scale(1.05);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .header-user {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .user-avatar {
            font-size: 3rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .user-info h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .user-info p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #syncStatus {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(0,0,0,0.03);
            border-radius: var(--radius-sm);
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95rem;
            font-family: 'Rubik', sans-serif;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #E91E63, #FF6B9D);
            color: white;
            box-shadow: 0 4px 12px rgba(233, 30, 99, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.4);
        }
        
        .btn-secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: rgba(0,0,0,0.08);
        }
        
        .btn-logout {
            background: transparent;
            color: var(--text-secondary);
            border: 2px solid currentColor;
        }
        
        .btn-logout:hover {
            background: var(--text-secondary);
            color: white;
        }
        
        /* FAB - Floating Action Button */
        .fab {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            background: #1976D2;
        }
        
        .fab:active {
            transform: scale(0.95);
        }
        
        /* Tabs */
        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            border: none;
            background: none;
            color: var(--text-secondary);
        }
        
        .nav-item:active {
            transform: scale(0.95);
        }
        
        .nav-item.active {
            color: #2196F3;
        }
        
        .nav-icon {
            font-size: 1.5rem;
            transition: transform 0.2s;
        }
        
        .nav-item.active .nav-icon {
            transform: scale(1.1);
        }
        
        .nav-label {
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .nav-badge {
            position: absolute;
            top: 4px;
            right: 20%;
            background: #E91E63;
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }
        
        /* Main Layout */
        .main-layout {
            padding-bottom: 80px;
        }
        
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 30px;
            box-shadow: var(--shadow-md);
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Filters */
        .filters {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 6px 10px;
            background: rgba(0,0,0,0.04);
            border: 2px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.75rem;
            font-family: 'Rubik', sans-serif;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }
        
        .filter-btn:hover {
            background: rgba(0,0,0,0.06);
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, #00BCD4, #00E5FF);
            color: white;
            border-color: #00BCD4;
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.3);
        }
        
        .filter-count {
            background: rgba(255,255,255,0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
        }
        
        .filter-btn.active .filter-count {
            background: rgba(255,255,255,0.95);
            color: #00BCD4;
        }
        
        /* Task/Shopping Item */
        .item {
            background: white;
            border-radius: var(--radius-sm);
            padding: 12px 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            touch-action: pan-y;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .item:active {
            box-shadow: var(--shadow-md);
        }
        
        .item.swiping {
            transition: none;
        }
        
        .item.swipe-left {
            background: #E8F5E9;
        }
        
        .item.swipe-right {
            background: #FFF3E0;
        }
        
        .item.swipe-up {
            background: #E3F2FD;
        }
        
        .item.swipe-down {
            background: #FFF9C4;
        }
        
        .item.pinned {
            border-left: 4px solid #E91E63;
            background: #FFF0F5;
        }
        
        .item.completed {
            opacity: 0.6;
            background: #F5F5F5;
        }
        
        .item.completed .item-content {
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        
        /* Personal Tasks - Different color */
        .item.personal-task {
            background: linear-gradient(to right, #FFF9E6 0%, #FFFEF8 100%);
            border-left: 3px solid #FF9800;
        }
        
        .item.purchased {
            opacity: 0.5;
            background: #FAFAFA;
        }
        
        .item.purchased .item-content {
            text-decoration: line-through;
            color: #9E9E9E;
        }
        
        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        .swipe-indicator.left {
            right: 20px;
        }
        
        .swipe-indicator.right {
            left: 20px;
        }
        
        .swipe-indicator.up {
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .swipe-indicator.down {
            left: 50%;
            top: auto;
            bottom: 50%;
            transform: translate(-50%, 50%);
        }
        
        .swipe-indicator.visible {
            opacity: 1;
        }
        
        .item-number {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-secondary);
            min-width: 25px;
            text-align: center;
        }
        
        .item-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.4;
        }
        
        .item-header {
            flex: 1;
            min-width: 0;
        }
        
        .item-title {
            font-size: 1.05rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .item-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }
        
        .badge-priority-high {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .badge-priority-medium {
            background: #FFF3E0;
            color: #E65100;
        }
        
        .badge-priority-low {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .badge-pinned {
            background: linear-gradient(135deg, #E91E63, #9C27B0);
            color: white;
        }
        
        .badge-personal {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .item-description {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .item-meta {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--text-secondary);
        }
        
        .user-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .item-actions {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }
        
        .btn-icon {
            padding: 5px 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.7rem;
            font-family: 'Rubik', sans-serif;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            position: relative;
            white-space: nowrap;
        }
        
        .btn-icon:hover {
            transform: translateY(-2px);
        }
        
        .btn-complete {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .btn-delete {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .btn-pin {
            background: #FCE4EC;
            color: #C2185B;
        }
        
        .btn-notes {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .btn-calendar {
            background: #FFF9C4;
            color: #F57C00;
        }
        
        .btn-calendar:hover {
            background: #FFF59D;
            box-shadow: 0 2px 8px rgba(245, 124, 0, 0.3);
        }
        
        .btn-read {
            background: #F3E5F5;
            color: #7B1FA2;
        }
        
        .btn-read.reading {
            animation: reading-pulse 1s infinite;
        }
        
        @keyframes reading-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .note-badge {
            position: absolute;
            top: -6px;
            left: -6px;
            background: #C62828;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 700;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #E91E63;
            box-shadow: 0 0 0 3px rgba(233, 30, 99, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        
        .form-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Assignee Selection */
        .assignee-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(42px, 1fr));
            gap: 4px;
            margin-top: 6px;
        }
        
        .assignee-btn {
            padding: 3px;
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-family: 'Rubik', sans-serif;
        }
        
        .assignee-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }
        
        .assignee-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .assignee-icon {
            font-size: 1rem;
            margin-bottom: 1px;
        }
        
        .assignee-name {
            font-weight: 600;
            font-size: 0.6rem;
        }
        
        /* Priority Selection */
        .priority-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }
        
        .priority-btn {
            padding: 15px;
            border: 3px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .priority-btn:hover {
            transform: translateY(-3px);
        }
        
        .priority-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 35px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: modalSlide 0.3s ease;
        }
        
        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .modal-title {
            font-size: 1.6rem;
            font-weight: 700;
        }
        
        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.05);
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: rgba(0,0,0,0.1);
            transform: rotate(90deg);
        }
        
        /* Statistics */
        .stat-card {
            background: linear-gradient(135deg, #FFF 0%, #F8F8F8 100%);
            border-radius: var(--radius-md);
            padding: 25px;
            margin-bottom: 20px;
            border-right: 5px solid;
        }
        
        .stat-card.tasks {
            border-right-color: #E91E63;
        }
        
        .stat-card.shopping {
            border-right-color: #FF9800;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-name {
            font-weight: 600;
        }
        
        .stat-count {
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        /* Statistics Tabs */
        .stat-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
        }
        
        .stat-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-secondary);
            transition: all 0.3s;
            font-family: 'Rubik', sans-serif;
        }
        
        .stat-tab:hover {
            color: var(--text-primary);
        }
        
        .stat-tab.active {
            color: #E91E63;
            border-bottom-color: #E91E63;
        }
        
        .stat-content {
            display: none;
        }
        
        .stat-content.active {
            display: block;
        }
        
        .member-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #F9FAFB;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .member-stat:hover {
            background: #E5E7EB;
            transform: translateX(-3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .member-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .member-icon {
            font-size: 1.5rem;
        }
        
        .member-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .member-count {
            font-size: 1.3rem;
            font-weight: 700;
            padding: 5px 12px;
            background: white;
            border-radius: 10px;
        }
        
        .member-count.zero {
            opacity: 0.5;
            color: var(--text-secondary);
        }
        
        .shopping-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .shopping-stat-box {
            background: #F9FAFB;
            padding: 20px;
            border-radius: var(--radius-sm);
            text-align: center;
        }
        
        .shopping-stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .shopping-stat-number.pending {
            color: #2196F3;
        }
        
        .shopping-stat-number.purchased {
            color: #4CAF50;
        }
        
        .shopping-stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        /* Top Performers */
        .performer-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #FFF 0%, #FAFAFA 100%);
            border-radius: var(--radius-sm);
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        
        .performer-item:hover {
            transform: translateX(-5px);
            box-shadow: var(--shadow-sm);
        }
        
        .performer-rank {
            font-size: 1.8rem;
            width: 50px;
            text-align: center;
        }
        
        .performer-info {
            flex: 1;
        }
        
        .performer-name {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }
        
        .performer-points {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        /* Notes */
        .notes-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .note-item {
            background: #F8F8F8;
            padding: 18px;
            border-radius: var(--radius-sm);
            margin-bottom: 15px;
            border-right: 4px solid #E0E0E0;
        }
        
        .note-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .note-author {
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .note-text {
            line-height: 1.6;
        }
        
        /* Deletion History */
        .history-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .history-table th,
        .history-table td {
            padding: 15px;
            text-align: right;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .history-table th {
            background: rgba(0,0,0,0.03);
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .history-table tr:hover {
            background: rgba(0,0,0,0.02);
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .empty-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-text {
            font-size: 1.1rem;
        }
        
        /* Quick Add */
        .quick-add {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
        }
        
        .quick-add input {
            flex: 1;
        }
        
        /* Search Box */
        .search-box {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 3px rgba(0, 188, 212, 0.1);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }
        
        /* Hidden */
        .hidden {
            display: none !important;
        }
        
        /* Login Screen */
        /* Login Screen - LOBALI Design */
        .login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #0A0A0B;
            background: radial-gradient(circle at center, #1E1E2D 0%, #0A0A0B 100%);
            padding: 40px 20px;
        }
        
        .brand-header {
            text-align: center;
            margin-bottom: 60px;
        }
        
        .logo-svg {
            width: 100px;
            height: 100px;
            margin: 0 auto 30px;
            display: block;
        }
        
        .login-title {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: -0.05em;
            background: linear-gradient(to bottom, #fff 0%, #64748B 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
        }
        
        .login-subtitle {
            font-size: 1rem;
            color: #6366F1;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            font-weight: 600;
        }
        
        .login-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 24px;
            max-width: 1100px;
            width: 100%;
        }
        
        .login-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            min-height: 130px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .login-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }
        
        .login-card:hover::before {
            transform: translateX(100%);
        }
        
        .login-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #6366F1;
            transform: scale(1.05);
        }
        
        .login-icon {
            font-size: 1.8rem;
            margin-bottom: 8px;
            display: block;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }
        
        .login-name {
            font-size: 1rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .login-role {
            font-size: 0.65rem;
            color: #94A3B8;
            text-align: center;
            line-height: 1.3;
        }
        
        .login-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .login-badge.pending {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }
        
        .login-badge.complete {
            background: rgba(16, 185, 129, 0.2);
            color: #10B981;
        }
        
        .user-management {
            margin-top: 50px;
            text-align: center;
        }
        
        .btn-manage {
            padding: 14px 32px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #94A3B8;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Rubik', sans-serif;
        }
        
        .btn-manage:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #6366F1;
            color: #6366F1;
            transform: translateY(-2px);
        }
        
        /* User List in Modal */
        .user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--bg-light);
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }
        
        .user-item-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .user-item-icon {
            font-size: 1.8rem;
        }
        
        .user-item-details {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .user-item-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .user-item-role {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .user-item-actions {
            display: flex;
            gap: 8px;
        }
        
        .user-item .btn-icon {
            padding: 6px 10px;
            font-size: 0.75rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-right {
                width: 100%;
                justify-content: space-between;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .item {
                flex-wrap: nowrap;
                padding: 6px 10px;
                font-size: 0.8rem;
            }
            
            .item-content {
                font-size: 0.8rem;
                line-height: 1.3;
            }
            
            .item-actions {
                flex-wrap: nowrap;
                gap: 4px;
            }
            
            .filter-btn {
                padding: 5px 8px;
                font-size: 0.7rem;
                gap: 4px;
            }
            
            .filter-count {
                padding: 1px 4px;
                font-size: 0.65rem;
            }
            
            .assignee-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
                gap: 3px;
            }
            
            .assignee-btn {
                padding: 2px;
            }
            
            .assignee-icon {
                font-size: 0.95rem;
            }
            
            .assignee-name {
                font-size: 0.6rem;
            }
            
            .filters {
                gap: 6px;
                margin-bottom: 15px;
            }
            
            .btn-icon {
                font-size: 0.65rem;
                padding: 4px 6px;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.03);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="version-badge-login">v9.4</div>
        
        <div class="brand-header">
            <svg class="logo-svg" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="30" fill="#161618"/>
                <path d="M35 30V70H65M65 55L55 65" stroke="#6366F1" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            
            <h1 class="login-title">LOBALI</h1>
            <p class="login-subtitle">ELITE PROCRASTINATION MANAGEMENT</p>
        </div>
        
        <div class="login-grid" id="loginGrid"></div>
        
        <!-- User Management -->
        <div class="user-management">
            <button class="btn-manage" onclick="openUserManagementModal()">
                üë• ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù
            </button>
        </div>
    </div>

    <!-- User Management Modal -->
    <div id="userManagementModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üë• ◊†◊ô◊î◊ï◊ú ◊û◊©◊™◊û◊©◊ô◊ù</h3>
                <button class="modal-close" onclick="closeUserManagementModal()">‚úï</button>
            </div>
            
            <div class="modal-body">
                <!-- Current Users -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ◊û◊©◊™◊û◊©◊ô◊ù ◊ß◊ô◊ô◊û◊ô◊ù:</h4>
                <div id="currentUsersList" style="margin-bottom: 25px;"></div>
                
                <!-- Add New User -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">‚ûï ◊î◊ï◊°◊£ ◊û◊©◊™◊û◊© ◊ó◊ì◊©:</h4>
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <input type="text" id="newUserName" class="form-input" placeholder="◊©◊ù ◊î◊û◊©◊™◊û◊©...">
                    <input type="text" id="newUserIcon" class="form-input" placeholder="◊ê◊ô◊û◊ï◊í'◊ô (◊ú◊ì◊ï◊í◊û◊î: üë∂)" maxlength="2">
                    <select id="newUserRole" class="form-input">
                        <option value="child">◊ô◊ú◊ì/◊î</option>
                        <option value="admin">◊û◊†◊î◊ú/◊™</option>
                    </select>
                    <button class="btn btn-primary" onclick="addNewUser()">‚ûï ◊î◊ï◊°◊£ ◊û◊©◊™◊û◊©</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container hidden">
        <!-- Header -->
        <header>
            <div class="header-compact">
                <div class="user-info-compact">
                    <span class="user-avatar-small" id="userAvatar">üë®</span>
                    <div class="user-details-compact">
                        <span class="user-name-small" id="userName">◊û◊©◊™◊û◊©</span>
                        <span class="user-role-small" id="userRole">◊™◊§◊ß◊ô◊ì</span>
                        <span class="version-badge-header">v9.4</span>
                    </div>
                </div>
                
                <div class="header-actions-compact">
                    <div id="syncStatus" class="sync-compact">
                        <span class="sync-dot" style="background: #FFA500;"></span>
                    </div>
                    
                    <button class="btn-icon-only hidden" id="btnDeletionHistory" onclick="openDeletionHistoryModal()" title="◊û◊ó◊ô◊ß◊ï◊™">
                        üóëÔ∏è
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnBackup" onclick="performManualBackup()" title="◊í◊ô◊ë◊ï◊ô">
                        üíæ
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnRestore" onclick="performRestore()" title="◊©◊ó◊ñ◊ï◊®">
                        üì•
                    </button>
                    
                    <button class="btn-icon-only btn-logout" onclick="logout()" title="◊ô◊¶◊ô◊ê◊î">
                        üö™
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Main Content -->
            <div class="main-content">
                <!-- Tasks Tab -->
                <div id="tasksTab" class="tab-content hidden">
                    <!-- Quick Add Task Card -->
                    <div class="card" style="padding: 12px;">
                        <input type="text" class="form-input" id="quickTaskInput" placeholder="◊©◊ù ◊î◊û◊©◊ô◊û◊î..." style="width: 100%; margin-bottom: 12px;" onkeypress="if(event.key === 'Enter') addQuickTask()">
                        
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500;">
                            ◊ú◊ó◊• ◊ú◊ë◊ó◊ô◊®◊î:
                        </div>
                        
                        <div class="assignee-grid" id="quickAssigneeGrid" style="margin-bottom: 12px;"></div>
                        
                        <button class="btn btn-primary" onclick="addQuickTask()" style="width: 100%;">
                            ‚ûï ◊î◊ï◊°◊£
                        </button>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="tasksSearchInput" placeholder="üîç ◊ó◊ô◊§◊ï◊© ◊û◊©◊ô◊û◊î..." oninput="filterTasksBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterTasks('pending', event)">
                            ◊û◊û◊™◊ô◊†◊ï◊™
                            <span class="filter-count" id="pendingTasksCount">0</span>
                        </button>
                        <button class="filter-btn" onclick="filterTasks('completed', event)">
                            ◊î◊ï◊©◊ú◊û◊ï
                        </button>
                        <button class="filter-btn" onclick="filterTasks('personal', event)">
                            ◊û◊©◊ô◊û◊ï◊™ ◊¢◊¶◊û◊ê◊ô◊ï◊™
                            <span class="filter-count" id="personalTasksCount">0</span>
                        </button>
                        <button class="filter-btn" id="myTasksFilter" onclick="filterTasks('my-tasks', event)">
                            ◊î◊û◊©◊ô◊û◊ï◊™ ◊©◊ú◊ô
                            <span class="filter-count" id="myTasksCount">0</span>
                        </button>
                    </div>

                    <!-- Tasks List -->
                    <div id="tasksList"></div>
                </div>

                <!-- Shopping Tab -->
                <div id="shoppingTab" class="tab-content">
                    <div class="card">
                        <h3 class="card-title">‚ûï ◊î◊ï◊°◊§◊™ ◊§◊®◊ô◊ò</h3>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" class="form-input" id="quickItemInput" placeholder="◊©◊ù ◊î◊§◊®◊ô◊ò..." style="flex: 0 0 60%; margin: 0;" onkeypress="if(event.key === 'Enter') { event.preventDefault(); quickAddItem(event); }">
                            <button type="button" class="btn btn-primary" onclick="quickAddItem(event)" style="flex: 0 0 calc(40% - 10px); white-space: nowrap;">‚ûï ◊î◊ï◊°◊£</button>
                        </div>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="shoppingSearchInput" placeholder="üîç ◊ó◊ô◊§◊ï◊© ◊û◊ï◊¶◊®..." oninput="filterShoppingBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterShopping('pending', event)">
                            ◊¶◊®◊ô◊ö ◊ú◊ß◊†◊ï◊™
                        </button>
                        <button class="filter-btn" onclick="filterShopping('purchased', event)">
                            ◊†◊ß◊†◊ï
                        </button>
                    </div>

                    <!-- Shopping List -->
                    <div id="shoppingList"></div>
                </div>
                
                <!-- Stats Screen -->
                <div id="statsScreen" class="tab-content hidden">
                    <div class="card">
                        <h3 class="card-title">üìä ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊ï◊™</h3>
                        <div id="statsContainer"></div>
                    </div>

                    <div class="card" id="topPerformersCard">
                        <h3 class="card-title">üèÜ ◊õ◊ï◊õ◊ë◊ô ◊î◊©◊ë◊ï◊¢</h3>
                        <div id="topPerformers"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- FAB - Floating Action Button -->
        <button class="fab" onclick="openFABModal()" title="◊î◊ï◊°◊£ ◊§◊®◊ô◊ò ◊ó◊ì◊©">
            ‚ûï
        </button>
        
        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <button class="nav-item active" onclick="switchScreen('shopping')" id="navShopping">
                <span class="nav-badge" id="navShoppingBadge">0</span>
                <div class="nav-icon">üõí</div>
                <div class="nav-label">◊ß◊†◊ô◊ï◊™</div>
            </button>
            <button class="nav-item" onclick="switchScreen('tasks')" id="navTasks">
                <span class="nav-badge" id="navTasksBadge">0</span>
                <div class="nav-icon">üìã</div>
                <div class="nav-label">◊û◊©◊ô◊û◊ï◊™</div>
            </button>
            <button class="nav-item" onclick="switchScreen('stats')" id="navStats">
                <div class="nav-icon">üìä</div>
                <div class="nav-label">◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î</div>
            </button>
        </div>
    </div>

    <!-- Add Task Modal -->
    <div id="addTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">‚ûï ◊û◊©◊ô◊û◊î ◊ó◊ì◊©◊î</h3>
                <button class="modal-close" onclick="closeAddTaskModal()">‚úï</button>
            </div>
            
            <form id="addTaskForm" onsubmit="submitTask(event)">
                <div class="form-group">
                    <label class="form-label">◊©◊ù ◊î◊û◊©◊ô◊û◊î *</label>
                    <input type="text" class="form-input" id="taskTitle" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label">◊™◊ô◊ê◊ï◊®</label>
                    <textarea class="form-textarea" id="taskDescription"></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">◊î◊ß◊¶◊ê◊î ◊ú◊û◊©◊™◊û◊© *</label>
                    <div class="assignee-grid" id="assigneeGrid"></div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">◊™◊ê◊®◊ô◊ö ◊ô◊¢◊ì</label>
                    <input type="date" class="form-input" id="taskDueDate">
                </div>
                
                <div class="form-group">
                    <label class="form-label">◊¢◊ì◊ô◊§◊ï◊™</label>
                    <div class="priority-grid">
                        <button type="button" class="priority-btn" style="background: #FFEBEE; color: #C62828;" onclick="selectPriority('high', event)">
                            üî¥ ◊í◊ë◊ï◊î◊î
                        </button>
                        <button type="button" class="priority-btn selected" style="background: #FFF3E0; color: #E65100;" onclick="selectPriority('medium', event)">
                            üü° ◊®◊í◊ô◊ú◊î
                        </button>
                        <button type="button" class="priority-btn" style="background: #E8F5E9; color: #2E7D32;" onclick="selectPriority('low', event)">
                            üü¢ ◊†◊û◊ï◊õ◊î
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsPersonal">
                        <span>üîí ◊û◊©◊ô◊û◊î ◊¢◊¶◊û◊ê◊ô◊™ (◊®◊ß ◊î◊û◊©◊™◊û◊© ◊©◊î◊ï◊ß◊¶◊™◊î ◊ú◊ï ◊ô◊®◊ê◊î ◊ê◊ï◊™◊î)</span>
                    </label>
                </div>
                
                <div class="form-group" id="recurringGroup" style="display: none;">
                    <label class="form-label">üîÑ ◊û◊©◊ô◊û◊î ◊û◊ó◊ñ◊ï◊®◊ô◊™</label>
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsRecurring" onchange="toggleRecurringOptions()">
                        <span>◊û◊©◊ô◊û◊î ◊ó◊ï◊ñ◊®◊™ (◊û◊™◊ê◊§◊°◊™ ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ú◊ê◊ó◊® ◊î◊©◊ú◊û◊î)</span>
                    </label>
                    <div id="recurringOptions" style="display: none; margin-top: 15px;">
                        <select class="form-select" id="recurringType">
                            <option value="daily">◊ô◊ï◊û◊ô◊™</option>
                            <option value="weekly">◊©◊ë◊ï◊¢◊ô◊™</option>
                        </select>
                    </div>
                </div>
                
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    ‚ûï ◊î◊ï◊°◊£ ◊û◊©◊ô◊û◊î
                </button>
            </form>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üí¨ ◊î◊¢◊®◊ï◊™ ◊ú◊û◊©◊ô◊û◊î</h3>
                <button class="modal-close" onclick="closeNotesModal()">‚úï</button>
            </div>
            
            <div class="notes-list" id="notesList"></div>
            
            <div id="addNoteSection">
                <div class="form-group">
                    <label class="form-label">◊î◊ï◊°◊£ ◊î◊¢◊®◊î</label>
                    <textarea class="form-textarea" id="newNoteText" placeholder="◊õ◊™◊ï◊ë ◊î◊¢◊®◊î..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="addNote()">üí¨ ◊î◊ï◊°◊£ ◊î◊¢◊®◊î</button>
            </div>
        </div>
    </div>

    <!-- Deletion History Modal -->
    <div id="deletionHistoryModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3 class="modal-title">üóëÔ∏è ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊û◊ó◊ô◊ß◊ï◊™</h3>
                <button class="modal-close" onclick="closeDeletionHistoryModal()">‚úï</button>
            </div>
            
            <table class="history-table">
                <thead>
                    <tr>
                        <th>◊°◊ï◊í</th>
                        <th>◊©◊ù</th>
                        <th>◊†◊û◊ó◊ß ◊¢◊ú ◊ô◊ì◊ô</th>
                        <th>◊™◊ê◊®◊ô◊ö</th>
                        <th>◊§◊¢◊ï◊ú◊ï◊™</th>
                    </tr>
                </thead>
                <tbody id="deletionHistoryBody"></tbody>
            </table>
            
            <div style="margin-top: 25px; text-align: left;">
                <button class="btn btn-delete" onclick="clearDeletionHistory()">
                    üóëÔ∏è ◊†◊ß◊î ◊î◊õ◊ú
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== FIREBASE CONFIGURATION ====================
        
        const firebaseConfig = {
            apiKey: "AIzaSyAkOH2RMig-uUYqPGfpB_ECVGQ6sSty-RQ",
            authDomain: "family-tasks-b3460.firebaseapp.com",
            databaseURL: "https://family-tasks-b3460-default-rtdb.firebaseio.com",
            projectId: "family-tasks-b3460",
            storageBucket: "family-tasks-b3460.firebasestorage.app",
            messagingSenderId: "679268328049",
            appId: "1:679268328049:web:e8b0a3e8f5c8d9e0a8b0a3"
        };
        
        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();
        
        // Firebase references
        const tasksRef = db.ref('tasks');
        const shoppingRef = db.ref('shopping');
        const deletionHistoryRef = db.ref('deletionHistory');
        
        // ==================== PWA - SERVICE WORKER ====================
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('üíú LOBALI Service Worker ◊†◊®◊©◊ù ◊ë◊î◊¶◊ú◊ó◊î!', registration.scope);
                        
                        // ◊ë◊ì◊ô◊ß◊™ ◊¢◊ì◊õ◊ï◊†◊ô◊ù
                        registration.addEventListener('updatefound', () => {
                            console.log('üîÑ ◊†◊û◊¶◊ê ◊¢◊ì◊õ◊ï◊ü ◊ú-Service Worker...');
                        });
                    })
                    .catch((error) => {
                        console.log('‚ùå ◊®◊ô◊©◊ï◊ù Service Worker ◊†◊õ◊©◊ú:', error);
                    });
            });
            
            // ◊û◊¢◊ß◊ë ◊ê◊ó◊® ◊©◊ô◊†◊ï◊ô◊ô ◊û◊¶◊ë ◊©◊ú Service Worker
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('‚ôªÔ∏è Service Worker ◊¢◊ï◊ì◊õ◊ü - ◊ê◊§◊©◊® ◊ú◊ò◊¢◊ï◊ü ◊û◊ó◊ì◊©');
            });
        }
        
        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('üì± LOBALI ◊û◊ï◊õ◊†◊î ◊ú◊î◊™◊ß◊†◊î!');
            
            // ◊ê◊§◊©◊® ◊ú◊î◊ï◊°◊ô◊£ ◊õ◊§◊™◊ï◊® "◊î◊™◊ß◊ü ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î" ◊ë◊¢◊™◊ô◊ì
            // const installButton = document.getElementById('installButton');
            // if (installButton) {
            //     installButton.style.display = 'block';
            // }
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('üíú LOBALI ◊î◊ï◊™◊ß◊†◊î ◊ë◊î◊¶◊ú◊ó◊î ◊¢◊ú ◊î◊û◊õ◊©◊ô◊®!');
            deferredPrompt = null;
        });
        
        // ==================== GLOBAL VARIABLES ====================
        
        // Family members
        // Family Members - Load from localStorage or use defaults
        // LOBALI Family Members - Always use latest
        const defaultFamilyMembers = {
            liat: { 
                id: 'liat', 
                name: '◊ú◊ô◊ê◊™', 
                icon: 'üë©‚Äçüíº', 
                color: '#E91E63', 
                role: '◊û◊†◊î◊ú◊™', 
                roleDescription: '◊î◊û◊†◊õ"◊ú◊ô◊™',
                isAdmin: true 
            },
            hagai: { 
                id: 'hagai', 
                name: '◊ó◊í◊ô', 
                icon: 'üë®', 
                color: '#2196F3', 
                role: '◊û◊†◊î◊ú', 
                roleDescription: '◊î◊™◊û◊ô◊õ◊î ◊î◊ò◊õ◊†◊ô◊™',
                isAdmin: true, 
                canBackup: true 
            },
            maya: { 
                id: 'maya', 
                name: '◊û◊ô◊î', 
                icon: '‚úçÔ∏è', 
                color: '#00BCD4', 
                role: '◊û◊©◊™◊û◊©◊™',
                roleDescription: '◊ô◊ï◊¢◊¶◊™ ◊ê◊°◊ò◊®◊ò◊í◊ô◊™ ◊ú◊û◊†◊ï◊ó◊î'
            },
            ariel: { 
                id: 'ariel', 
                name: '◊ê◊®◊ô◊ê◊ú', 
                icon: 'üéÆ', 
                color: '#4CAF50', 
                role: '◊û◊©◊™◊û◊©',
                roleDescription: '◊®◊ê◊© ◊ê◊í◊£ ◊§◊†◊ê◊ô ◊ï◊û◊©◊ó◊ß◊ô◊ù'
            },
            ann: { 
                id: 'ann', 
                name: '◊ê◊ü', 
                icon: 'üë∂', 
                color: '#FF9800', 
                role: '◊û◊©◊™◊û◊©◊™',
                roleDescription: '◊°◊û◊†◊õ"◊ú◊ô◊™ ◊™◊§◊¢◊ï◊ú',
                canSpeak: true 
            }
        };
        
        // Always use latest definition (override localStorage for consistency)
        let familyMembers = defaultFamilyMembers;
        localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
        
        // Current state
        let currentUser = null;
        let selectedAssignee = null;
        let selectedPriority = 'medium';
        let currentFilter = 'pending';
        let currentShoppingFilter = 'pending';
        let currentTaskForNotes = null;
        let shoppingSearchQuery = '';
        let tasksSearchQuery = '';
        
        // Data (will be populated from Firebase)
        let tasks = {};
        let shopping = {};
        let deletionHistory = [];
        
        // Sync status
        let isOnline = false;
        let isSyncing = false;
        
        // Backup system (for Hagai)
        let backupDirectoryHandle = null;
        const DB_NAME = 'FamilyTasksDB';
        const STORE_NAME = 'backupSettings';
        
        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        function initializeApp() {
            // Check if user is logged in
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser && familyMembers[savedUser]) {
                loginUser(savedUser);
            } else {
                showLoginScreen();
            }
        }
        
        // ==================== LOGIN ====================
        
        function showLoginScreen() {
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.add('hidden');
            renderLoginCards();
        }
        
        function renderLoginCards() {
            const grid = document.getElementById('loginGrid');
            grid.innerHTML = '';
            
            // Get pending tasks count for each user from Firebase
            tasksRef.once('value', (snapshot) => {
                const tasksData = snapshot.val() || {};
                
                Object.values(familyMembers).forEach(member => {
                    const pendingCount = Object.values(tasksData).filter(task => 
                        task.assignedTo === member.id && task.status === 'pending'
                    ).length;
                    
                    const card = document.createElement('div');
                    card.className = 'login-card';
                    card.onclick = () => loginUser(member.id);
                    
                    card.innerHTML = `
                        <div class="login-icon">${member.icon}</div>
                        <div class="login-name">${member.name}</div>
                        <div class="login-role">${member.roleDescription || member.role}</div>
                        ${pendingCount > 0 ? `<div class="login-badge pending">${pendingCount} ◊û◊©◊ô◊û◊ï◊™</div>` : ''}
                    `;
                    
                    grid.appendChild(card);
                });
            });
        }
        
        async function loginUser(userId) {
            currentUser = familyMembers[userId];
            localStorage.setItem('currentUser', userId);
            showMainApp();
            
            // Auto backup for Hagai on login
            if (userId === 'hagai') {
                await performBackup(true); // silent backup
            }
        }
        
        // User Management Modal
        function openUserManagementModal() {
            document.getElementById('userManagementModal').classList.add('active');
            loadCurrentUsers();
        }
        
        function closeUserManagementModal() {
            document.getElementById('userManagementModal').classList.remove('active');
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
        }
        
        function loadCurrentUsers() {
            const container = document.getElementById('currentUsersList');
            container.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                
                const roleText = member.isAdmin ? 'üëë ◊û◊†◊î◊ú/◊™' : 'üë∂ ◊ô◊ú◊ì/◊î';
                
                userItem.innerHTML = `
                    <div class="user-item-info">
                        <div class="user-item-icon">${member.icon}</div>
                        <div class="user-item-details">
                            <div class="user-item-name">${member.name}</div>
                            <div class="user-item-role">${roleText}</div>
                        </div>
                    </div>
                    <div class="user-item-actions">
                        <button class="btn-icon" style="background: #FFF3E0; color: #F57C00;" onclick="editUser('${member.id}')">‚úèÔ∏è</button>
                        <button class="btn-icon btn-delete" onclick="deleteUser('${member.id}')">üóëÔ∏è</button>
                    </div>
                `;
                
                container.appendChild(userItem);
            });
        }
        
        function addNewUser() {
            const name = document.getElementById('newUserName').value.trim();
            const icon = document.getElementById('newUserIcon').value.trim();
            const role = document.getElementById('newUserRole').value;
            
            if (!name) {
                alert('‚ùå ◊†◊ê ◊ú◊î◊ñ◊ô◊ü ◊©◊ù ◊û◊©◊™◊û◊©');
                return;
            }
            
            if (!icon) {
                alert('‚ùå ◊†◊ê ◊ú◊î◊ñ◊ô◊ü ◊ê◊ô◊û◊ï◊í\'◊ô');
                return;
            }
            
            // Check if name already exists
            const nameExists = Object.values(familyMembers).some(m => m.name === name);
            if (nameExists) {
                alert('‚ùå ◊©◊ù ◊û◊©◊™◊û◊© ◊õ◊ë◊® ◊ß◊ô◊ô◊ù');
                return;
            }
            
            const userId = name.toLowerCase().replace(/\s/g, '');
            const isAdmin = role === 'admin';
            
            const colors = ['#E91E63', '#9C27B0', '#3F51B5', '#00BCD4', '#4CAF50', '#FF9800', '#795548'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const newUser = {
                id: userId,
                name: name,
                icon: icon,
                role: isAdmin ? '◊û◊†◊î◊ú/◊™' : '◊ô◊ú◊ì/◊î',
                color: randomColor,
                isAdmin: isAdmin,
                canSpeak: false
            };
            
            // Add to familyMembers
            familyMembers[userId] = newUser;
            
            // Save to localStorage for persistence
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
            
            // Reload list
            loadCurrentUsers();
            
            // Update login grid
            renderLoginCards();
            
            showToast(`‚úÖ ${name} ◊†◊ï◊°◊£/◊î ◊ë◊î◊¶◊ú◊ó◊î!`);
        }
        
        function editUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            const newName = prompt(`‚úèÔ∏è ◊©◊ù ◊ó◊ì◊© ◊¢◊ë◊ï◊® ${user.name}:`, user.name);
            if (!newName || newName.trim() === '') return;
            
            const newIcon = prompt(`‚úèÔ∏è ◊ê◊ô◊û◊ï◊í'◊ô ◊ó◊ì◊© ◊¢◊ë◊ï◊® ${user.name}:`, user.icon);
            if (!newIcon || newIcon.trim() === '') return;
            
            // Update user
            familyMembers[userId].name = newName.trim();
            familyMembers[userId].icon = newIcon.trim();
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`‚úÖ ${newName} ◊¢◊ï◊ì◊õ◊ü/◊î ◊ë◊î◊¶◊ú◊ó◊î!`);
        }
        
        function deleteUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            // Prevent deletion of admins
            if (user.isAdmin) {
                alert('‚ùå ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊û◊ó◊ï◊ß ◊û◊†◊î◊ú◊ô◊ù (◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™)');
                return;
            }
            
            if (!confirm(`üóëÔ∏è ◊î◊ê◊ù ◊ú◊û◊ó◊ï◊ß ◊ê◊™ ${user.name}?\n\n‚ö†Ô∏è ◊ñ◊î ◊ô◊û◊ó◊ß ◊í◊ù ◊ê◊™ ◊õ◊ú ◊î◊û◊©◊ô◊û◊ï◊™ ◊î◊û◊ï◊ß◊¶◊ï◊™ ◊ú◊ï/◊ú◊î!`)) {
                return;
            }
            
            // Delete from familyMembers
            delete familyMembers[userId];
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Delete all tasks assigned to this user
            tasksRef.once('value', (snapshot) => {
                const tasksData = snapshot.val() || {};
                Object.keys(tasksData).forEach(taskId => {
                    if (tasksData[taskId].assignedTo === userId) {
                        tasksRef.child(taskId).remove();
                    }
                });
            });
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`üóëÔ∏è ${user.name} ◊†◊û◊ó◊ß/◊î ◊ë◊î◊¶◊ú◊ó◊î`);
        }
        
        function showMainApp() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            
            // Update header
            document.getElementById('userAvatar').textContent = currentUser.icon;
            document.getElementById('userName').textContent = currentUser.name;
            document.getElementById('userRole').textContent = currentUser.role;
            
            // Show/hide stats screen navigation - only for admins
            const navStats = document.getElementById('navStats');
            if (currentUser.isAdmin) {
                navStats.style.display = 'flex';
            } else {
                navStats.style.display = 'none';
            }
            
            // Show/hide top performers card - only for Hagai
            const topPerformersCard = document.getElementById('topPerformersCard');
            if (currentUser.id === 'hagai') {
                topPerformersCard.classList.remove('hidden');
            } else {
                topPerformersCard.classList.add('hidden');
            }
            
            // Show deletion history, backup, restore buttons ONLY for Hagai
            if (currentUser.id === 'hagai') {
                document.getElementById('btnDeletionHistory').classList.remove('hidden');
                document.getElementById('btnBackup').classList.remove('hidden');
                document.getElementById('btnRestore').classList.remove('hidden');
                setupAutoBackup();
            } else {
                // Hide for all other users
                document.getElementById('btnDeletionHistory').classList.add('hidden');
                document.getElementById('btnBackup').classList.add('hidden');
                document.getElementById('btnRestore').classList.add('hidden');
            }
            
            // Set default filter based on user role
            if (currentUser.isAdmin) {
                // Admins see "pending" by default
                currentFilter = 'pending';
                document.querySelector('.filter-btn[onclick*="pending"]').classList.add('active');
            } else {
                // Regular users see "my tasks" by default
                currentFilter = 'my-tasks';
                const myTasksBtn = document.getElementById('myTasksFilter');
                // Remove active from pending
                document.querySelector('.filter-btn[onclick*="pending"]').classList.remove('active');
                // Add active to my-tasks
                myTasksBtn.classList.add('active');
            }
            
            // Setup Firebase listeners
            setupFirebaseListeners();
            
            // Monitor connection status
            monitorConnection();
            
            // Populate assignee grid
            populateAssigneeGrid();
            populateQuickAssigneeGrid();
        }
        
        async function logout() {
            // Auto backup for Hagai before logout
            if (currentUser && currentUser.id === 'hagai') {
                await performBackup(true); // silent backup
            }
            
            currentUser = null;
            localStorage.removeItem('currentUser');
            
            // Remove Firebase listeners
            tasksRef.off();
            shoppingRef.off();
            deletionHistoryRef.off();
            
            showLoginScreen();
        }
        
        // ==================== FIREBASE LISTENERS ====================
        
        function setupFirebaseListeners() {
            // Tasks listener
            tasksRef.on('value', (snapshot) => {
                tasks = snapshot.val() || {};
                loadTasks();
                loadStats();
                updateTabCounts();
            });
            
            // Shopping listener
            shoppingRef.on('value', (snapshot) => {
                shopping = snapshot.val() || {};
                loadShopping();
                loadStats();
                updateTabCounts();
            });
            
            // Deletion history listener
            deletionHistoryRef.on('value', (snapshot) => {
                deletionHistory = snapshot.val() || [];
            });
        }
        
        function updateTabCounts() {
            // Count pending tasks for current user
            const allTasks = Object.values(tasks);
            const visibleTasks = allTasks.filter(t => !t.isPersonal || t.assignedTo === currentUser.id || currentUser.id === 'hagai');
            const pendingTasks = visibleTasks.filter(t => t.status === 'pending').length;
            
            // Count pending shopping items
            const allShopping = Object.values(shopping);
            const pendingShopping = allShopping.filter(i => i.status === 'pending').length;
            
            // Update bottom nav badges
            const navTasksBadge = document.getElementById('navTasksBadge');
            const navShoppingBadge = document.getElementById('navShoppingBadge');
            
            if (navTasksBadge) {
                navTasksBadge.textContent = pendingTasks;
                navTasksBadge.style.display = pendingTasks > 0 ? 'block' : 'none';
            }
            
            if (navShoppingBadge) {
                navShoppingBadge.textContent = pendingShopping;
                navShoppingBadge.style.display = pendingShopping > 0 ? 'block' : 'none';
            }
        }
        
        function monitorConnection() {
            const connectedRef = db.ref('.info/connected');
            connectedRef.on('value', (snap) => {
                isOnline = snap.val() === true;
                updateSyncStatus();
            });
        }
        
        function updateSyncStatus() {
            const statusDiv = document.getElementById('syncStatus');
            if (!statusDiv) return;
            
            if (isSyncing) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #FFA500;"></span> ◊û◊°◊†◊õ◊®◊ü...';
            } else if (isOnline) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #4CAF50;"></span> ◊û◊ó◊ï◊ë◊®';
            } else {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #f44336;"></span> ◊ú◊ê ◊û◊ó◊ï◊ë◊®';
            }
        }
        
        // ==================== TABS ====================
        
        function switchScreen(screenName) {
            // Update bottom nav buttons
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('nav' + screenName.charAt(0).toUpperCase() + screenName.slice(1)).classList.add('active');
            
            // Update screen content
            document.getElementById('tasksTab').classList.toggle('hidden', screenName !== 'tasks');
            document.getElementById('shoppingTab').classList.toggle('hidden', screenName !== 'shopping');
            document.getElementById('statsScreen').classList.toggle('hidden', screenName !== 'stats');
            
            // Show/hide FAB based on screen
            const fab = document.querySelector('.fab');
            if (screenName === 'stats') {
                fab.style.display = 'none';
            } else {
                fab.style.display = 'flex';
            }
            
            // Clear search when leaving tabs
            if (screenName !== 'shopping') {
                shoppingSearchQuery = '';
                const searchInput = document.getElementById('shoppingSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
            
            if (screenName !== 'tasks') {
                tasksSearchQuery = '';
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
        }
        
        // Keep old switchTab for compatibility
        function switchTab(tabName) {
            switchScreen(tabName);
        }
        
        // ==================== TASKS ====================
        
        function populateAssigneeGrid() {
            const grid = document.getElementById('assigneeGrid');
            grid.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.style.color = member.color;
                btn.onclick = (e) => selectAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectAssignee(memberId, event) {
            selectedAssignee = memberId;
            
            // Update UI
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function selectPriority(priority, event) {
            selectedPriority = priority;
            
            // Update UI
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        // Quick Assignee Grid for Quick Add
        let quickSelectedAssignee = null;
        
        function populateQuickAssigneeGrid() {
            const grid = document.getElementById('quickAssigneeGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.style.color = member.color;
                btn.onclick = (e) => selectQuickAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectQuickAssignee(memberId, event) {
            quickSelectedAssignee = memberId;
            
            // Update UI
            const grid = document.getElementById('quickAssigneeGrid');
            grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function addQuickTask() {
            const input = document.getElementById('quickTaskInput');
            const taskName = input.value.trim();
            
            if (!taskName) {
                alert('‚ùå ◊†◊ê ◊ú◊î◊ñ◊ô◊ü ◊©◊ù ◊û◊©◊ô◊û◊î');
                return;
            }
            
            if (!quickSelectedAssignee) {
                alert('‚ùå ◊†◊ê ◊ú◊ë◊ó◊ï◊® ◊ú◊û◊ô ◊ú◊î◊ß◊¶◊ï◊™ ◊ê◊™ ◊î◊û◊©◊ô◊û◊î');
                return;
            }
            
            const assignee = familyMembers[quickSelectedAssignee];
            
            const newTask = {
                id: 'task_' + Date.now(),
                title: taskName,
                description: '',
                assignedTo: assignee.id,
                assignedToName: assignee.name,
                assignedToIcon: assignee.icon,
                assignedToColor: assignee.color,
                priority: 'medium',
                status: 'pending',
                createdAt: Date.now(),
                createdBy: currentUser.name,
                createdById: currentUser.id,
                isPinned: false,
                isPersonal: assignee.id === currentUser.id, // ‚Üê ◊û◊©◊ô◊û◊î ◊¢◊¶◊û◊ê◊ô◊™ ◊ê◊ù ◊û◊ï◊°◊ô◊£ ◊ú◊¢◊¶◊û◊ï
                isRecurring: false,
                dueDate: null
            };
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(newTask.id).set(newTask)
                .then(() => {
                    input.value = '';
                    quickSelectedAssignee = null;
                    
                    // Reset selection
                    const grid = document.getElementById('quickAssigneeGrid');
                    grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
                    
                    showToast(`‚úÖ ◊û◊©◊ô◊û◊î ◊†◊ï◊°◊§◊î ◊ú-${assignee.name}!`);
                })
                .catch(error => {
                    console.error('Error adding task:', error);
                    alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊°◊§◊™ ◊î◊û◊©◊ô◊û◊î');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // FAB - Smart modal opener based on active tab
        function openFABModal() {
            const tasksTab = document.getElementById('tasksTab');
            const shoppingTab = document.getElementById('shoppingTab');
            
            if (!tasksTab.classList.contains('hidden')) {
                // Tasks tab is active - open task modal
                openAddTaskModal();
            } else if (!shoppingTab.classList.contains('hidden')) {
                // Shopping tab is active - open shopping modal
                openAddShoppingModal();
            } else {
                // Default to task modal
                openAddTaskModal();
            }
        }
        
        function openAddTaskModal() {
            document.getElementById('addTaskModal').classList.add('active');
            
            // Show recurring option only for admins
            const recurringGroup = document.getElementById('recurringGroup');
            if (currentUser.isAdmin) {
                recurringGroup.style.display = 'block';
            } else {
                recurringGroup.style.display = 'none';
            }
        }
        
        function closeAddTaskModal() {
            document.getElementById('addTaskModal').classList.remove('active');
            document.getElementById('addTaskForm').reset();
            selectedAssignee = null;
            selectedPriority = 'medium';
            
            // Reset recurring options
            document.getElementById('recurringOptions').style.display = 'none';
            
            // Reset selections
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.priority-btn[onclick*="medium"]').classList.add('selected');
        }
        
        function toggleRecurringOptions() {
            const isRecurring = document.getElementById('taskIsRecurring').checked;
            const options = document.getElementById('recurringOptions');
            options.style.display = isRecurring ? 'block' : 'none';
        }
        
        function submitTask(event) {
            event.preventDefault();
            
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const dueDate = document.getElementById('taskDueDate').value;
            const isPersonal = document.getElementById('taskIsPersonal').checked;
            const isRecurring = document.getElementById('taskIsRecurring') ? document.getElementById('taskIsRecurring').checked : false;
            const recurringType = isRecurring ? document.getElementById('recurringType').value : null;
            
            if (!title || !selectedAssignee) {
                alert('◊†◊ê ◊ú◊û◊ú◊ê ◊ê◊™ ◊õ◊ú ◊î◊©◊ì◊ï◊™ ◊î◊ó◊ï◊ë◊î');
                return;
            }
            
            const assignedUser = familyMembers[selectedAssignee];
            const taskId = 'task_' + Date.now();
            
            const task = {
                id: taskId,
                title,
                description,
                assignedTo: selectedAssignee,
                assignedToName: assignedUser.name,
                assignedToIcon: assignedUser.icon,
                assignedToColor: assignedUser.color,
                dueDate,
                priority: selectedPriority,
                status: 'pending',
                createdAt: Date.now(),
                createdBy: currentUser.name,
                createdById: currentUser.id,
                completedAt: null,
                completedBy: null,
                completedById: null,
                isPersonal,
                isPinned: false,
                notes: [],
                isRecurring,
                recurringType,
                lastCompletedAt: null
            };
            
            // Add to Firebase
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).set(task)
                .then(() => {
                    console.log('‚úÖ ◊û◊©◊ô◊û◊î ◊†◊ï◊°◊§◊î ◊ú-Firebase');
                    closeAddTaskModal();
                })
                .catch(error => {
                    console.error('‚ùå ◊©◊í◊ô◊ê◊î:', error);
                    alert('◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊°◊§◊™ ◊î◊û◊©◊ô◊û◊î');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadTasks() {
            const container = document.getElementById('tasksList');
            container.innerHTML = '';
            
            let filteredTasks = Object.values(tasks);
            
            // Filter by visibility based on user role
            if (currentUser.isAdmin) {
                // Admins (Liat and Hagai) see all non-personal tasks + their own personal tasks
                // Hagai sees everything including all personal tasks
                if (currentUser.id !== 'hagai') {
                    // Liat sees all tasks except personal tasks of others
                    filteredTasks = filteredTasks.filter(task => 
                        !task.isPersonal || task.assignedTo === currentUser.id
                    );
                }
                // Hagai sees ALL tasks (no filter)
            } else {
                // Regular users see: their own tasks only (both personal and regular)
                filteredTasks = filteredTasks.filter(task => 
                    task.assignedTo === currentUser.id
                );
            }
            
            // Apply search filter
            if (tasksSearchQuery) {
                filteredTasks = filteredTasks.filter(task => 
                    task.title.toLowerCase().includes(tasksSearchQuery.toLowerCase()) ||
                    (task.description && task.description.toLowerCase().includes(tasksSearchQuery.toLowerCase())) ||
                    (task.assignedToName && task.assignedToName.toLowerCase().includes(tasksSearchQuery.toLowerCase()))
                );
            }
            
            // Apply status/type filter
            if (currentFilter === 'pending') {
                filteredTasks = filteredTasks.filter(t => t.status === 'pending');
            } else if (currentFilter === 'completed') {
                filteredTasks = filteredTasks.filter(t => t.status === 'completed');
            } else if (currentFilter === 'personal') {
                // Show only MY personal tasks (tasks I created for myself)
                filteredTasks = filteredTasks.filter(t => {
                    // Personal task must be mine (assigned to me)
                    return t.isPersonal === true && t.assignedTo === currentUser.id;
                });
            } else if (currentFilter === 'my-tasks') {
                // Show only tasks assigned to me that are pending
                // Exclude recurring tasks that were completed today
                const today = new Date().setHours(0, 0, 0, 0);
                filteredTasks = filteredTasks.filter(t => {
                    // Must be assigned to me
                    if (t.assignedTo !== currentUser.id) return false;
                    
                    // If completed, don't show
                    if (t.status === 'completed') return false;
                    
                    // If recurring and completed today, don't show
                    if (t.isRecurring && t.lastCompletedAt) {
                        const completedDate = new Date(t.lastCompletedAt).setHours(0, 0, 0, 0);
                        if (completedDate === today) {
                            return false; // Hide tasks completed today
                        }
                    }
                    
                    return true;
                });
            }
            
            // Sort: pinned first, then by status, then by date
            // Note: In 'my-tasks' filter, don't push personal tasks to the end
            filteredTasks.sort((a, b) => {
                // Pinned always first
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                
                // Pending before completed
                if (a.status === 'pending' && b.status === 'completed') return -1;
                if (a.status === 'completed' && b.status === 'pending') return 1;
                
                // Within same status: regular tasks before personal tasks
                // EXCEPT in 'my-tasks' and 'personal' filters where we don't separate
                if (a.status === b.status && currentFilter !== 'my-tasks' && currentFilter !== 'personal') {
                    if (!a.isPersonal && b.isPersonal) return -1;
                    if (a.isPersonal && !b.isPersonal) return 1;
                }
                
                // Finally by date
                return b.createdAt - a.createdAt;
            });
            
            // Update filter counts
            const allTasks = Object.values(tasks).filter(t => {
                if (currentUser.isAdmin) {
                    if (currentUser.id === 'hagai') return true; // Hagai sees all
                    return !t.isPersonal || t.assignedTo === currentUser.id; // Liat sees all except others' personal
                }
                return t.assignedTo === currentUser.id; // Regular users see only their tasks
            });
            
            // Helper function to check if task should be counted
            const today = new Date().setHours(0, 0, 0, 0);
            const shouldCountTask = (t) => {
                // Don't count completed tasks
                if (t.status === 'completed') return false;
                
                // Don't count recurring tasks completed today
                if (t.isRecurring && t.lastCompletedAt) {
                    const completedDate = new Date(t.lastCompletedAt).setHours(0, 0, 0, 0);
                    if (completedDate === today) return false;
                }
                
                return true;
            };
            
            const pending = allTasks.filter(t => shouldCountTask(t) && t.status === 'pending').length;
            const personal = allTasks.filter(t => shouldCountTask(t) && t.isPersonal && t.assignedTo === currentUser.id).length;
            const myTasks = allTasks.filter(t => shouldCountTask(t) && t.assignedTo === currentUser.id).length;
            
            document.getElementById('pendingTasksCount').textContent = pending;
            document.getElementById('personalTasksCount').textContent = personal;
            document.getElementById('myTasksCount').textContent = myTasks;
            
            if (filteredTasks.length === 0) {
                const emptyMessage = tasksSearchQuery 
                    ? `◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ë◊ï◊® "${tasksSearchQuery}"`
                    : '◊ê◊ô◊ü ◊û◊©◊ô◊û◊ï◊™ ◊ú◊î◊¶◊í◊î';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üìã</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredTasks.forEach((task, index) => {
                const taskEl = createTaskElement(task, index);
                container.appendChild(taskEl);
            });
        }
        
        function createTaskElement(task, index) {
            const div = document.createElement('div');
            div.className = `item ${task.isPinned ? 'pinned' : ''} ${task.status === 'completed' ? 'completed' : ''} ${task.isPersonal ? 'personal-task' : ''}`;
            div.setAttribute('data-task-id', task.id);
            div.dataset.itemId = task.id;
            
            const priorityLabels = {
                high: { emoji: 'üî¥', class: 'badge-priority-high', text: '◊í◊ë◊ï◊î◊î' },
                medium: { emoji: 'üü°', class: 'badge-priority-medium', text: '◊®◊í◊ô◊ú◊î' },
                low: { emoji: 'üü¢', class: 'badge-priority-low', text: '◊†◊û◊ï◊õ◊î' }
            };
            
            const priority = priorityLabels[task.priority];
            const isAdmin = currentUser.isAdmin;
            
            const dueDate = task.dueDate ? new Date(task.dueDate) : null;
            
            // Build action buttons
            let actions = '';
            
            if (task.status === 'pending') {
                actions += `<button class="btn-icon btn-complete" onclick="completeTask('${task.id}')">‚úì</button>`;
            }
            
            if (isAdmin) {
                actions += `<button class="btn-icon btn-delete" onclick="deleteTask('${task.id}')">üóëÔ∏è</button>`;
            }
            
            // Add to Calendar button - always show
            actions += `<button class="btn-icon btn-calendar" onclick="addToCalendar('${task.id}')" title="◊î◊ï◊°◊£ ◊ú◊ô◊ï◊û◊ü">üìÖ</button>`;
            
            // Creator name (only if different from assignee)
            let creatorText = '';
            if (task.createdById && task.createdBy && task.createdById !== task.assignedTo) {
                creatorText = ` <span style="font-size: 0.75rem; color: #666;">(${task.createdBy})</span>`;
            }
            
            div.innerHTML = `
                <div class="swipe-indicator left">‚úì</div>
                <div class="swipe-indicator right">‚Ü©Ô∏è</div>
                <div class="swipe-indicator up">‚¨ÜÔ∏è</div>
                <div class="swipe-indicator down">‚¨áÔ∏è</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${task.isPinned ? 'üìå ' : ''}${task.isRecurring ? 'üîÑ ' : ''}${task.isPersonal ? 'üîí ' : ''}${task.title}${task.description ? ` (${task.description})` : ''} ‚Ä¢ ${task.assignedToIcon} ${task.assignedToName}${task.createdAt ? ` ‚Ä¢ ${new Date(task.createdAt).toLocaleDateString('he-IL')}${creatorText}` : ''}${task.status === 'completed' && task.completedBy ? ` ‚Ä¢ ‚úì ${task.completedBy}` : ''}
                </div>
                <div class="item-actions">${actions}</div>
            `;
            
            // Add touch handlers for swipe
            setupTaskSwipeHandlers(div, task);
            
            return div;
        }
        
        // Swipe Handler Setup for Tasks
        function setupTaskSwipeHandlers(element, task) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            let longPressTimer = null;
            let canSwipeVertical = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                canSwipeVertical = false;
                element.classList.add('swiping');
                
                // Start long press timer for vertical swipe (0.5 seconds)
                longPressTimer = setTimeout(() => {
                    canSwipeVertical = true;
                    // Vibrate if available
                    if (navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                }, 500);
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Cancel long press if moved horizontally
                if (Math.abs(diffX) > 10 && longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Horizontal swipe (immediate) - always block scroll for horizontal movement
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (canSwipeVertical && Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Vertical swipe after long press - show indicator only, don't move element
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swiping up - will move to TOP of list
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                        upIndicator.textContent = '‚¨ÜÔ∏è ◊ú◊®◊ê◊©';
                    } else if (diffY > 30) {
                        // Swiping down - will move to BOTTOM of list
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                        downIndicator.textContent = '‚¨áÔ∏è ◊ú◊°◊ï◊£';
                    }
                }
                // If vertical movement but canSwipeVertical is false, allow normal scrolling
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as complete)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'pending') {
                        completeTask(task.id);
                    }
                }
                // Swipe right (uncomplete)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'completed') {
                        uncompleteTask(task.id);
                    }
                }
                // Swipe up - move to TOP of list
                else if (canSwipeVertical && diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveTaskUp(task.id);
                }
                // Swipe down - move to BOTTOM of list
                else if (canSwipeVertical && diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveTaskDown(task.id);
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                    canSwipeVertical = false;
                }
            });
        }
        
        // Move task up (increase priority by changing createdAt)
        function moveTaskUp(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set createdAt to future (moves to top)
            const newCreatedAt = Date.now() + 1000000;
            
            tasksRef.child(taskId).update({
                createdAt: newCreatedAt
            }).then(() => {
                showToast('‚¨ÜÔ∏è ◊î◊û◊©◊ô◊û◊î ◊¢◊ú◊™◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        // Move task down (decrease priority by changing createdAt)
        function moveTaskDown(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set createdAt to very old (moves to bottom) - use 1 to ensure it's the oldest
            const newCreatedAt = 1;
            
            tasksRef.child(taskId).update({
                createdAt: newCreatedAt
            }).then(() => {
                showToast('‚¨áÔ∏è ◊î◊û◊©◊ô◊û◊î ◊ô◊®◊ì◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function completeTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            if (task.isRecurring) {
                // For recurring tasks, reset instead of marking as completed
                tasksRef.child(taskId).update({
                    lastCompletedAt: Date.now(),
                    lastCompletedBy: currentUser.name,
                    lastCompletedById: currentUser.id
                }).then(() => {
                    console.log('‚úÖ ◊û◊©◊ô◊û◊î ◊û◊ó◊ñ◊ï◊®◊ô◊™ ◊î◊ï◊©◊ú◊û◊î ◊ï◊ê◊ï◊§◊°◊î');
                    // Show notification
                    showToast(`‚úÖ ${task.title} ◊ë◊ï◊¶◊¢◊î! ◊î◊û◊©◊ô◊û◊î ◊™◊ó◊ñ◊ï◊® ${task.recurringType === 'daily' ? '◊û◊ó◊®' : '◊ë◊©◊ë◊ï◊¢ ◊î◊ë◊ê'}`);
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            } else {
                // Regular task - mark as completed
                tasksRef.child(taskId).update({
                    status: 'completed',
                    completedAt: Date.now(),
                    completedBy: currentUser.name,
                    completedById: currentUser.id
                }).then(() => {
                    showToast('‚úÖ ◊î◊û◊©◊ô◊û◊î ◊î◊ï◊©◊ú◊û◊î');
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            }
        }
        
        function uncompleteTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set dueDate to today when uncompleting
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            tasksRef.child(taskId).update({
                status: 'pending',
                completedAt: null,
                completedBy: null,
                completedById: null,
                dueDate: today.getTime()
            }).then(() => {
                showToast('‚Ü©Ô∏è ◊î◊û◊©◊ô◊û◊î ◊ó◊ñ◊®◊î ◊ú◊û◊¶◊ë ◊û◊û◊™◊ô◊ü ◊¢◊ù ◊™◊ê◊®◊ô◊ö ◊î◊ô◊ï◊ù');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #4CAF50, #66BB6A);
                color: white;
                padding: 15px 30px;
                border-radius: 12px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: slideUp 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function addToCalendar(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            // Use task's dueDate or today's date as default
            const dueDate = task.dueDate ? new Date(task.dueDate) : new Date();
            
            // Format task details for Google Calendar
            const title = task.title;
            const description = task.description || '';
            const priority = task.priority === 'high' ? 'üî¥ ◊¢◊ì◊ô◊§◊ï◊™ ◊í◊ë◊ï◊î◊î' : task.priority === 'medium' ? 'üü° ◊¢◊ì◊ô◊§◊ï◊™ ◊®◊í◊ô◊ú◊î' : 'üü¢ ◊¢◊ì◊ô◊§◊ï◊™ ◊†◊û◊ï◊õ◊î';
            const assignedTo = `◊û◊ï◊ß◊¶◊î ◊ú: ${task.assignedToName}`;
            
            const fullDescription = `${description}\n\n${priority}\n${assignedTo}`;
            
            // Format date for Google Calendar (YYYYMMDDTHHMMSS format)
            const startDate = new Date(dueDate);
            startDate.setHours(9, 0, 0); // Set to 9:00 AM
            
            const endDate = new Date(dueDate);
            endDate.setHours(10, 0, 0); // Set to 10:00 AM (1 hour duration)
            
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
            };
            
            const startDateFormatted = formatDate(startDate);
            const endDateFormatted = formatDate(endDate);
            
            // Build Google Calendar URL
            const baseUrl = 'https://calendar.google.com/calendar/render';
            const params = new URLSearchParams({
                action: 'TEMPLATE',
                text: title,
                dates: `${startDateFormatted}/${endDateFormatted}`,
                details: fullDescription,
                location: '',
                trp: 'false'
            });
            
            const calendarUrl = `${baseUrl}?${params.toString()}`;
            
            // Open in new window
            window.open(calendarUrl, '_blank');
            
            showToast('üìÖ ◊†◊§◊™◊ó Google Calendar!');
        }
        
        function deleteTask(taskId) {
            if (!currentUser.isAdmin) {
                alert('‚ùå ◊®◊ß ◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™ ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊û◊ó◊ï◊ß ◊û◊©◊ô◊û◊ï◊™');
                return;
            }
            
            const task = tasks[taskId];
            if (!task) return;
            
            if (!confirm(`◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó ◊©◊ë◊®◊¶◊ï◊†◊ö ◊ú◊û◊ó◊ï◊ß ◊ê◊™ ◊î◊û◊©◊ô◊û◊î "${task.title}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'task',
                item: task.title,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: task
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                tasksRef.child(taskId).remove()
            ]).then(() => {
                console.log('‚úÖ ◊û◊©◊ô◊û◊î ◊†◊û◊ó◊ß◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).update({
                isPinned: !task.isPinned
            }).then(() => {
                console.log('üìå ◊î◊¶◊û◊ì◊î ◊©◊ï◊†◊™◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function readTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            if (!('speechSynthesis' in window)) {
                alert('◊î◊ì◊§◊ì◊§◊ü ◊ú◊ê ◊™◊ï◊û◊ö ◊ë◊î◊ß◊®◊ê◊î. ◊†◊°◊î ◊ú◊î◊©◊™◊û◊© ◊ë-Chrome ◊ê◊ï Edge.');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            let speechText = `◊û◊©◊ô◊û◊î: ${task.title}. `;
            
            if (task.description) {
                speechText += `${task.description}. `;
            }
            
            speechText += `◊ê◊ó◊®◊ê◊ô: ${task.assignedToName}. `;
            
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const formattedDate = dueDate.toLocaleDateString('he-IL');
                speechText += `◊™◊ê◊®◊ô◊ö ◊ô◊¢◊ì: ${formattedDate}. `;
            }
            
            const priorityText = {
                high: '◊¢◊ì◊ô◊§◊ï◊™ ◊í◊ë◊ï◊î◊î',
                medium: '◊¢◊ì◊ô◊§◊ï◊™ ◊®◊í◊ô◊ú◊î',
                low: '◊¢◊ì◊ô◊§◊ï◊™ ◊†◊û◊ï◊õ◊î'
            };
            speechText += priorityText[task.priority] + '. ';
            
            if (task.status === 'completed') {
                speechText += `◊î◊û◊©◊ô◊û◊î ◊ë◊ï◊¶◊¢◊î ◊¢◊ú ◊ô◊ì◊ô ${task.completedBy}. `;
            } else {
                speechText += '◊î◊û◊©◊ô◊û◊î ◊û◊û◊™◊ô◊†◊î ◊ú◊ë◊ô◊¶◊ï◊¢.';
            }
            
            const utterance = new SpeechSynthesisUtterance(speechText);
            utterance.lang = 'he-IL';
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            const readButton = taskElement ? taskElement.querySelector('.read-btn') : null;
            
            if (readButton) {
                readButton.classList.add('reading');
            }
            
            utterance.onend = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
            };
            
            utterance.onerror = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
                alert('◊©◊í◊ô◊ê◊î ◊ë◊î◊ß◊®◊ê◊™ ◊î◊û◊©◊ô◊û◊î');
            };
            
            window.speechSynthesis.speak(utterance);
        }
        
        function filterTasks(filter, event) {
            currentFilter = filter;
            
            // Update filter buttons
            const tasksTab = document.getElementById('tasksTab');
            tasksTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadTasks();
        }
        
        function filterTasksBySearch() {
            tasksSearchQuery = document.getElementById('tasksSearchInput').value.trim();
            loadTasks();
        }
        
        function filterByMember(memberId) {
            // Switch to tasks tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab')[0].classList.add('active'); // First tab is tasks
            
            document.getElementById('tasksTab').classList.remove('hidden');
            document.getElementById('shoppingTab').classList.add('hidden');
            
            // Set filter to pending
            currentFilter = 'pending';
            document.querySelectorAll('#tasksTab .filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#tasksTab .filter-btn')[0].classList.add('active'); // First filter is pending
            
            // Set search to member name
            const member = familyMembers[memberId];
            if (member) {
                tasksSearchQuery = member.name;
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = member.name;
                }
                loadTasks();
            }
        }
        
        // ==================== NOTES ====================
        
        function openNotesModal(taskId) {
            currentTaskForNotes = taskId;
            const task = tasks[taskId];
            if (!task) return;
            
            const modal = document.getElementById('notesModal');
            const notesList = document.getElementById('notesList');
            const addNoteSection = document.getElementById('addNoteSection');
            
            // Check if user can add notes (only assigned user)
            const canAddNote = task.assignedTo === currentUser.id;
            addNoteSection.style.display = canAddNote ? 'block' : 'none';
            
            // Render existing notes
            notesList.innerHTML = '';
            if (task.notes && task.notes.length > 0) {
                task.notes.forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note-item';
                    noteEl.style.borderRightColor = note.authorColor || '#E0E0E0';
                    
                    const date = new Date(note.createdAt);
                    noteEl.innerHTML = `
                        <div class="note-header">
                            <span class="note-author">
                                ${note.authorIcon} ${note.authorName}
                            </span>
                            <span>${date.toLocaleDateString('he-IL')} ${date.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                        <div class="note-text">${note.text}</div>
                    `;
                    notesList.appendChild(noteEl);
                });
            } else {
                notesList.innerHTML = '<div class="empty-state"><div class="empty-icon">üí¨</div><div class="empty-text">◊ê◊ô◊ü ◊î◊¢◊®◊ï◊™ ◊ú◊û◊©◊ô◊û◊î ◊ñ◊ï</div></div>';
            }
            
            modal.classList.add('active');
        }
        
        function closeNotesModal() {
            document.getElementById('notesModal').classList.remove('active');
            document.getElementById('newNoteText').value = '';
            currentTaskForNotes = null;
        }
        
        function addNote() {
            const text = document.getElementById('newNoteText').value.trim();
            if (!text) {
                alert('‚ùå ◊†◊ê ◊ú◊î◊ñ◊ô◊ü ◊™◊ï◊õ◊ü ◊ú◊î◊¢◊®◊î');
                return;
            }
            
            const task = tasks[currentTaskForNotes];
            if (!task) return;
            
            if (task.assignedTo !== currentUser.id) {
                alert('‚ùå ◊®◊ß ◊û◊ß◊ë◊ú ◊î◊û◊©◊ô◊û◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊ï◊°◊ô◊£ ◊î◊¢◊®◊ï◊™');
                return;
            }
            
            const note = {
                text,
                authorId: currentUser.id,
                authorName: currentUser.name,
                authorIcon: currentUser.icon,
                authorColor: currentUser.color,
                createdAt: Date.now()
            };
            
            const notes = task.notes || [];
            notes.push(note);
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(currentTaskForNotes).update({ notes })
                .then(() => {
                    console.log('‚úÖ ◊î◊¢◊®◊î ◊†◊ï◊°◊§◊î');
                    document.getElementById('newNoteText').value = '';
                    openNotesModal(currentTaskForNotes); // Refresh
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== SHOPPING ====================
        
        function quickAddItem(event) {
            event.preventDefault();
            
            const itemName = document.getElementById('quickItemInput').value.trim();
            if (!itemName) return;
            
            const itemId = 'item_' + Date.now();
            
            const item = {
                id: itemId,
                name: itemName,
                addedBy: currentUser.name,
                addedById: currentUser.id,
                addedByIcon: currentUser.icon,
                addedByColor: currentUser.color,
                addedAt: Date.now(),
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null,
                isPinned: false
            };
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).set(item)
                .then(() => {
                    console.log('‚úÖ ◊§◊®◊ô◊ò ◊†◊ï◊°◊£');
                    document.getElementById('quickItemInput').value = '';
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadShopping() {
            const container = document.getElementById('shoppingList');
            container.innerHTML = '';
            
            let filteredItems = Object.values(shopping);
            
            // Apply search filter
            if (shoppingSearchQuery) {
                filteredItems = filteredItems.filter(item => 
                    item.name.toLowerCase().includes(shoppingSearchQuery.toLowerCase())
                );
            }
            
            // Apply status filter
            if (currentShoppingFilter === 'pending') {
                filteredItems = filteredItems.filter(item => item.status === 'pending');
            } else if (currentShoppingFilter === 'purchased') {
                filteredItems = filteredItems.filter(item => item.status === 'purchased');
            }
            
            // Sort: pinned first, then by status, then by date
            filteredItems.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                if (a.status === 'pending' && b.status === 'purchased') return -1;
                if (a.status === 'purchased' && b.status === 'pending') return 1;
                return b.addedAt - a.addedAt;
            });
            
            if (filteredItems.length === 0) {
                const emptyMessage = shoppingSearchQuery 
                    ? `◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ë◊ï◊® "${shoppingSearchQuery}"`
                    : '◊ê◊ô◊ü ◊§◊®◊ô◊ò◊ô◊ù ◊ú◊î◊¶◊í◊î';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">üõí</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredItems.forEach((item, index) => {
                const itemEl = createShoppingElement(item, index);
                container.appendChild(itemEl);
            });
        }
        
        function createShoppingElement(item, index) {
            const div = document.createElement('div');
            div.className = `item ${item.isPinned ? 'pinned' : ''} ${item.status === 'purchased' ? 'purchased' : ''}`;
            div.dataset.itemId = item.id;
            
            const isAdmin = currentUser.isAdmin;
            
            const addedDate = new Date(item.addedAt);
            
            // Build action buttons
            let actions = '';
            
            if (item.status === 'pending') {
                actions += `<button class="btn-icon btn-complete" onclick="purchaseItem('${item.id}')">‚úì</button>`;
            }
            
            if (isAdmin) {
                actions += `<button class="btn-icon btn-delete" onclick="deleteShoppingItem('${item.id}')">üóëÔ∏è</button>`;
            }
            
            div.innerHTML = `
                <div class="swipe-indicator left">‚úì</div>
                <div class="swipe-indicator right">‚Ü©Ô∏è</div>
                <div class="swipe-indicator up">‚¨ÜÔ∏è</div>
                <div class="swipe-indicator down">‚¨áÔ∏è</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${item.isPinned ? 'üìå ' : ''}${item.name} ‚Ä¢ ${item.addedByIcon} ${item.addedBy} ‚Ä¢ üìÖ ${addedDate.toLocaleDateString('he-IL')}${item.status === 'purchased' && item.purchasedBy ? ` ‚Ä¢ ‚úì ${item.purchasedBy}` : ''}
                </div>
                <div class="item-actions">${actions}</div>
            `;
            
            // Add touch handlers for swipe
            setupSwipeHandlers(div, item);
            
            return div;
        }
        
        // Swipe Handler Setup
        function setupSwipeHandlers(element, item) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            let longPressTimer = null;
            let canSwipeVertical = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                canSwipeVertical = false;
                element.classList.add('swiping');
                
                // Start long press timer for vertical swipe (0.5 seconds)
                longPressTimer = setTimeout(() => {
                    canSwipeVertical = true;
                    // Vibrate if available
                    if (navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                }, 500);
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Cancel long press if moved horizontally
                if (Math.abs(diffX) > 10 && longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Horizontal swipe (immediate) - always block scroll for horizontal movement
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (canSwipeVertical && Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Vertical swipe after long press - show indicator only, don't move element
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swiping up - will move to TOP of list
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                        upIndicator.textContent = '‚¨ÜÔ∏è ◊ú◊®◊ê◊©';
                    } else if (diffY > 30) {
                        // Swiping down - will move to BOTTOM of list
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                        downIndicator.textContent = '‚¨áÔ∏è ◊ú◊°◊ï◊£';
                    }
                }
                // If vertical movement but canSwipeVertical is false, allow normal scrolling
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as purchased)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'pending') {
                        purchaseItem(item.id);
                    }
                }
                // Swipe right (unmark as purchased)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'purchased') {
                        unpurchaseItem(item.id);
                    }
                }
                // Swipe up - move to TOP of list
                else if (canSwipeVertical && diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemUp(item.id);
                }
                // Swipe down - move to BOTTOM of list
                else if (canSwipeVertical && diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemDown(item.id);
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                    canSwipeVertical = false;
                }
            });
        }
        
        // Move shopping item up in the list
        function moveShoppingItemUp(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Increase priority by setting addedAt to now
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: Date.now()
            })
                .then(() => {
                    showToast('‚¨ÜÔ∏è ◊î◊§◊®◊ô◊ò ◊î◊ï◊¢◊ú◊î ◊ú◊û◊¢◊ú◊î ◊ë◊®◊©◊ô◊û◊î');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊¢◊ú◊ê◊™ ◊î◊§◊®◊ô◊ò');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function moveShoppingItemDown(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Set addedAt to 1 (oldest possible) - moves to bottom
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: 1
            })
                .then(() => {
                    showToast('‚¨áÔ∏è ◊î◊§◊®◊ô◊ò ◊î◊ï◊®◊ì ◊ú◊°◊ï◊£ ◊î◊®◊©◊ô◊û◊î');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊®◊ì◊™ ◊î◊§◊®◊ô◊ò');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function purchaseItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('‚ùå ◊®◊ß ◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™ ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊°◊û◊ü ◊§◊®◊ô◊ò◊ô◊ù ◊õ◊†◊ß◊†◊ï');
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'purchased',
                purchasedAt: Date.now(),
                purchasedBy: currentUser.name,
                purchasedById: currentUser.id
            }).then(() => {
                console.log('‚úÖ ◊§◊®◊ô◊ò ◊°◊ï◊û◊ü ◊õ◊†◊ß◊†◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function unpurchaseItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null
            }).then(() => {
                showToast('‚Ü©Ô∏è ◊î◊§◊®◊ô◊ò ◊ó◊ñ◊® ◊ú◊®◊©◊ô◊û◊™ ◊î◊ß◊†◊ô◊ï◊™');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function deleteShoppingItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('‚ùå ◊®◊ß ◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™ ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊û◊ó◊ï◊ß ◊§◊®◊ô◊ò◊ô◊ù');
                return;
            }
            
            const item = shopping[itemId];
            if (!item) return;
            
            if (!confirm(`◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó ◊©◊ë◊®◊¶◊ï◊†◊ö ◊ú◊û◊ó◊ï◊ß ◊ê◊™ "${item.name}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'shopping',
                item: item.name,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: item
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                shoppingRef.child(itemId).remove()
            ]).then(() => {
                console.log('‚úÖ ◊§◊®◊ô◊ò ◊†◊û◊ó◊ß');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinShoppingItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                isPinned: !item.isPinned
            }).then(() => {
                console.log('üìå ◊î◊¶◊û◊ì◊î ◊©◊ï◊†◊™◊î');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function filterShopping(filter, event) {
            currentShoppingFilter = filter;
            
            // Update filter buttons
            const shoppingTab = document.getElementById('shoppingTab');
            shoppingTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadShopping();
        }
        
        function filterShoppingBySearch() {
            shoppingSearchQuery = document.getElementById('shoppingSearchInput').value.trim();
            loadShopping();
        }
        
        // ==================== DELETION HISTORY ====================
        
        function openDeletionHistoryModal() {
            const modal = document.getElementById('deletionHistoryModal');
            const tbody = document.getElementById('deletionHistoryBody');
            
            tbody.innerHTML = '';
            
            if (deletionHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 40px; color: var(--text-secondary);">◊ê◊ô◊ü ◊§◊®◊ô◊ò◊ô◊ù ◊ë◊û◊ó◊ô◊ß◊ï◊™</td></tr>';
            } else {
                deletionHistory.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    const typeIcon = entry.type === 'task' ? 'üìã' : 'üõí';
                    const typeText = entry.type === 'task' ? '◊û◊©◊ô◊û◊î' : '◊ß◊†◊ô◊ô◊î';
                    
                    const canRestore = currentUser.isAdmin;
                    
                    row.innerHTML = `
                        <td>${typeIcon} ${typeText}</td>
                        <td>${entry.item}</td>
                        <td>${entry.deletedBy}</td>
                        <td>${entry.deletedAt}</td>
                        <td>
                            ${canRestore ? `<button class="btn btn-secondary" onclick="restoreItem(${index})">‚Ü©Ô∏è ◊©◊ó◊ñ◊®</button>` : '‚Äî'}
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            }
            
            modal.classList.add('active');
        }
        
        function closeDeletionHistoryModal() {
            document.getElementById('deletionHistoryModal').classList.remove('active');
        }
        
        function restoreItem(index) {
            if (!currentUser.isAdmin) {
                alert('‚ùå ◊®◊ß ◊ó◊í◊ô ◊ï◊ú◊ô◊ê◊™ ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊©◊ó◊ñ◊® ◊§◊®◊ô◊ò◊ô◊ù');
                return;
            }
            
            const entry = deletionHistory[index];
            if (!entry) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Restore the item
            const restorePromise = entry.type === 'task' 
                ? tasksRef.child(entry.originalItem.id).set(entry.originalItem)
                : shoppingRef.child(entry.originalItem.id).set(entry.originalItem);
            
            // Remove from deletion history
            const newHistory = deletionHistory.filter((_, i) => i !== index);
            
            Promise.all([
                restorePromise,
                deletionHistoryRef.set(newHistory)
            ]).then(() => {
                console.log('‚úÖ ◊§◊®◊ô◊ò ◊©◊ï◊ó◊ñ◊®');
                openDeletionHistoryModal(); // Refresh
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function clearDeletionHistory() {
            if (!confirm('◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó ◊©◊ë◊®◊¶◊ï◊†◊ö ◊ú◊†◊ß◊ï◊™ ◊ê◊™ ◊õ◊ú ◊î◊î◊ô◊°◊ò◊ï◊®◊ô◊î?')) {
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            deletionHistoryRef.set([])
                .then(() => {
                    console.log('‚úÖ ◊î◊ô◊°◊ò◊ï◊®◊ô◊î ◊†◊ï◊ß◊™◊î');
                    closeDeletionHistoryModal();
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== STATISTICS ====================
        
        function loadStats() {
            const allTasks = Object.values(tasks);
            const allShopping = Object.values(shopping);
            
            const hasTasks = allTasks.length > 0;
            const hasShopping = allShopping.length > 0;
            
            // Create tabs structure
            let statsHTML = `
                <div class="stat-tabs">
                    <button class="stat-tab active" onclick="switchStatTab('tasks-stat')">üìã ◊û◊©◊ô◊û◊ï◊™</button>
                    <button class="stat-tab" onclick="switchStatTab('shopping-stat')">üõí ◊ß◊†◊ô◊ï◊™</button>
                </div>
            `;
            
            // Tasks stats content
            statsHTML += '<div id="tasks-stat" class="stat-content active">';
            
            if (hasTasks) {
                // Count pending tasks per member
                const memberTaskCounts = {};
                Object.keys(familyMembers).forEach(memberId => {
                    if (memberId !== 'everyone') {
                        memberTaskCounts[memberId] = 0;
                    }
                });
                
                allTasks.forEach(task => {
                    if (task.status === 'pending' && task.assignedTo) {
                        if (memberTaskCounts[task.assignedTo] !== undefined) {
                            memberTaskCounts[task.assignedTo]++;
                        }
                    }
                });
                
                // Display each member with their pending tasks count
                Object.entries(memberTaskCounts).forEach(([memberId, count]) => {
                    const member = familyMembers[memberId];
                    statsHTML += `
                        <div class="member-stat" onclick="filterByMember('${memberId}')">
                            <div class="member-info">
                                <span class="member-icon">${member.icon}</span>
                                <span class="member-name">${member.name}</span>
                            </div>
                            <div class="member-count ${count === 0 ? 'zero' : ''}" style="color: ${member.color}">
                                ${count}
                            </div>
                        </div>
                    `;
                });
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">◊ê◊ô◊ü ◊¢◊ì◊ô◊ô◊ü ◊û◊©◊ô◊û◊ï◊™</p>';
            }
            
            statsHTML += '</div>'; // Close tasks-stat
            
            // Shopping stats content
            statsHTML += '<div id="shopping-stat" class="stat-content">';
            
            if (hasShopping) {
                const totalItems = allShopping.length;
                const purchasedItems = allShopping.filter(i => i.status === 'purchased').length;
                const pendingItems = totalItems - purchasedItems;
                
                statsHTML += `
                    <div class="shopping-stats">
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number pending">${pendingItems}</div>
                            <div class="shopping-stat-label">◊¶◊®◊ô◊ö ◊ú◊ß◊†◊ï◊™</div>
                        </div>
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number purchased">${purchasedItems}</div>
                            <div class="shopping-stat-label">◊†◊ß◊†◊ï</div>
                        </div>
                    </div>
                `;
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">◊ê◊ô◊ü ◊¢◊ì◊ô◊ô◊ü ◊§◊®◊ô◊ò◊ô ◊ß◊†◊ô◊ô◊î</p>';
            }
            
            statsHTML += '</div>'; // Close shopping-stat
            
            document.getElementById('statsContainer').innerHTML = statsHTML;
            
            // Update top performers (only shown to Hagai)
            updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping);
        }
        
        function switchStatTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.stat-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.stat-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }
        
        function updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping) {
            // Top performers (for Hagai only)
            const memberStats = {};
            Object.keys(familyMembers).forEach(memberId => {
                if (memberId !== 'everyone') {
                    memberStats[memberId] = {
                        tasksCompleted: 0,
                        itemsAdded: 0,
                        itemsPurchased: 0,
                        total: 0
                    };
                }
            });
            
            // Count completed tasks
            if (hasTasks) {
                allTasks.forEach(task => {
                    if (task.status === 'completed' && task.completedById && memberStats[task.completedById]) {
                        memberStats[task.completedById].tasksCompleted++;
                        memberStats[task.completedById].total++;
                    }
                });
            }
            
            // Count purchased items
            if (hasShopping) {
                allShopping.forEach(item => {
                    if (item.status === 'purchased' && item.purchasedById && memberStats[item.purchasedById]) {
                        memberStats[item.purchasedById].itemsPurchased++;
                        memberStats[item.purchasedById].total++;
                    }
                });
            }
            
            // Sort by total
            const topPerformers = Object.entries(memberStats)
                .map(([id, stats]) => ({ id, ...stats, ...familyMembers[id] }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 3);
            
            let performersHTML = '';
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            
            topPerformers.forEach((performer, index) => {
                if (performer.total === 0 && index > 0) return;
                
                performersHTML += `
                    <div class="performer-item">
                        <div class="performer-rank">${medals[index]}</div>
                        <div class="performer-info">
                            <div class="performer-name">${performer.icon} ${performer.name}</div>
                            <div class="performer-points">${performer.total} ◊§◊¢◊ï◊ú◊ï◊™ ◊î◊©◊ë◊ï◊¢</div>
                        </div>
                    </div>
                `;
            });
            
            if (!performersHTML) {
                performersHTML = '<div class="empty-state"><div class="empty-icon">üèÜ</div><div class="empty-text">◊¢◊ì◊ô◊ô◊ü ◊ê◊ô◊ü ◊†◊™◊ï◊†◊ô◊ù ◊î◊©◊ë◊ï◊¢</div></div>';
            }
            
            const topPerformersEl = document.getElementById('topPerformers');
            if (topPerformersEl) {
                topPerformersEl.innerHTML = performersHTML;
            }
        }
        
        // ==================== BACKUP SYSTEM (Hagai only) ====================
        
        async function setupAutoBackup() {
            if (!currentUser.canBackup) return;
            
            // Check if File System Access API is supported (Desktop only)
            if (!('showDirectoryPicker' in window)) {
                console.log('üì± ◊†◊ô◊ô◊ì: ◊í◊ô◊ë◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊ú◊ê ◊ñ◊û◊ô◊ü - ◊î◊©◊™◊û◊© ◊ë◊õ◊§◊™◊ï◊® üíæ ◊ú◊í◊ô◊ë◊ï◊ô ◊ô◊ì◊†◊ô');
                return;
            }
            
            console.log('‚úÖ ◊û◊¢◊®◊õ◊™ ◊í◊ô◊ë◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊ñ◊û◊ô◊†◊î (Desktop)');
            
            // Check if this is first time
            const autoBackupEnabled = localStorage.getItem('autoBackupEnabled');
            
            if (autoBackupEnabled === null) {
                const confirmed = confirm('◊î◊ô◊ô ◊ó◊í◊ô! üîê\n\n◊î◊ê◊ù ◊ú◊î◊§◊¢◊ô◊ú ◊í◊ô◊ë◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô?\n\n◊î◊û◊¢◊®◊õ◊™ ◊™◊©◊û◊ï◊® ◊ê◊™ ◊õ◊ú ◊î◊†◊™◊ï◊†◊ô◊ù ◊ë◊™◊ô◊ß◊ô◊ô◊î ◊©◊™◊ë◊ó◊® ◊ë◊õ◊ú ◊õ◊†◊ô◊°◊î ◊ï◊ô◊¶◊ô◊ê◊î.\n\nüíª ◊ñ◊û◊ô◊ü ◊®◊ß ◊ë◊û◊ó◊©◊ë!');
                
                if (confirmed) {
                    localStorage.setItem('autoBackupEnabled', 'true');
                    const success = await requestBackupDirectory();
                    if (success) {
                        await performBackup(true);
                    }
                } else {
                    localStorage.setItem('autoBackupEnabled', 'false');
                }
            } else if (autoBackupEnabled === 'true') {
                try {
                    const savedHandle = await loadDirectoryHandle();
                    
                    if (savedHandle) {
                        if (typeof savedHandle.queryPermission === 'function') {
                            const permission = await savedHandle.queryPermission({ mode: 'readwrite' });
                            
                            if (permission === 'granted') {
                                backupDirectoryHandle = savedHandle;
                                console.log('‚úÖ ◊†◊™◊ô◊ë ◊í◊ô◊ë◊ï◊ô ◊ò◊¢◊ï◊ü ◊û◊î◊ñ◊ô◊õ◊®◊ï◊ü');
                                await performBackup(true);
                            } else if (typeof savedHandle.requestPermission === 'function') {
                                const newPermission = await savedHandle.requestPermission({ mode: 'readwrite' });
                                if (newPermission === 'granted') {
                                    backupDirectoryHandle = savedHandle;
                                    console.log('‚úÖ ◊î◊®◊©◊ê◊™ ◊í◊ô◊ë◊ï◊ô ◊ó◊ï◊ì◊©◊î');
                                    await performBackup(true);
                                } else {
                                    console.log('‚ö†Ô∏è ◊î◊®◊©◊ê◊î ◊†◊ì◊ó◊™◊î - ◊í◊ô◊ë◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊ú◊ê ◊§◊¢◊ô◊ú');
                                }
                            }
                        }
                    } else {
                        console.log('‚ö†Ô∏è ◊ú◊ê ◊†◊û◊¶◊ê ◊†◊™◊ô◊ë ◊©◊û◊ï◊® - ◊û◊ë◊ß◊© ◊†◊™◊ô◊ë ◊ó◊ì◊©');
                        const success = await requestBackupDirectory();
                        if (success) {
                            await performBackup(true);
                        }
                    }
                } catch (err) {
                    console.log('◊©◊í◊ô◊ê◊î ◊ë◊ò◊¢◊ô◊†◊™ ◊†◊™◊ô◊ë ◊í◊ô◊ë◊ï◊ô:', err);
                }
            }
            
            // Auto backup every 5 minutes
            setInterval(() => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            }, 5 * 60 * 1000);
            
            // Auto backup on page unload
            window.addEventListener('beforeunload', () => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            });
        }
        
        async function requestBackupDirectory() {
            try {
                backupDirectoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });
                
                await saveDirectoryHandle(backupDirectoryHandle);
                console.log('‚úÖ ◊†◊™◊ô◊ë ◊í◊ô◊ë◊ï◊ô ◊†◊©◊û◊®');
                return true;
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('◊©◊í◊ô◊ê◊î ◊ë◊ë◊ó◊ô◊®◊™ ◊™◊ô◊ß◊ô◊ô◊î:', err);
                }
                return false;
            }
        }
        
        async function performBackup(silent = true) {
            if (!backupDirectoryHandle) {
                if (!silent) console.log('◊ê◊ô◊ü ◊†◊™◊ô◊ë ◊í◊ô◊ë◊ï◊ô');
                return false;
            }
            
            try {
                // Check permission silently - only if queryPermission is supported
                if (typeof backupDirectoryHandle.queryPermission === 'function') {
                    try {
                        const permission = await backupDirectoryHandle.queryPermission({ mode: 'readwrite' });
                        if (permission !== 'granted') {
                            // Permission lost - don't show any dialog, just skip silently
                            if (!silent) console.warn('Backup folder permission not granted, skipping backup');
                            return false;
                        }
                    } catch (permErr) {
                        // queryPermission might fail on some mobile browsers - continue anyway
                        console.log('‚ö†Ô∏è queryPermission failed, attempting backup anyway:', permErr.message);
                    }
                }
                
                const backupData = {
                    timestamp: new Date().toISOString(),
                    user: currentUser.name,
                    tasks: tasks,
                    shopping: shopping,
                    deletionHistory: deletionHistory,
                    version: '9.2'
                };
                
                // Daily backup - one file per day (overwrites previous)
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const todayFilename = `family-tasks-backup-${dateStr}.json`;
                
                // Get yesterday's date for cleanup
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayDateStr = yesterday.toISOString().split('T')[0];
                const yesterdayFilename = `family-tasks-backup-${yesterdayDateStr}.json`;
                
                try {
                    // Delete yesterday's backup if exists
                    const yesterdayHandle = await backupDirectoryHandle.getFileHandle(yesterdayFilename);
                    await backupDirectoryHandle.removeEntry(yesterdayFilename);
                    console.log(`üóëÔ∏è ◊û◊ó◊ß ◊í◊ô◊ë◊ï◊ô ◊©◊ú ◊ê◊™◊û◊ï◊ú: ${yesterdayFilename}`);
                } catch (err) {
                    // File doesn't exist, that's ok
                }
                
                // Create/overwrite today's backup
                const fileHandle = await backupDirectoryHandle.getFileHandle(todayFilename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(backupData, null, 2));
                await writable.close();
                
                if (!silent) console.log('‚úÖ ◊í◊ô◊ë◊ï◊ô ◊ë◊ï◊¶◊¢ ◊ë◊î◊¶◊ú◊ó◊î:', todayFilename);
                return true;
            } catch (err) {
                console.error('◊©◊í◊ô◊ê◊î ◊ë◊í◊ô◊ë◊ï◊ô:', err);
                return false;
            }
        }
        
        async function performManualBackup() {
            console.log('üîµ performManualBackup ◊†◊ß◊®◊ê');
            console.log('üì± User Agent:', navigator.userAgent);
            
            // Force mobile backup on mobile devices - no permissions needed, just download
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('üì± ◊ñ◊ï◊î◊î ◊õ◊†◊ô◊ô◊ì:', isMobile);
            
            if (isMobile) {
                console.log('üì± ◊û◊õ◊©◊ô◊® ◊†◊ô◊ô◊ì - ◊î◊ï◊®◊ì◊™ ◊ß◊ï◊ë◊• ◊ô◊©◊ô◊®◊î');
                performMobileBackup();
                return;
            }
            
            // Desktop only: use File System Access API
            if (!window.showDirectoryPicker) {
                console.log('üñ•Ô∏è ◊ì◊§◊ì◊§◊ü ◊ú◊ê ◊™◊ï◊û◊ö - ◊î◊ï◊®◊ì◊™ ◊ß◊ï◊ë◊•');
                performMobileBackup();
                return;
            }
            
            console.log('üíª ◊û◊¶◊ë Desktop - ◊û◊©◊™◊û◊© ◊ë-File System Access API');
            
            try {
                if (!backupDirectoryHandle) {
                    backupDirectoryHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });
                    await saveDirectoryHandle(backupDirectoryHandle);
                }
                
                const success = await performBackup(false);
                if (success) {
                    const taskCount = Object.keys(tasks).length;
                    const shoppingCount = Object.keys(shopping || {}).length;
                    alert(`‚úÖ ◊î◊í◊ô◊ë◊ï◊ô ◊ë◊ï◊¶◊¢ ◊ë◊î◊¶◊ú◊ó◊î!\n\nüìã ${taskCount} ◊û◊©◊ô◊û◊ï◊™\nüõí ${shoppingCount} ◊§◊®◊ô◊ò◊ô ◊ß◊†◊ô◊ô◊î`);
                } else {
                    alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊ë◊ô◊¶◊ï◊¢ ◊í◊ô◊ë◊ï◊ô - ◊†◊°◊î ◊©◊ï◊ë');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('◊ë◊ô◊ò◊ï◊ú ◊ë◊ó◊ô◊®◊™ ◊™◊ô◊ß◊ô◊ô◊î');
                    return;
                }
                console.error('Desktop backup error:', error);
                // Fallback to download
                performMobileBackup();
            }
        }
        
        function performMobileBackup() {
            console.log('üîÑ ◊û◊™◊ó◊ô◊ú ◊í◊ô◊ë◊ï◊ô ◊†◊ô◊ô◊ì...');
            
            try {
                // Simple validation
                if (!currentUser || !currentUser.name) {
                    alert('‚ùå ◊ê◊†◊ê ◊î◊™◊ó◊ë◊® ◊™◊ó◊ô◊ú◊î');
                    return;
                }
                
                if (!tasks) {
                    alert('‚è≥ ◊ò◊ï◊¢◊ü ◊†◊™◊ï◊†◊ô◊ù... ◊†◊°◊î ◊©◊ï◊ë ◊ë◊¢◊ï◊ì ◊©◊†◊ô◊ô◊î');
                    return;
                }
                
                // Create backup object
                const backupData = {
                    timestamp: new Date().toISOString(),
                    user: currentUser.name,
                    tasks: tasks || {},
                    shopping: shopping || {},
                    deletionHistory: deletionHistory || [],
                    familyMembers: familyMembers || {},
                    version: '9.4'
                };
                
                // Convert to JSON
                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                
                // Create filename with date and time
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                const filename = `LOBALI-backup-${dateStr}-${timeStr}.json`;
                
                // Create download link and trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                // Success message
                const taskCount = Object.keys(tasks).length;
                const shoppingCount = Object.keys(shopping || {}).length;
                
                console.log('‚úÖ ◊í◊ô◊ë◊ï◊ô ◊î◊ï◊©◊ú◊ù ◊ë◊î◊¶◊ú◊ó◊î:', filename);
                alert(`‚úÖ ◊î◊í◊ô◊ë◊ï◊ô ◊î◊ï◊®◊ì ◊ë◊î◊¶◊ú◊ó◊î!\n\nüìã ${taskCount} ◊û◊©◊ô◊û◊ï◊™\nüõí ${shoppingCount} ◊§◊®◊ô◊ò◊ô◊ù\n\nüìÇ ◊ß◊ï◊ë◊•: ${filename}\n‚úîÔ∏è ◊ë◊ì◊ï◊ß ◊ë◊™◊ô◊ß◊ô◊ô◊™ ◊î◊î◊ï◊®◊ì◊ï◊™`);
                
            } catch (error) {
                console.error('‚ùå ◊©◊í◊ô◊ê◊™ ◊í◊ô◊ë◊ï◊ô ◊†◊ô◊ô◊ì:', error);
                alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊ë◊ô◊¶◊ï◊¢ ◊í◊ô◊ë◊ï◊ô:\n\n' + error.message + '\n\n◊†◊°◊î ◊©◊ï◊ë ◊ê◊ï ◊§◊†◊î ◊ú◊™◊û◊ô◊õ◊î');
            }
        }
        
        async function performRestore() {
            try {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] }
                    }],
                    multiple: false
                });
                
                const file = await fileHandle.getFile();
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (!confirm('◊î◊ê◊ù ◊ê◊™◊î ◊ë◊ò◊ï◊ó ◊©◊ë◊®◊¶◊ï◊†◊ö ◊ú◊©◊ó◊ñ◊® ◊í◊ô◊ë◊ï◊ô? ◊§◊¢◊ï◊ú◊î ◊ñ◊ï ◊™◊ì◊®◊ï◊° ◊ê◊™ ◊î◊†◊™◊ï◊†◊ô◊ù ◊î◊†◊ï◊õ◊ó◊ô◊ô◊ù!')) {
                    return;
                }
                
                isSyncing = true;
                updateSyncStatus();
                
                await Promise.all([
                    data.tasks ? tasksRef.set(data.tasks) : Promise.resolve(),
                    data.shopping ? shoppingRef.set(data.shopping) : Promise.resolve(),
                    data.deletionHistory ? deletionHistoryRef.set(data.deletionHistory) : Promise.resolve()
                ]);
                
                alert('‚úÖ ◊î◊í◊ô◊ë◊ï◊ô ◊©◊ï◊ó◊ñ◊® ◊ë◊î◊¶◊ú◊ó◊î!');
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Restore error:', error);
                    alert('‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊©◊ó◊ñ◊ï◊® ◊í◊ô◊ë◊ï◊ô');
                }
            } finally {
                isSyncing = false;
                updateSyncStatus();
            }
        }
        
        async function openBackupDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        
        async function saveDirectoryHandle(handle) {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.put(handle, 'backupDirectory');
                
                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        db.close();
                        resolve(true);
                    };
                    transaction.onerror = () => {
                        db.close();
                        reject(transaction.error);
                    };
                });
            } catch (err) {
                console.error('Error saving directory handle:', err);
                return false;
            }
        }
        
        async function loadDirectoryHandle() {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('backupDirectory');
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('Error loading directory handle:', err);
                return null;
            }
        }
    </script>
</body>
</html>