<!DOCTYPE html>
<!--
    LOBALI - Elite Procrastination Management - ×ž×©×¤×—×ª ×—×’×™ ×•×œ×™××ª
    
    ×”×™×¡×˜×•×¨×™×™×ª ×’×¨×¡××•×ª:
    v9.7 (13/02/2026) - ðŸ‘¥ General Tasks: ×ž×©×™×ž×•×ª ×›×œ×œ×™×•×ª ×œ×›×•×œ×! ×›×¤×ª×•×¨ "×›×•×œ×" + ×¤×™×œ×˜×¨ + ×”×§×œ×˜×” ×§×•×œ×™×ª ×—×›×ž×”!
    v9.6 (13/02/2026) - ðŸŽ™ï¸ Voice Input: ×”×§×œ×˜×” ×§×•×œ×™×ª ×œ×ž×©×™×ž×•×ª ×•×§× ×™×•×ª + ×”×§×¨××” + ×–×™×”×•×™ ×©× ××•×˜×•×ž×˜×™!
    v9.5 (13/02/2026) - ðŸ”’ Firebase Auth: Anonymous Authentication + ××‘×˜×—×ª ×ž×¡×“ × ×ª×•× ×™×!
    v9.4 (10/02/2026) - ðŸ§¹ PWA Clean: × ×™×§×•×™ ×¨×¢×œ×™× - Service Worker ×—×¡×™×Ÿ ×©×’×™××•×ª, ×‘×“×™×§×ª response.type!
    v9.3 (10/02/2026) - ðŸ”§ PWA Fix: ×ª×™×§×•×Ÿ Service Worker - ×¡×™× ×•×Ÿ chrome-extension, mobile-web-app-capable!
    v9.2 (10/02/2026) - ðŸ“± PWA Support: ×”×¤×™×›×” ×œ××¤×œ×™×§×¦×™×” ×ž×ª×§× ×ª! manifest, service worker, ××™×™×§×•× ×™×!
    v9.1 (10/02/2026) - ðŸ‘¶ Ann Promotion: ××Ÿ ×¢×•×“×›× ×” ×œ"×¡×ž× ×›"×œ×™×ª ×ª×¤×¢×•×œ"! ×§×™×“×•× ×¨××•×™!
    v9.0 (10/02/2026) - ðŸ”’ Personal Fix: "×ž×©×™×ž×•×ª ×¢×¦×ž××™×•×ª" ×ž×¦×™×’ ×¨×§ ×ž×©×™×ž×•×ª ×©×œ×™! ×œ× ×©×œ ××—×¨×™×!
    v8.9 (10/02/2026) - ðŸ”¢ Count Fix: ×¡×¤×™×¨×ª ×”×ž×©×™×ž×•×ª ×‘×›×¨×˜×™×¡×™×•×ª ×ª×•×§× ×”! ×œ× ×¡×•×¤×¨×•×ª ×ž×©×™×ž×•×ª ×©×”×•×©×œ×ž×•!
    v8.8 (10/02/2026) - ðŸ”§ My Tasks Fix: ×ž×©×™×ž×•×ª ×©×”×•×©×œ×ž×• (×›×•×œ×œ recurring!) ×œ× ×ž×•×¤×™×¢×•×ª ×™×•×ª×¨ ×‘"×ž×©×™×ž×•×ª ×©×œ×™"!
    v8.7 (10/02/2026) - ðŸ”§ Bottom Fix: ×ª×™×§×•×Ÿ "×”×—×œ×§×” ×œ×ž×˜×”" - ×¢×›×©×™×• ×™×¨×™×“×” ×œ×¡×•×£ ×”×¨×©×™×ž×” ×¢×•×‘×“×ª ×ž×•×©×œ×!
    v8.6 (10/02/2026) - ðŸ—‘ï¸ Delete Shopping: ×”×•×¡×¤×ª ×›×¤×ª×•×¨ ×ž×—×™×§×” ×œ×§× ×™×•×ª! ×›×ž×• ×‘×ž×©×™×ž×•×ª - ×¨×§ ×œ-Admin!
    v8.5 (10/02/2026) - â±ï¸ Extra Safe: long-press ×”×•××¨×š ×œ-2 ×©× ×™×•×ª ×ž×œ××•×ª!
    v8.4 (10/02/2026) - â±ï¸ Timing Perfect: long-press 0.5 ×©× ×™×•×ª + ×’×¨×™×¨×” â†‘ ×œ×¨××© / â†“ ×œ×¡×•×£!
    v8.3 (10/02/2026) - ðŸŽ¯ Perfect Reordering: ×œ×—×™×¦×” + ×’×¨×™×¨×” ×× ×›×™×ª! ×’×œ×™×œ×” ×¨×’×™×œ×” ×¢×•×‘×“×ª ×ª×ž×™×“!
    v8.2 (10/02/2026) - ðŸŽ¯ Critical Fix: ×’×œ×™×œ×” vs ×”×—×œ×§×” ×ª×•×§×Ÿ! preventDefault ×¨×§ ×‘×”×—×œ×§×”!
    v8.1 (10/02/2026) - ðŸŽ¯ UX Perfect: ×›×¤×ª×•×¨ ×”×•×¡×£ ×ž×ª×—×ª ×œ×× ×©×™×, "×œ×—×¥ ×œ×‘×—×™×¨×”:", ×’×™×‘×•×™ × ×™×™×“ ×ž×©×•×¤×¨!
    v8.0 (09/02/2026) - ðŸ’œ LOBALI Rebranding: ×ž×¡×š ×”×ª×—×‘×¨×•×ª ×—×“×© ×¢× ×œ×•×’×• L, ×›×œ ×”××¤×œ×™×§×¦×™×” × ×©××¨×” ×–×”×”!
    v6.1 (09/02/2026) - ðŸŽ¨ UX Revolution: Input+×›×¤×ª×•×¨ ×‘×©×•×¨×” ××—×ª, Long-press (2 ×©× ×™×•×ª) ×œ×ž×¢×œ×”/×œ×ž×˜×”, ×ž×—×™×§×ª ðŸ’¬ðŸ“Œ, ×”×•×¡×¤×ª (×™×•×¦×¨)!
    v6.0 (09/02/2026) - ðŸŽ¯ Complete Fix: × ×™×”×•×œ ×ž×©×ª×ž×©×™× (modal z-index), ×ž×©×™×ž×•×ª ×¢×¦×ž××™×•×ª ×‘×¤×™×œ×˜×¨, ××™×™×§×•× ×™× ×§×˜× ×™×, responsive!
    v5.6 (09/02/2026) - ðŸ”§ Major Fixes: Swipe â†‘â†“ ×¢×•×‘×“, ×ª××¨×™×š ×”×©×œ×ž×”, ×‘×™×˜×•×œ ×¡×™×¡×ž×” ×œ×—×’×™, ×’×™×‘×•×™ ×‘×ž×•×‘×™×™×œ!
    v5.5 (09/02/2026) - ðŸ”§ Bug Fixes: ×ª×™×§×•×Ÿ × ×™×”×•×œ ×ž×©×ª×ž×©×™× + Google Calendar ××™×¨×•×¢ ×œ×©×¢×” ××—×ª ×‘×ž×§×•× ×›×œ ×”×™×•×!
    v5.4 (09/02/2026) - ðŸ·ï¸ Version Display: ×ž×¡×¤×¨ ×’×¨×¡×” ×ž×•×¦×’ ×‘×ž×¡×š ×”×ª×—×‘×¨×•×ª ×•×‘-Header!
    v5.3 (09/02/2026) - ðŸ‘¥ User Management: × ×™×”×•×œ ×ž×©×ª×ž×©×™× ×ž×œ× - ×”×•×¡×£, ×¢×¨×•×š, ×ž×—×§ ×ž×©×ª×ž×©×™×!
    v5.2 (09/02/2026) - âš¡ Quick Add Task: ×§××¨×“ ×”×•×¡×¤×ª ×ž×©×™×ž×” ×ž×”×™×¨×” ×—×–×¨ ×œ×ž×¡×š! ×‘×—×¨ ××“× ×•×”×•×¡×£ ×‘×§×œ×™×§
    v5.1 (09/02/2026) - ðŸ“… Google Calendar Integration: ×›×¤×ª×•×¨ "×”×•×¡×£ ×œ×™×•×ž×Ÿ" ×œ×ž×©×™×ž×•×ª ×¢× ×ª××¨×™×š!
    v5.0 (09/02/2026) - ðŸŒŸ Bottom Nav Revolution: 3 ×ž×¡×›×™× × ×¤×¨×“×™× (ðŸ“‹ðŸ›’ðŸ“Š), Swipe ×’× ×œ×ž×©×™×ž×•×ª, ×¡×˜×˜×™×¡×˜×™×§×” × ×¤×¨×“×ª
    v4.2 (09/02/2026) - ðŸ‘† Swipe Perfect: â† × ×§× ×”, â†’ ×‘×™×˜×•×œ (×‘×œ×™ ××™×©×•×¨!), â†‘ ×”×¢×œ××”, â†“ ×”×•×¨×“×”
    v4.1 (09/02/2026) - ðŸŽ¨ Professional Design: ×¢×™×¦×•×‘ × ×§×™, Swipe Actions (â†â†’â†‘), × ×™×”×•×œ ×ž×©×ª×ž×©×™×, ×¨×©×•×ž×” × ×§× ×ª×” ×¢× ×§×•
    v4.0 (09/02/2026) - ðŸš€ Mobile First Revolution: Header ×“×§ (50px), FAB ×¦×£, "×”×ž×©×™×ž×•×ª ×©×œ×™" ×‘×¨×™×¨×ª ×ž×—×“×œ, ×¢×™×¦×•×‘ ×ž×•×“×¨× ×™
    v3.4 (09/02/2026) - ×¢×™×¦×•×‘ ×¡×•×¤×¨ ×§×•×ž×¤×§×˜×™: ×©×•×¨×” ××—×ª ×“×§×” (×’× ×ž×©×™×ž×•×ª ×•×’× ×§× ×™×•×ª, ×›×•×œ×œ ×ž×•×‘×™×™×œ)
    v3.3 (09/02/2026) - ×¢×™×¦×•×‘ ×§×•×ž×¤×§×˜×™: ×©×•×¨×•×ª ×“×§×•×ª ×œ×¤×¨×™×˜×™ ×§× ×™×™×” (×©×•×¨×” ××—×ª ×¢× ×›×œ ×”×ž×™×“×¢)
    v3.2 (09/02/2026) - ×ª×™×§×•×Ÿ ×‘××’: ×”×¡×ª×¨×ª ×›×¤×ª×•×¨×™ ×ž×—×™×§×•×ª/×’×™×‘×•×™/×©×—×–×•×¨ ×ž×›×•×œ× ×—×•×¥ ×ž×—×’×™
    v3.1 (09/02/2026) - ×¡×™×¡×ž×” ×œ×—×’×™ (cochag12), ×’×™×‘×•×™ ××•×˜×•×ž×˜×™ ×¨×§ ×‘×ž×—×©×‘
    v3.0 (08/02/2026) - ×ª×™×§×•×Ÿ: ×ž× ×”×œ×™× ×¨×•××™× ×›×œ ×”×ž×©×™×ž×•×ª, ×ž×©×™×ž×•×ª ×ž×—×–×•×¨×™×•×ª (×™×•×ž×™/×©×‘×•×¢×™)
    v2.7 (08/02/2026) - ×›×¤×ª×•×¨×™ ×ž×—×™×§×•×ª/×’×™×‘×•×™/×©×—×–×•×¨ ×¨×§ ×œ×—×’×™ (×œ× ×œ×œ×™××ª)
    v2.6 (08/02/2026) - ×§×œ×™×§ ×¢×œ ×ž×©×ª×ž×© ×‘×¡×˜×˜×™×¡×˜×™×§×•×ª ×ž×¢×‘×¨ ×œ×ž×©×™×ž×•×ª ×©×œ×•, ×—×™×¤×•×© ×’× ×œ×¤×™ ×©×
    v2.5 (08/02/2026) - ×—×™×¤×•×© ×ž×©×™×ž×•×ª ×œ×¤×™ ×©× ××• ×ª×™××•×¨
    v2.4 (08/02/2026) - ×ª×™×§×•×Ÿ ×‘××’: ×ž×©×™×ž×•×ª ×¢×¦×ž××™×•×ª ×œ× × ×¨××•×ª ×œ×ž×™ ×©×œ× ××ž×•×¨
    v2.3 (08/02/2026) - ×¡×˜×˜×™×¡×˜×™×§×•×ª ×ž×¤×•×¨×˜×•×ª ×¨×§ ×œ×ž× ×”×œ×™×, ×œ×©×•× ×™×•×ª ×ž×©×™×ž×•×ª/×§× ×™×•×ª
    v2.2 (08/02/2026) - ×ž×¡×¤×•×¨ ×‘×˜××‘×™×, ×”×¡×¨×ª ×¤×™×œ×˜×¨ '×”×›×œ', ×‘×¨×™×¨×ª ×ž×—×“×œ ×œ×ž×ž×ª×™× ×•×ª
    v2.1 (08/02/2026) - ×¨×©×™×ž×” ×ž×¡×•×“×¨×ª ×¢× ×ž×¡×¤×•×¨, ×—×™×¤×•×© ×ž×•×¦×¨×™×, ×›×•×›×‘×™ ×©×‘×•×¢ ×¨×§ ×œ×—×’×™
    v2.0 (08/02/2026) - Firebase Realtime Database - ×¡× ×›×¨×•×Ÿ ×‘×–×ž×Ÿ ××ž×ª
    v1.6 (×§×•×“×)      - ×’×¨×¡×” ×ž×§×•×¨×™×ª ×¢× localStorage
-->
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOBALI v9.7 - Elite Procrastination Management ðŸ’œ</title>
    
    <!-- Version Info -->
    <meta name="version" content="9.7">
    <meta name="last-updated" content="2026-02-13">
    <meta name="sync" content="firebase-realtime">
    <meta name="changelog" content="General Tasks: ×ž×©×™×ž×•×ª ×›×œ×œ×™×•×ª ×œ×›×•×œ× + ×”×§×œ×˜×” ×—×›×ž×”! ðŸ‘¥">
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="LOBALI">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700;800&family=Varela+Round&family=Alef:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-liat: #E91E63;
            --color-hagai: #2196F3;
            --color-maya: #00BCD4;
            --color-ariel: #4CAF50;
            --color-ann: #FF9800;
            
            --bg-main: #F5F5F5;
            --bg-card: #FFFFFF;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border-color: #E0E0E0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 2px 6px rgba(0,0,0,0.15);
            --shadow-lg: 0 4px 12px rgba(0,0,0,0.18);
            
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rubik', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 0;
            position: relative;
            overflow-x: hidden;
        }
            z-index: 0;
            animation: float 20s ease-in-out infinite;
        }
        
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            to {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-bottom: 100px;
            position: relative;
            z-index: 1;
        }
        
        /* Header */
        header {
            background: white;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .header-compact {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .user-info-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .user-avatar-small {
            font-size: 1.5rem;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .user-details-compact {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        
        .user-name-small {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .user-role-small {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        /* Version Badges */
        .version-badge-header {
            display: inline-block;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            padding: 2px 8px;
            border-radius: 10px;
            margin-top: 2px;
        }
        
        .version-badge-login {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, #6366F1, #8B5CF6);
            padding: 8px 16px;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            z-index: 10;
        }
        
        .header-actions-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sync-compact {
            display: flex;
            align-items: center;
            padding: 4px;
        }
        
        .btn-icon-only {
            padding: 6px 10px;
            border: none;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
        }
        
        .btn-icon-only:hover {
            background: rgba(0,0,0,0.1);
            transform: scale(1.05);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .header-user {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .user-avatar {
            font-size: 3rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .user-info h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .user-info p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #syncStatus {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(0,0,0,0.03);
            border-radius: var(--radius-sm);
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95rem;
            font-family: 'Rubik', sans-serif;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #E91E63, #FF6B9D);
            color: white;
            box-shadow: 0 4px 12px rgba(233, 30, 99, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.4);
        }
        
        .btn-secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: rgba(0,0,0,0.08);
        }
        
        .btn-logout {
            background: transparent;
            color: var(--text-secondary);
            border: 2px solid currentColor;
        }
        
        .btn-logout:hover {
            background: var(--text-secondary);
            color: white;
        }
        
        /* FAB - Floating Action Button */
        .fab {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            background: #1976D2;
        }
        
        .fab:active {
            transform: scale(0.95);
        }
        
        /* Tabs */
        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            border: none;
            background: none;
            color: var(--text-secondary);
        }
        
        .nav-item:active {
            transform: scale(0.95);
        }
        
        .nav-item.active {
            color: #2196F3;
        }
        
        .nav-icon {
            font-size: 1.5rem;
            transition: transform 0.2s;
        }
        
        .nav-item.active .nav-icon {
            transform: scale(1.1);
        }
        
        .nav-label {
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .nav-badge {
            position: absolute;
            top: 4px;
            right: 20%;
            background: #E91E63;
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }
        
        /* Main Layout */
        .main-layout {
            padding-bottom: 80px;
        }
        
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 30px;
            box-shadow: var(--shadow-md);
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Filters */
        .filters {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 6px 10px;
            background: rgba(0,0,0,0.04);
            border: 2px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.75rem;
            font-family: 'Rubik', sans-serif;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }
        
        .filter-btn:hover {
            background: rgba(0,0,0,0.06);
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, #00BCD4, #00E5FF);
            color: white;
            border-color: #00BCD4;
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.3);
        }
        
        .filter-count {
            background: rgba(255,255,255,0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
        }
        
        .filter-btn.active .filter-count {
            background: rgba(255,255,255,0.95);
            color: #00BCD4;
        }
        
        /* Task/Shopping Item */
        .item {
            background: white;
            border-radius: var(--radius-sm);
            padding: 12px 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            touch-action: pan-y;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .item:active {
            box-shadow: var(--shadow-md);
        }
        
        .item.swiping {
            transition: none;
        }
        
        .item.swipe-left {
            background: #E8F5E9;
        }
        
        .item.swipe-right {
            background: #FFF3E0;
        }
        
        .item.swipe-up {
            background: #E3F2FD;
        }
        
        .item.swipe-down {
            background: #FFF9C4;
        }
        
        .item.pinned {
            border-left: 4px solid #E91E63;
            background: #FFF0F5;
        }
        
        .item.completed {
            opacity: 0.6;
            background: #F5F5F5;
        }
        
        .item.completed .item-content {
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        
        /* Personal Tasks - Different color */
        .item.personal-task {
            background: linear-gradient(to right, #FFF9E6 0%, #FFFEF8 100%);
            border-left: 3px solid #FF9800;
        }
        
        .item.purchased {
            opacity: 0.5;
            background: #FAFAFA;
        }
        
        .item.purchased .item-content {
            text-decoration: line-through;
            color: #9E9E9E;
        }
        
        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        .swipe-indicator.left {
            right: 20px;
        }
        
        .swipe-indicator.right {
            left: 20px;
        }
        
        .swipe-indicator.up {
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .swipe-indicator.down {
            left: 50%;
            top: auto;
            bottom: 50%;
            transform: translate(-50%, 50%);
        }
        
        .swipe-indicator.visible {
            opacity: 1;
        }
        
        .item-number {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-secondary);
            min-width: 25px;
            text-align: center;
        }
        
        .item-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.4;
        }
        
        .item-header {
            flex: 1;
            min-width: 0;
        }
        
        .item-title {
            font-size: 1.05rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .item-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }
        
        .badge-priority-high {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .badge-priority-medium {
            background: #FFF3E0;
            color: #E65100;
        }
        
        .badge-priority-low {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .badge-pinned {
            background: linear-gradient(135deg, #E91E63, #9C27B0);
            color: white;
        }
        
        .badge-personal {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .item-description {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .item-meta {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--text-secondary);
        }
        
        .user-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .item-actions {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }
        
        .btn-icon {
            padding: 5px 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.7rem;
            font-family: 'Rubik', sans-serif;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            position: relative;
            white-space: nowrap;
        }
        
        .btn-icon:hover {
            transform: translateY(-2px);
        }
        
        .btn-complete {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .btn-delete {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .btn-pin {
            background: #FCE4EC;
            color: #C2185B;
        }
        
        .btn-notes {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .btn-calendar {
            background: #FFF9C4;
            color: #F57C00;
        }
        
        .btn-calendar:hover {
            background: #FFF59D;
            box-shadow: 0 2px 8px rgba(245, 124, 0, 0.3);
        }
        
        .btn-read {
            background: #F3E5F5;
            color: #7B1FA2;
        }
        
        .btn-read.reading {
            animation: reading-pulse 1s infinite;
        }
        
        @keyframes reading-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .note-badge {
            position: absolute;
            top: -6px;
            left: -6px;
            background: #C62828;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 700;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #E91E63;
            box-shadow: 0 0 0 3px rgba(233, 30, 99, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        
        .form-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Assignee Selection */
        .assignee-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(42px, 1fr));
            gap: 4px;
            margin-top: 6px;
        }
        
        .assignee-btn {
            padding: 3px;
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-family: 'Rubik', sans-serif;
        }
        
        .assignee-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }
        
        .assignee-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .assignee-icon {
            font-size: 1rem;
            margin-bottom: 1px;
        }
        
        .assignee-name {
            font-weight: 600;
            font-size: 0.6rem;
        }
        
        /* Priority Selection */
        .priority-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }
        
        .priority-btn {
            padding: 15px;
            border: 3px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .priority-btn:hover {
            transform: translateY(-3px);
        }
        
        .priority-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 35px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: modalSlide 0.3s ease;
        }
        
        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .modal-title {
            font-size: 1.6rem;
            font-weight: 700;
        }
        
        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.05);
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: rgba(0,0,0,0.1);
            transform: rotate(90deg);
        }
        
        /* Statistics */
        .stat-card {
            background: linear-gradient(135deg, #FFF 0%, #F8F8F8 100%);
            border-radius: var(--radius-md);
            padding: 25px;
            margin-bottom: 20px;
            border-right: 5px solid;
        }
        
        .stat-card.tasks {
            border-right-color: #E91E63;
        }
        
        .stat-card.shopping {
            border-right-color: #FF9800;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-name {
            font-weight: 600;
        }
        
        .stat-count {
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        /* Statistics Tabs */
        .stat-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
        }
        
        .stat-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-secondary);
            transition: all 0.3s;
            font-family: 'Rubik', sans-serif;
        }
        
        .stat-tab:hover {
            color: var(--text-primary);
        }
        
        .stat-tab.active {
            color: #E91E63;
            border-bottom-color: #E91E63;
        }
        
        .stat-content {
            display: none;
        }
        
        .stat-content.active {
            display: block;
        }
        
        .member-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #F9FAFB;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .member-stat:hover {
            background: #E5E7EB;
            transform: translateX(-3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .member-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .member-icon {
            font-size: 1.5rem;
        }
        
        .member-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .member-count {
            font-size: 1.3rem;
            font-weight: 700;
            padding: 5px 12px;
            background: white;
            border-radius: 10px;
        }
        
        .member-count.zero {
            opacity: 0.5;
            color: var(--text-secondary);
        }
        
        .shopping-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .shopping-stat-box {
            background: #F9FAFB;
            padding: 20px;
            border-radius: var(--radius-sm);
            text-align: center;
        }
        
        .shopping-stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .shopping-stat-number.pending {
            color: #2196F3;
        }
        
        .shopping-stat-number.purchased {
            color: #4CAF50;
        }
        
        .shopping-stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        /* Top Performers */
        .performer-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #FFF 0%, #FAFAFA 100%);
            border-radius: var(--radius-sm);
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        
        .performer-item:hover {
            transform: translateX(-5px);
            box-shadow: var(--shadow-sm);
        }
        
        .performer-rank {
            font-size: 1.8rem;
            width: 50px;
            text-align: center;
        }
        
        .performer-info {
            flex: 1;
        }
        
        .performer-name {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }
        
        .performer-points {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        /* Notes */
        .notes-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .note-item {
            background: #F8F8F8;
            padding: 18px;
            border-radius: var(--radius-sm);
            margin-bottom: 15px;
            border-right: 4px solid #E0E0E0;
        }
        
        .note-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .note-author {
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .note-text {
            line-height: 1.6;
        }
        
        /* Deletion History */
        .history-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .history-table th,
        .history-table td {
            padding: 15px;
            text-align: right;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .history-table th {
            background: rgba(0,0,0,0.03);
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .history-table tr:hover {
            background: rgba(0,0,0,0.02);
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .empty-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-text {
            font-size: 1.1rem;
        }
        
        /* Quick Add */
        .quick-add {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
        }
        
        .quick-add input {
            flex: 1;
        }
        
        /* Search Box */
        .search-box {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 3px rgba(0, 188, 212, 0.1);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }
        
        /* Hidden */
        .hidden {
            display: none !important;
        }
        
        /* Login Screen */
        /* Login Screen - LOBALI Design */
        .login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #0A0A0B;
            background: radial-gradient(circle at center, #1E1E2D 0%, #0A0A0B 100%);
            padding: 40px 20px;
        }
        
        .brand-header {
            text-align: center;
            margin-bottom: 60px;
        }
        
        .logo-svg {
            width: 100px;
            height: 100px;
            margin: 0 auto 30px;
            display: block;
        }
        
        .login-title {
            font-size: 4rem;
            font-weight: 900;
            letter-spacing: -0.05em;
            background: linear-gradient(to bottom, #fff 0%, #64748B 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
        }
        
        .login-subtitle {
            font-size: 1rem;
            color: #6366F1;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            font-weight: 600;
        }
        
        .login-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 24px;
            max-width: 1100px;
            width: 100%;
        }
        
        .login-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
            min-height: 130px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .login-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }
        
        .login-card:hover::before {
            transform: translateX(100%);
        }
        
        .login-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #6366F1;
            transform: scale(1.05);
        }
        
        .login-icon {
            font-size: 1.8rem;
            margin-bottom: 8px;
            display: block;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }
        
        .login-name {
            font-size: 1rem;
            font-weight: 700;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .login-role {
            font-size: 0.65rem;
            color: #94A3B8;
            text-align: center;
            line-height: 1.3;
        }
        
        .login-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .login-badge.pending {
            background: rgba(239, 68, 68, 0.2);
            color: #EF4444;
        }
        
        .login-badge.complete {
            background: rgba(16, 185, 129, 0.2);
            color: #10B981;
        }
        
        .user-management {
            margin-top: 50px;
            text-align: center;
        }
        
        .btn-manage {
            padding: 14px 32px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #94A3B8;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Rubik', sans-serif;
        }
        
        .btn-manage:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #6366F1;
            color: #6366F1;
            transform: translateY(-2px);
        }
        
        /* User List in Modal */
        .user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--bg-light);
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }
        
        .user-item-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .user-item-icon {
            font-size: 1.8rem;
        }
        
        .user-item-details {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .user-item-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .user-item-role {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .user-item-actions {
            display: flex;
            gap: 8px;
        }
        
        .user-item .btn-icon {
            padding: 6px 10px;
            font-size: 0.75rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-right {
                width: 100%;
                justify-content: space-between;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .item {
                flex-wrap: nowrap;
                padding: 6px 10px;
                font-size: 0.8rem;
            }
            
            .item-content {
                font-size: 0.8rem;
                line-height: 1.3;
            }
            
            .item-actions {
                flex-wrap: nowrap;
                gap: 4px;
            }
            
            .filter-btn {
                padding: 5px 8px;
                font-size: 0.7rem;
                gap: 4px;
            }
            
            .filter-count {
                padding: 1px 4px;
                font-size: 0.65rem;
            }
            
            .assignee-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
                gap: 3px;
            }
            
            .assignee-btn {
                padding: 2px;
            }
            
            .assignee-icon {
                font-size: 0.95rem;
            }
            
            .assignee-name {
                font-size: 0.6rem;
            }
            
            .filters {
                gap: 6px;
                margin-bottom: 15px;
            }
            
            .btn-icon {
                font-size: 0.65rem;
                padding: 4px 6px;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.03);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0,0,0,0.3);
        }
        /* Floating Mic Button */
        .fab-mic {
            position: fixed;
            bottom: calc(80px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(129, 140, 248, 0.4);
            background: linear-gradient(135deg, #6366F1, #818CF8);
            color: white;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.4);
            transition: all 0.2s;
        }
        
        .fab-mic:active {
            transform: translateX(-50%) scale(0.93);
        }
        
        .fab-mic.recording {
            border-color: rgba(248, 113, 113, 0.6);
            background: linear-gradient(135deg, #EF4444, #F87171);
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
            animation: mic-fab-pulse 1s infinite;
        }
        
        @keyframes mic-fab-pulse {
            0%, 100% { box-shadow: 0 4px 16px rgba(239,68,68,0.4); }
            50% { box-shadow: 0 4px 24px rgba(239,68,68,0.6), 0 0 0 8px rgba(239,68,68,0.1); }
        }
        
        /* Voice Confirmation Modal */
        .voice-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .voice-modal-overlay.active {
            display: flex;
        }
        
        .voice-modal {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            text-align: center;
            animation: fadeUp 0.3s ease;
        }
        
        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(16px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .voice-modal-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
        }
        
        .voice-modal-status {
            font-size: 0.9rem;
            color: #6B7280;
            margin-bottom: 16px;
            font-weight: 500;
        }
        
        .voice-modal-status.recording {
            color: #EF4444;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .voice-modal-text {
            background: #F3F4F6;
            border-radius: 12px;
            padding: 16px;
            font-size: 1.1rem;
            line-height: 1.8;
            color: #1F2937;
            min-height: 50px;
            margin-bottom: 16px;
            direction: rtl;
            font-family: 'Rubik', sans-serif;
        }
        
        .voice-modal-text:empty::after {
            content: '...×ž×§×©×™×‘';
            color: #9CA3AF;
        }
        
        .voice-modal-actions {
            display: flex;
            gap: 10px;
        }
        
        .voice-modal-actions .btn {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            font-family: 'Rubik', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }
        
        .btn-voice-confirm {
            background: #10B981;
            color: white;
        }
        
        .btn-voice-retry {
            background: #F59E0B;
            color: white;
        }
        
        .btn-voice-cancel {
            background: #EF4444;
            color: white;
        }
        
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="version-badge-login">v9.7</div>
        
        <div class="brand-header">
            <svg class="logo-svg" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="30" fill="#161618"/>
                <path d="M35 30V70H65M65 55L55 65" stroke="#6366F1" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            
            <h1 class="login-title">LOBALI</h1>
            <p class="login-subtitle">ELITE PROCRASTINATION MANAGEMENT</p>
        </div>
        
        <div class="login-grid" id="loginGrid"></div>
        
        <!-- User Management -->
        <div class="user-management">
            <button class="btn-manage" onclick="openUserManagementModal()">
                ðŸ‘¥ × ×™×”×•×œ ×ž×©×ª×ž×©×™×
            </button>
        </div>
    </div>

    <!-- User Management Modal -->
    <div id="userManagementModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ðŸ‘¥ × ×™×”×•×œ ×ž×©×ª×ž×©×™×</h3>
                <button class="modal-close" onclick="closeUserManagementModal()">âœ•</button>
            </div>
            
            <div class="modal-body">
                <!-- Current Users -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ ×ž×©×ª×ž×©×™× ×§×™×™×ž×™×:</h4>
                <div id="currentUsersList" style="margin-bottom: 25px;"></div>
                
                <!-- Add New User -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">âž• ×”×•×¡×£ ×ž×©×ª×ž×© ×—×“×©:</h4>
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <input type="text" id="newUserName" class="form-input" placeholder="×©× ×”×ž×©×ª×ž×©...">
                    <input type="text" id="newUserIcon" class="form-input" placeholder="××™×ž×•×’'×™ (×œ×“×•×’×ž×”: ðŸ‘¶)" maxlength="2">
                    <select id="newUserRole" class="form-input">
                        <option value="child">×™×œ×“/×”</option>
                        <option value="admin">×ž× ×”×œ/×ª</option>
                    </select>
                    <button class="btn btn-primary" onclick="addNewUser()">âž• ×”×•×¡×£ ×ž×©×ª×ž×©</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container hidden">
        <!-- Header -->
        <header>
            <div class="header-compact">
                <div class="user-info-compact">
                    <span class="user-avatar-small" id="userAvatar">ðŸ‘¨</span>
                    <div class="user-details-compact">
                        <span class="user-name-small" id="userName">×ž×©×ª×ž×©</span>
                        <span class="user-role-small" id="userRole">×ª×¤×§×™×“</span>
                        <span class="version-badge-header">v9.7</span>
                    </div>
                </div>
                
                <div class="header-actions-compact">
                    <div id="syncStatus" class="sync-compact">
                        <span class="sync-dot" style="background: #FFA500;"></span>
                    </div>
                    
                    <button class="btn-icon-only hidden" id="btnDeletionHistory" onclick="openDeletionHistoryModal()" title="×ž×—×™×§×•×ª">
                        ðŸ—‘ï¸
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnBackup" onclick="performManualBackup()" title="×’×™×‘×•×™">
                        ðŸ’¾
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnRestore" onclick="performRestore()" title="×©×—×–×•×¨">
                        ðŸ“¥
                    </button>
                    
                    <button class="btn-icon-only btn-logout" onclick="logout()" title="×™×¦×™××”">
                        ðŸšª
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Main Content -->
            <div class="main-content">
                <!-- Tasks Tab -->
                <div id="tasksTab" class="tab-content hidden">
                    <!-- Quick Add Task Card -->
                    <div class="card" style="padding: 12px;">
                        <input type="text" class="form-input" id="quickTaskInput" placeholder="×©× ×”×ž×©×™×ž×”..." style="width: 100%; margin-bottom: 12px;" onkeypress="if(event.key === 'Enter') addQuickTask()">
                        
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500;">
                            ×œ×—×¥ ×œ×‘×—×™×¨×”:
                        </div>
                        
                        <div class="assignee-grid" id="quickAssigneeGrid" style="margin-bottom: 12px;"></div>
                        
                        <button class="btn btn-primary" onclick="addQuickTask()" style="width: 100%;">
                            âž• ×”×•×¡×£
                        </button>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="tasksSearchInput" placeholder="ðŸ” ×—×™×¤×•×© ×ž×©×™×ž×”..." oninput="filterTasksBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterTasks('pending', event)">
                            ×ž×ž×ª×™× ×•×ª
                            <span class="filter-count" id="pendingTasksCount">0</span>
                        </button>
                        <button class="filter-btn" onclick="filterTasks('completed', event)">
                            ×”×•×©×œ×ž×•
                        </button>
                        <button class="filter-btn" onclick="filterTasks('personal', event)">
                            ×ž×©×™×ž×•×ª ×¢×¦×ž××™×•×ª
                            <span class="filter-count" id="personalTasksCount">0</span>
                        </button>
                        <button class="filter-btn" id="myTasksFilter" onclick="filterTasks('my-tasks', event)">
                            ×”×ž×©×™×ž×•×ª ×©×œ×™
                            <span class="filter-count" id="myTasksCount">0</span>
                        </button>
                        <button class="filter-btn" onclick="filterTasks('general', event)">
                            ×›×œ×œ×™×•×ª
                            <span class="filter-count" id="generalTasksCount">0</span>
                        </button>
                    </div>

                    <!-- Tasks List -->
                    <div id="tasksList"></div>
                </div>

                <!-- Shopping Tab -->
                <div id="shoppingTab" class="tab-content">
                    <div class="card">
                        <h3 class="card-title">âž• ×”×•×¡×¤×ª ×¤×¨×™×˜</h3>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" class="form-input" id="quickItemInput" placeholder="×©× ×”×¤×¨×™×˜..." style="flex: 0 0 60%; margin: 0;" onkeypress="if(event.key === 'Enter') { event.preventDefault(); quickAddItem(event); }">
                            <button type="button" class="btn btn-primary" onclick="quickAddItem(event)" style="flex: 0 0 calc(40% - 10px); white-space: nowrap;">âž• ×”×•×¡×£</button>
                        </div>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="shoppingSearchInput" placeholder="ðŸ” ×—×™×¤×•×© ×ž×•×¦×¨..." oninput="filterShoppingBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterShopping('pending', event)">
                            ×¦×¨×™×š ×œ×§× ×•×ª
                        </button>
                        <button class="filter-btn" onclick="filterShopping('purchased', event)">
                            × ×§× ×•
                        </button>
                    </div>

                    <!-- Shopping List -->
                    <div id="shoppingList"></div>
                </div>
                
                <!-- Stats Screen -->
                <div id="statsScreen" class="tab-content hidden">
                    <div class="card">
                        <h3 class="card-title">ðŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª</h3>
                        <div id="statsContainer"></div>
                    </div>

                    <div class="card" id="topPerformersCard">
                        <h3 class="card-title">ðŸ† ×›×•×›×‘×™ ×”×©×‘×•×¢</h3>
                        <div id="topPerformers"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Voice Input Modal -->
        <div class="voice-modal-overlay" id="voiceModal">
            <div class="voice-modal">
                <div class="voice-modal-icon" id="voiceModalIcon">ðŸŽ™ï¸</div>
                <div class="voice-modal-status" id="voiceModalStatus">×ž×§×©×™×‘...</div>
                <div class="voice-modal-text" id="voiceModalText"></div>
                <div class="voice-modal-actions" id="voiceModalActions" style="display:none;">
                    <button class="btn btn-voice-confirm" onclick="confirmVoiceInput()">âœ… ××©×¨</button>
                    <button class="btn btn-voice-retry" onclick="retryVoiceInput()">ðŸ”„ ×”×§×œ×˜ ×©×•×‘</button>
                    <button class="btn btn-voice-cancel" onclick="cancelVoiceInput()">âŒ ×‘×˜×œ</button>
                </div>
            </div>
        </div>
        
        <!-- FAB - Floating Action Button -->
        <button class="fab" onclick="openFABModal()" title="×”×•×¡×£ ×¤×¨×™×˜ ×—×“×©">
            âž•
        </button>
        
        <!-- Floating Mic Button -->
        <button class="fab-mic" id="fabMicBtn" onclick="startVoiceInputSmart()" title="×”×§×œ×˜×” ×§×•×œ×™×ª">
            ðŸŽ™ï¸
        </button>
        
        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <button class="nav-item active" onclick="switchScreen('shopping')" id="navShopping">
                <span class="nav-badge" id="navShoppingBadge">0</span>
                <div class="nav-icon">ðŸ›’</div>
                <div class="nav-label">×§× ×™×•×ª</div>
            </button>
            <button class="nav-item" onclick="switchScreen('tasks')" id="navTasks">
                <span class="nav-badge" id="navTasksBadge">0</span>
                <div class="nav-icon">ðŸ“‹</div>
                <div class="nav-label">×ž×©×™×ž×•×ª</div>
            </button>
            <button class="nav-item" onclick="switchScreen('stats')" id="navStats">
                <div class="nav-icon">ðŸ“Š</div>
                <div class="nav-label">×¡×˜×˜×™×¡×˜×™×§×”</div>
            </button>
        </div>
    </div>

    <!-- Add Task Modal -->
    <div id="addTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">âž• ×ž×©×™×ž×” ×—×“×©×”</h3>
                <button class="modal-close" onclick="closeAddTaskModal()">âœ•</button>
            </div>
            
            <form id="addTaskForm" onsubmit="submitTask(event)">
                <div class="form-group">
                    <label class="form-label">×©× ×”×ž×©×™×ž×” *</label>
                    <input type="text" class="form-input" id="taskTitle" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×ª×™××•×¨</label>
                    <textarea class="form-textarea" id="taskDescription"></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×”×§×¦××” ×œ×ž×©×ª×ž×© *</label>
                    <div class="assignee-grid" id="assigneeGrid"></div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×ª××¨×™×š ×™×¢×“</label>
                    <input type="date" class="form-input" id="taskDueDate">
                </div>
                
                <div class="form-group">
                    <label class="form-label">×¢×“×™×¤×•×ª</label>
                    <div class="priority-grid">
                        <button type="button" class="priority-btn" style="background: #FFEBEE; color: #C62828;" onclick="selectPriority('high', event)">
                            ðŸ”´ ×’×‘×•×”×”
                        </button>
                        <button type="button" class="priority-btn selected" style="background: #FFF3E0; color: #E65100;" onclick="selectPriority('medium', event)">
                            ðŸŸ¡ ×¨×’×™×œ×”
                        </button>
                        <button type="button" class="priority-btn" style="background: #E8F5E9; color: #2E7D32;" onclick="selectPriority('low', event)">
                            ðŸŸ¢ × ×ž×•×›×”
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsPersonal">
                        <span>ðŸ”’ ×ž×©×™×ž×” ×¢×¦×ž××™×ª (×¨×§ ×”×ž×©×ª×ž×© ×©×”×•×§×¦×ª×” ×œ×• ×™×¨××” ××•×ª×”)</span>
                    </label>
                </div>
                
                <div class="form-group" id="recurringGroup" style="display: none;">
                    <label class="form-label">ðŸ”„ ×ž×©×™×ž×” ×ž×—×–×•×¨×™×ª</label>
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsRecurring" onchange="toggleRecurringOptions()">
                        <span>×ž×©×™×ž×” ×—×•×–×¨×ª (×ž×ª××¤×¡×ª ××•×˜×•×ž×˜×™×ª ×œ××—×¨ ×”×©×œ×ž×”)</span>
                    </label>
                    <div id="recurringOptions" style="display: none; margin-top: 15px;">
                        <select class="form-select" id="recurringType">
                            <option value="daily">×™×•×ž×™×ª</option>
                            <option value="weekly">×©×‘×•×¢×™×ª</option>
                        </select>
                    </div>
                </div>
                
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    âž• ×”×•×¡×£ ×ž×©×™×ž×”
                </button>
            </form>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ðŸ’¬ ×”×¢×¨×•×ª ×œ×ž×©×™×ž×”</h3>
                <button class="modal-close" onclick="closeNotesModal()">âœ•</button>
            </div>
            
            <div class="notes-list" id="notesList"></div>
            
            <div id="addNoteSection">
                <div class="form-group">
                    <label class="form-label">×”×•×¡×£ ×”×¢×¨×”</label>
                    <textarea class="form-textarea" id="newNoteText" placeholder="×›×ª×•×‘ ×”×¢×¨×”..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="addNote()">ðŸ’¬ ×”×•×¡×£ ×”×¢×¨×”</button>
            </div>
        </div>
    </div>

    <!-- Deletion History Modal -->
    <div id="deletionHistoryModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3 class="modal-title">ðŸ—‘ï¸ ×”×™×¡×˜×•×¨×™×™×ª ×ž×—×™×§×•×ª</h3>
                <button class="modal-close" onclick="closeDeletionHistoryModal()">âœ•</button>
            </div>
            
            <table class="history-table">
                <thead>
                    <tr>
                        <th>×¡×•×’</th>
                        <th>×©×</th>
                        <th>× ×ž×—×§ ×¢×œ ×™×“×™</th>
                        <th>×ª××¨×™×š</th>
                        <th>×¤×¢×•×œ×•×ª</th>
                    </tr>
                </thead>
                <tbody id="deletionHistoryBody"></tbody>
            </table>
            
            <div style="margin-top: 25px; text-align: left;">
                <button class="btn btn-delete" onclick="clearDeletionHistory()">
                    ðŸ—‘ï¸ × ×§×” ×”×›×œ
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== FIREBASE CONFIGURATION ====================
        
        const firebaseConfig = {
            apiKey: "AIzaSyAkOH2RMig-uUYqPGfpB_ECVGQ6sSty-RQ",
            authDomain: "family-tasks-b3460.firebaseapp.com",
            databaseURL: "https://family-tasks-b3460-default-rtdb.firebaseio.com",
            projectId: "family-tasks-b3460",
            storageBucket: "family-tasks-b3460.firebasestorage.app",
            messagingSenderId: "679268328049",
            appId: "1:679268328049:web:e8b0a3e8f5c8d9e0a8b0a3"
        };
        
        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        // Anonymous Authentication - ××‘×˜×—×ª ×ž×¡×“ ×”× ×ª×•× ×™×
        firebase.auth().signInAnonymously().catch((error) => {
            console.error('âŒ ×©×’×™××ª ××™×ž×•×ª:', error);
        });
        
        const db = firebase.database();
        
        // Firebase references
        const tasksRef = db.ref('tasks');
        const shoppingRef = db.ref('shopping');
        const deletionHistoryRef = db.ref('deletionHistory');
        
        // ==================== PWA - SERVICE WORKER ====================
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('ðŸ’œ LOBALI Service Worker × ×¨×©× ×‘×”×¦×œ×—×”!', registration.scope);
                        
                        // ×‘×“×™×§×ª ×¢×“×›×•× ×™×
                        registration.addEventListener('updatefound', () => {
                            console.log('ðŸ”„ × ×ž×¦× ×¢×“×›×•×Ÿ ×œ-Service Worker...');
                        });
                    })
                    .catch((error) => {
                        console.log('âŒ ×¨×™×©×•× Service Worker × ×›×©×œ:', error);
                    });
            });
            
            // ×ž×¢×§×‘ ××—×¨ ×©×™× ×•×™×™ ×ž×¦×‘ ×©×œ Service Worker
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('â™»ï¸ Service Worker ×¢×•×“×›×Ÿ - ××¤×©×¨ ×œ×˜×¢×•×Ÿ ×ž×—×“×©');
            });
        }
        
        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('ðŸ“± LOBALI ×ž×•×›× ×” ×œ×”×ª×§× ×”!');
            
            // ××¤×©×¨ ×œ×”×•×¡×™×£ ×›×¤×ª×•×¨ "×”×ª×§×Ÿ ××¤×œ×™×§×¦×™×”" ×‘×¢×ª×™×“
            // const installButton = document.getElementById('installButton');
            // if (installButton) {
            //     installButton.style.display = 'block';
            // }
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('ðŸ’œ LOBALI ×”×•×ª×§× ×” ×‘×”×¦×œ×—×” ×¢×œ ×”×ž×›×©×™×¨!');
            deferredPrompt = null;
        });
        
        // ==================== GLOBAL VARIABLES ====================
        
        // Family members
        // Family Members - Load from localStorage or use defaults
        // LOBALI Family Members - Always use latest
        const defaultFamilyMembers = {
            liat: { 
                id: 'liat', 
                name: '×œ×™××ª', 
                icon: 'ðŸ‘©â€ðŸ’¼', 
                color: '#E91E63', 
                role: '×ž× ×”×œ×ª', 
                roleDescription: '×”×ž× ×›"×œ×™×ª',
                isAdmin: true 
            },
            hagai: { 
                id: 'hagai', 
                name: '×—×’×™', 
                icon: 'ðŸ‘¨', 
                color: '#2196F3', 
                role: '×ž× ×”×œ', 
                roleDescription: '×”×ª×ž×™×›×” ×”×˜×›× ×™×ª',
                isAdmin: true, 
                canBackup: true 
            },
            maya: { 
                id: 'maya', 
                name: '×ž×™×”', 
                icon: 'âœï¸', 
                color: '#00BCD4', 
                role: '×ž×©×ª×ž×©×ª',
                roleDescription: '×™×•×¢×¦×ª ××¡×˜×¨×˜×’×™×ª ×œ×ž× ×•×—×”'
            },
            ariel: { 
                id: 'ariel', 
                name: '××¨×™××œ', 
                icon: 'ðŸŽ®', 
                color: '#4CAF50', 
                role: '×ž×©×ª×ž×©',
                roleDescription: '×¨××© ××’×£ ×¤× ××™ ×•×ž×©×—×§×™×'
            },
            ann: { 
                id: 'ann', 
                name: '××Ÿ', 
                icon: 'ðŸ‘¶', 
                color: '#FF9800', 
                role: '×ž×©×ª×ž×©×ª',
                roleDescription: '×¡×ž× ×›"×œ×™×ª ×ª×¤×¢×•×œ',
                canSpeak: true 
            }
        };
        
        // Always use latest definition (override localStorage for consistency)
        let familyMembers = defaultFamilyMembers;
        localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
        
        // Current state
        let currentUser = null;
        let selectedAssignee = null;
        let selectedPriority = 'medium';
        let currentFilter = 'pending';
        let currentShoppingFilter = 'pending';
        let currentTaskForNotes = null;
        let shoppingSearchQuery = '';
        let tasksSearchQuery = '';
        
        // Data (will be populated from Firebase)
        let tasks = {};
        let shopping = {};
        let deletionHistory = [];
        
        // Sync status
        let isOnline = false;
        let isSyncing = false;
        
        // Backup system (for Hagai)
        let backupDirectoryHandle = null;
        const DB_NAME = 'FamilyTasksDB';
        const STORE_NAME = 'backupSettings';
        
        // ==================== INITIALIZATION ====================
        
        let appInitialized = false;
        
        document.addEventListener('DOMContentLoaded', function() {
            firebase.auth().onAuthStateChanged(function(user) {
                if (!appInitialized) {
                    appInitialized = true;
                    initializeApp();
                }
            });
            // Fallback - ×× Auth ×œ× ×ž×’×™×‘ ×ª×•×š 3 ×©× ×™×•×ª
            setTimeout(function() {
                if (!appInitialized) {
                    appInitialized = true;
                    initializeApp();
                }
            }, 3000);
        });
        
        function initializeApp() {
            // Check if user is logged in
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser && familyMembers[savedUser]) {
                loginUser(savedUser);
            } else {
                showLoginScreen();
            }
        }
        
        // ==================== LOGIN ====================
        
        function showLoginScreen() {
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.add('hidden');
            renderLoginCards();
        }
        
        function renderLoginCards() {
            const grid = document.getElementById('loginGrid');
            grid.innerHTML = '';
            
            // ×”×¦×’ ×›×¨×˜×™×¡×™× ×ž×™×“
            Object.values(familyMembers).forEach(member => {
                const card = document.createElement('div');
                card.className = 'login-card';
                card.id = 'login-card-' + member.id;
                card.onclick = () => loginUser(member.id);
                
                card.innerHTML = `
                    <div class="login-icon">${member.icon}</div>
                    <div class="login-name">${member.name}</div>
                    <div class="login-role">${member.roleDescription || member.role}</div>
                `;
                
                grid.appendChild(card);
            });
            
            // ×”×•×¡×£ ×¡×¤×™×¨×ª ×ž×©×™×ž×•×ª ×‘×¨×§×¢
            tasksRef.once('value').then((snapshot) => {
                const tasksData = snapshot.val() || {};
                Object.values(familyMembers).forEach(member => {
                    const pendingCount = Object.values(tasksData).filter(task => 
                        task.assignedTo === member.id && task.status === 'pending'
                    ).length;
                    if (pendingCount > 0) {
                        const card = document.getElementById('login-card-' + member.id);
                        if (card) {
                            const badge = document.createElement('div');
                            badge.className = 'login-badge pending';
                            badge.textContent = pendingCount + ' ×ž×©×™×ž×•×ª';
                            card.appendChild(badge);
                        }
                    }
                });
            }).catch(() => {});
        }
        
        async function loginUser(userId) {
            currentUser = familyMembers[userId];
            localStorage.setItem('currentUser', userId);
            showMainApp();
            
            // Auto backup for Hagai on login
            if (userId === 'hagai') {
                await performBackup(true); // silent backup
            }
        }
        
        // User Management Modal
        function openUserManagementModal() {
            document.getElementById('userManagementModal').classList.add('active');
            loadCurrentUsers();
        }
        
        function closeUserManagementModal() {
            document.getElementById('userManagementModal').classList.remove('active');
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
        }
        
        function loadCurrentUsers() {
            const container = document.getElementById('currentUsersList');
            container.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                
                const roleText = member.isAdmin ? 'ðŸ‘‘ ×ž× ×”×œ/×ª' : 'ðŸ‘¶ ×™×œ×“/×”';
                
                userItem.innerHTML = `
                    <div class="user-item-info">
                        <div class="user-item-icon">${member.icon}</div>
                        <div class="user-item-details">
                            <div class="user-item-name">${member.name}</div>
                            <div class="user-item-role">${roleText}</div>
                        </div>
                    </div>
                    <div class="user-item-actions">
                        <button class="btn-icon" style="background: #FFF3E0; color: #F57C00;" onclick="editUser('${member.id}')">âœï¸</button>
                        <button class="btn-icon btn-delete" onclick="deleteUser('${member.id}')">ðŸ—‘ï¸</button>
                    </div>
                `;
                
                container.appendChild(userItem);
            });
        }
        
        function addNewUser() {
            const name = document.getElementById('newUserName').value.trim();
            const icon = document.getElementById('newUserIcon').value.trim();
            const role = document.getElementById('newUserRole').value;
            
            if (!name) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×©× ×ž×©×ª×ž×©');
                return;
            }
            
            if (!icon) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ××™×ž×•×’\'×™');
                return;
            }
            
            // Check if name already exists
            const nameExists = Object.values(familyMembers).some(m => m.name === name);
            if (nameExists) {
                alert('âŒ ×©× ×ž×©×ª×ž×© ×›×‘×¨ ×§×™×™×');
                return;
            }
            
            const userId = name.toLowerCase().replace(/\s/g, '');
            const isAdmin = role === 'admin';
            
            const colors = ['#E91E63', '#9C27B0', '#3F51B5', '#00BCD4', '#4CAF50', '#FF9800', '#795548'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const newUser = {
                id: userId,
                name: name,
                icon: icon,
                role: isAdmin ? '×ž× ×”×œ/×ª' : '×™×œ×“/×”',
                color: randomColor,
                isAdmin: isAdmin,
                canSpeak: false
            };
            
            // Add to familyMembers
            familyMembers[userId] = newUser;
            
            // Save to localStorage for persistence
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
            
            // Reload list
            loadCurrentUsers();
            
            // Update login grid
            renderLoginCards();
            
            showToast(`âœ… ${name} × ×•×¡×£/×” ×‘×”×¦×œ×—×”!`);
        }
        
        function editUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            const newName = prompt(`âœï¸ ×©× ×—×“×© ×¢×‘×•×¨ ${user.name}:`, user.name);
            if (!newName || newName.trim() === '') return;
            
            const newIcon = prompt(`âœï¸ ××™×ž×•×’'×™ ×—×“×© ×¢×‘×•×¨ ${user.name}:`, user.icon);
            if (!newIcon || newIcon.trim() === '') return;
            
            // Update user
            familyMembers[userId].name = newName.trim();
            familyMembers[userId].icon = newIcon.trim();
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`âœ… ${newName} ×¢×•×“×›×Ÿ/×” ×‘×”×¦×œ×—×”!`);
        }
        
        function deleteUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            // Prevent deletion of admins
            if (user.isAdmin) {
                alert('âŒ ×œ× × ×™×ª×Ÿ ×œ×ž×—×•×§ ×ž× ×”×œ×™× (×—×’×™ ×•×œ×™××ª)');
                return;
            }
            
            if (!confirm(`ðŸ—‘ï¸ ×”×× ×œ×ž×—×•×§ ××ª ${user.name}?\n\nâš ï¸ ×–×” ×™×ž×—×§ ×’× ××ª ×›×œ ×”×ž×©×™×ž×•×ª ×”×ž×•×§×¦×•×ª ×œ×•/×œ×”!`)) {
                return;
            }
            
            // Delete from familyMembers
            delete familyMembers[userId];
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Delete all tasks assigned to this user
            tasksRef.once('value', (snapshot) => {
                const tasksData = snapshot.val() || {};
                Object.keys(tasksData).forEach(taskId => {
                    if (tasksData[taskId].assignedTo === userId) {
                        tasksRef.child(taskId).remove();
                    }
                });
            });
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`ðŸ—‘ï¸ ${user.name} × ×ž×—×§/×” ×‘×”×¦×œ×—×”`);
        }
        
        function showMainApp() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            
            // Update header
            document.getElementById('userAvatar').textContent = currentUser.icon;
            document.getElementById('userName').textContent = currentUser.name;
            document.getElementById('userRole').textContent = currentUser.role;
            
            // Show/hide stats screen navigation - only for admins
            const navStats = document.getElementById('navStats');
            if (currentUser.isAdmin) {
                navStats.style.display = 'flex';
            } else {
                navStats.style.display = 'none';
            }
            
            // Show/hide top performers card - only for Hagai
            const topPerformersCard = document.getElementById('topPerformersCard');
            if (currentUser.id === 'hagai') {
                topPerformersCard.classList.remove('hidden');
            } else {
                topPerformersCard.classList.add('hidden');
            }
            
            // Show deletion history, backup, restore buttons ONLY for Hagai
            if (currentUser.id === 'hagai') {
                document.getElementById('btnDeletionHistory').classList.remove('hidden');
                document.getElementById('btnBackup').classList.remove('hidden');
                document.getElementById('btnRestore').classList.remove('hidden');
                setupAutoBackup();
            } else {
                // Hide for all other users
                document.getElementById('btnDeletionHistory').classList.add('hidden');
                document.getElementById('btnBackup').classList.add('hidden');
                document.getElementById('btnRestore').classList.add('hidden');
            }
            
            // Set default filter based on user role
            if (currentUser.isAdmin) {
                // Admins see "pending" by default
                currentFilter = 'pending';
                document.querySelector('.filter-btn[onclick*="pending"]').classList.add('active');
            } else {
                // Regular users see "my tasks" by default
                currentFilter = 'my-tasks';
                const myTasksBtn = document.getElementById('myTasksFilter');
                // Remove active from pending
                document.querySelector('.filter-btn[onclick*="pending"]').classList.remove('active');
                // Add active to my-tasks
                myTasksBtn.classList.add('active');
            }
            
            // Setup Firebase listeners
            setupFirebaseListeners();
            
            // Monitor connection status
            monitorConnection();
            
            // Populate assignee grid
            populateAssigneeGrid();
            populateQuickAssigneeGrid();
        }
        
        async function logout() {
            // Auto backup for Hagai before logout
            if (currentUser && currentUser.id === 'hagai') {
                await performBackup(true); // silent backup
            }
            
            currentUser = null;
            localStorage.removeItem('currentUser');
            
            // Remove Firebase listeners
            tasksRef.off();
            shoppingRef.off();
            deletionHistoryRef.off();
            
            showLoginScreen();
        }
        
        // ==================== FIREBASE LISTENERS ====================
        
        function setupFirebaseListeners() {
            // Tasks listener
            tasksRef.on('value', (snapshot) => {
                tasks = snapshot.val() || {};
                loadTasks();
                loadStats();
                updateTabCounts();
            });
            
            // Shopping listener
            shoppingRef.on('value', (snapshot) => {
                shopping = snapshot.val() || {};
                loadShopping();
                loadStats();
                updateTabCounts();
            });
            
            // Deletion history listener
            deletionHistoryRef.on('value', (snapshot) => {
                deletionHistory = snapshot.val() || [];
            });
        }
        
        function updateTabCounts() {
            // Count pending tasks for current user
            const allTasks = Object.values(tasks);
            const visibleTasks = allTasks.filter(t => !t.isPersonal || t.assignedTo === currentUser.id || currentUser.id === 'hagai');
            const pendingTasks = visibleTasks.filter(t => t.status === 'pending').length;
            
            // Count pending shopping items
            const allShopping = Object.values(shopping);
            const pendingShopping = allShopping.filter(i => i.status === 'pending').length;
            
            // Update bottom nav badges
            const navTasksBadge = document.getElementById('navTasksBadge');
            const navShoppingBadge = document.getElementById('navShoppingBadge');
            
            if (navTasksBadge) {
                navTasksBadge.textContent = pendingTasks;
                navTasksBadge.style.display = pendingTasks > 0 ? 'block' : 'none';
            }
            
            if (navShoppingBadge) {
                navShoppingBadge.textContent = pendingShopping;
                navShoppingBadge.style.display = pendingShopping > 0 ? 'block' : 'none';
            }
        }
        
        function monitorConnection() {
            const connectedRef = db.ref('.info/connected');
            connectedRef.on('value', (snap) => {
                isOnline = snap.val() === true;
                updateSyncStatus();
            });
        }
        
        function updateSyncStatus() {
            const statusDiv = document.getElementById('syncStatus');
            if (!statusDiv) return;
            
            if (isSyncing) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #FFA500;"></span> ×ž×¡× ×›×¨×Ÿ...';
            } else if (isOnline) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #4CAF50;"></span> ×ž×—×•×‘×¨';
            } else {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #f44336;"></span> ×œ× ×ž×—×•×‘×¨';
            }
        }
        
        // ==================== TABS ====================
        
        function switchScreen(screenName) {
            // Update bottom nav buttons
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('nav' + screenName.charAt(0).toUpperCase() + screenName.slice(1)).classList.add('active');
            
            // Update screen content
            document.getElementById('tasksTab').classList.toggle('hidden', screenName !== 'tasks');
            document.getElementById('shoppingTab').classList.toggle('hidden', screenName !== 'shopping');
            document.getElementById('statsScreen').classList.toggle('hidden', screenName !== 'stats');
            
            // Show/hide FAB based on screen
            const fab = document.querySelector('.fab');
            const fabMic = document.getElementById('fabMicBtn');
            if (screenName === 'stats') {
                fab.style.display = 'none';
                if (fabMic) fabMic.style.display = 'none';
            } else {
                fab.style.display = 'flex';
                if (fabMic) fabMic.style.display = 'flex';
            }
            
            // Clear search when leaving tabs
            if (screenName !== 'shopping') {
                shoppingSearchQuery = '';
                const searchInput = document.getElementById('shoppingSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
            
            if (screenName !== 'tasks') {
                tasksSearchQuery = '';
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
        }
        
        // Keep old switchTab for compatibility
        function switchTab(tabName) {
            switchScreen(tabName);
        }
        
        // ==================== TASKS ====================
        
        function populateAssigneeGrid() {
            const grid = document.getElementById('assigneeGrid');
            grid.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.style.color = member.color;
                btn.onclick = (e) => selectAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectAssignee(memberId, event) {
            selectedAssignee = memberId;
            
            // Update UI
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function selectPriority(priority, event) {
            selectedPriority = priority;
            
            // Update UI
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        // Quick Assignee Grid for Quick Add
        let quickSelectedAssignee = null;
        
        function populateQuickAssigneeGrid() {
            const grid = document.getElementById('quickAssigneeGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // Add "General" (everyone) option
            const generalBtn = document.createElement('button');
            generalBtn.type = 'button';
            generalBtn.className = 'assignee-btn';
            generalBtn.dataset.id = 'general';
            generalBtn.style.color = '#9C27B0';
            generalBtn.onclick = (e) => selectQuickAssignee('general', e);
            generalBtn.innerHTML = `
                <div class="assignee-icon">ðŸ‘¥</div>
                <div class="assignee-name">×›×•×œ×</div>
            `;
            grid.appendChild(generalBtn);
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.dataset.id = member.id;
                btn.style.color = member.color;
                btn.onclick = (e) => selectQuickAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectQuickAssignee(memberId, event) {
            quickSelectedAssignee = memberId;
            
            // Update UI
            const grid = document.getElementById('quickAssigneeGrid');
            grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function addQuickTask() {
            const input = document.getElementById('quickTaskInput');
            const taskName = input.value.trim();
            
            if (!taskName) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×©× ×ž×©×™×ž×”');
                return;
            }
            
            if (!quickSelectedAssignee) {
                alert('âŒ × × ×œ×‘×—×•×¨ ×œ×ž×™ ×œ×”×§×¦×•×ª ××ª ×”×ž×©×™×ž×”');
                return;
            }
            
            let newTask;
            
            if (quickSelectedAssignee === 'general') {
                newTask = {
                    id: 'task_' + Date.now(),
                    title: taskName,
                    description: '',
                    assignedTo: 'general',
                    assignedToName: '×›×•×œ×',
                    assignedToIcon: 'ðŸ‘¥',
                    assignedToColor: '#9C27B0',
                    priority: 'medium',
                    status: 'pending',
                    createdAt: Date.now(),
                    createdBy: currentUser.name,
                    createdById: currentUser.id,
                    isPinned: false,
                    isPersonal: false,
                    isGeneral: true,
                    isRecurring: false,
                    dueDate: null
                };
            } else {
                const assignee = familyMembers[quickSelectedAssignee];
                newTask = {
                    id: 'task_' + Date.now(),
                    title: taskName,
                    description: '',
                    assignedTo: assignee.id,
                    assignedToName: assignee.name,
                    assignedToIcon: assignee.icon,
                    assignedToColor: assignee.color,
                    priority: 'medium',
                    status: 'pending',
                    createdAt: Date.now(),
                    createdBy: currentUser.name,
                    createdById: currentUser.id,
                    isPinned: false,
                    isPersonal: assignee.id === currentUser.id,
                    isGeneral: false,
                    isRecurring: false,
                    dueDate: null
                };
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(newTask.id).set(newTask)
                .then(() => {
                    input.value = '';
                    quickSelectedAssignee = null;
                    
                    // Reset selection
                    const grid = document.getElementById('quickAssigneeGrid');
                    grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
                    
                    showToast(`âœ… ×ž×©×™×ž×” × ×•×¡×¤×” ×œ-${newTask.assignedToName}!`);
                })
                .catch(error => {
                    console.error('Error adding task:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×•×¡×¤×ª ×”×ž×©×™×ž×”');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // FAB - Smart modal opener based on active tab
        function openFABModal() {
            const tasksTab = document.getElementById('tasksTab');
            const shoppingTab = document.getElementById('shoppingTab');
            
            if (!tasksTab.classList.contains('hidden')) {
                // Tasks tab is active - open task modal
                openAddTaskModal();
            } else if (!shoppingTab.classList.contains('hidden')) {
                // Shopping tab is active - open shopping modal
                openAddShoppingModal();
            } else {
                // Default to task modal
                openAddTaskModal();
            }
        }
        
        function openAddTaskModal() {
            document.getElementById('addTaskModal').classList.add('active');
            
            // Show recurring option only for admins
            const recurringGroup = document.getElementById('recurringGroup');
            if (currentUser.isAdmin) {
                recurringGroup.style.display = 'block';
            } else {
                recurringGroup.style.display = 'none';
            }
        }
        
        function closeAddTaskModal() {
            document.getElementById('addTaskModal').classList.remove('active');
            document.getElementById('addTaskForm').reset();
            selectedAssignee = null;
            selectedPriority = 'medium';
            
            // Reset recurring options
            document.getElementById('recurringOptions').style.display = 'none';
            
            // Reset selections
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.priority-btn[onclick*="medium"]').classList.add('selected');
        }
        
        function toggleRecurringOptions() {
            const isRecurring = document.getElementById('taskIsRecurring').checked;
            const options = document.getElementById('recurringOptions');
            options.style.display = isRecurring ? 'block' : 'none';
        }
        
        function submitTask(event) {
            event.preventDefault();
            
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const dueDate = document.getElementById('taskDueDate').value;
            const isPersonal = document.getElementById('taskIsPersonal').checked;
            const isRecurring = document.getElementById('taskIsRecurring') ? document.getElementById('taskIsRecurring').checked : false;
            const recurringType = isRecurring ? document.getElementById('recurringType').value : null;
            
            if (!title || !selectedAssignee) {
                alert('× × ×œ×ž×œ× ××ª ×›×œ ×”×©×“×•×ª ×”×—×•×‘×”');
                return;
            }
            
            const assignedUser = familyMembers[selectedAssignee];
            const taskId = 'task_' + Date.now();
            
            const task = {
                id: taskId,
                title,
                description,
                assignedTo: selectedAssignee,
                assignedToName: assignedUser.name,
                assignedToIcon: assignedUser.icon,
                assignedToColor: assignedUser.color,
                dueDate,
                priority: selectedPriority,
                status: 'pending',
                createdAt: Date.now(),
                createdBy: currentUser.name,
                createdById: currentUser.id,
                completedAt: null,
                completedBy: null,
                completedById: null,
                isPersonal,
                isPinned: false,
                notes: [],
                isRecurring,
                recurringType,
                lastCompletedAt: null
            };
            
            // Add to Firebase
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).set(task)
                .then(() => {
                    console.log('âœ… ×ž×©×™×ž×” × ×•×¡×¤×” ×œ-Firebase');
                    closeAddTaskModal();
                })
                .catch(error => {
                    console.error('âŒ ×©×’×™××”:', error);
                    alert('×©×’×™××” ×‘×”×•×¡×¤×ª ×”×ž×©×™×ž×”');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadTasks() {
            const container = document.getElementById('tasksList');
            container.innerHTML = '';
            
            let filteredTasks = Object.values(tasks);
            
            // Filter by visibility based on user role
            if (currentUser.isAdmin) {
                // Admins (Liat and Hagai) see all non-personal tasks + their own personal tasks + general
                // Hagai sees everything including all personal tasks
                if (currentUser.id !== 'hagai') {
                    // Liat sees all tasks except personal tasks of others
                    filteredTasks = filteredTasks.filter(task => 
                        !task.isPersonal || task.assignedTo === currentUser.id || task.isGeneral
                    );
                }
                // Hagai sees ALL tasks (no filter)
            } else {
                // Regular users see: their own tasks + general tasks
                filteredTasks = filteredTasks.filter(task => 
                    task.assignedTo === currentUser.id || task.isGeneral || task.assignedTo === 'general'
                );
            }
            
            // Apply search filter
            if (tasksSearchQuery) {
                filteredTasks = filteredTasks.filter(task => 
                    task.title.toLowerCase().includes(tasksSearchQuery.toLowerCase()) ||
                    (task.description && task.description.toLowerCase().includes(tasksSearchQuery.toLowerCase())) ||
                    (task.assignedToName && task.assignedToName.toLowerCase().includes(tasksSearchQuery.toLowerCase()))
                );
            }
            
            // Apply status/type filter
            if (currentFilter === 'pending') {
                filteredTasks = filteredTasks.filter(t => t.status === 'pending');
            } else if (currentFilter === 'completed') {
                filteredTasks = filteredTasks.filter(t => t.status === 'completed');
            } else if (currentFilter === 'personal') {
                // Show only MY personal tasks (tasks I created for myself)
                filteredTasks = filteredTasks.filter(t => {
                    // Personal task must be mine (assigned to me)
                    return t.isPersonal === true && t.assignedTo === currentUser.id;
                });
            } else if (currentFilter === 'my-tasks') {
                // Show only tasks assigned to me that are pending
                // Exclude recurring tasks that were completed today
                const today = new Date().setHours(0, 0, 0, 0);
                filteredTasks = filteredTasks.filter(t => {
                    // Must be assigned to me
                    if (t.assignedTo !== currentUser.id) return false;
                    
                    // If completed, don't show
                    if (t.status === 'completed') return false;
                    
                    // If recurring and completed today, don't show
                    if (t.isRecurring && t.lastCompletedAt) {
                        const completedDate = new Date(t.lastCompletedAt).setHours(0, 0, 0, 0);
                        if (completedDate === today) {
                            return false; // Hide tasks completed today
                        }
                    }
                    
                    return true;
                });
            } else if (currentFilter === 'general') {
                // Show only general tasks (assigned to everyone)
                filteredTasks = filteredTasks.filter(t => 
                    (t.isGeneral || t.assignedTo === 'general') && t.status === 'pending'
                );
            }
            
            // Sort: pinned first, then by status, then by date
            // Note: In 'my-tasks' filter, don't push personal tasks to the end
            filteredTasks.sort((a, b) => {
                // Pinned always first
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                
                // Pending before completed
                if (a.status === 'pending' && b.status === 'completed') return -1;
                if (a.status === 'completed' && b.status === 'pending') return 1;
                
                // Within same status: regular tasks before personal tasks
                // EXCEPT in 'my-tasks' and 'personal' filters where we don't separate
                if (a.status === b.status && currentFilter !== 'my-tasks' && currentFilter !== 'personal') {
                    if (!a.isPersonal && b.isPersonal) return -1;
                    if (a.isPersonal && !b.isPersonal) return 1;
                }
                
                // Finally by date
                return b.createdAt - a.createdAt;
            });
            
            // Update filter counts
            const allTasks = Object.values(tasks).filter(t => {
                if (currentUser.isAdmin) {
                    if (currentUser.id === 'hagai') return true; // Hagai sees all
                    return !t.isPersonal || t.assignedTo === currentUser.id; // Liat sees all except others' personal
                }
                return t.assignedTo === currentUser.id; // Regular users see only their tasks
            });
            
            // Helper function to check if task should be counted
            const today = new Date().setHours(0, 0, 0, 0);
            const shouldCountTask = (t) => {
                // Don't count completed tasks
                if (t.status === 'completed') return false;
                
                // Don't count recurring tasks completed today
                if (t.isRecurring && t.lastCompletedAt) {
                    const completedDate = new Date(t.lastCompletedAt).setHours(0, 0, 0, 0);
                    if (completedDate === today) return false;
                }
                
                return true;
            };
            
            const pending = allTasks.filter(t => shouldCountTask(t) && t.status === 'pending').length;
            const personal = allTasks.filter(t => shouldCountTask(t) && t.isPersonal && t.assignedTo === currentUser.id).length;
            const myTasks = allTasks.filter(t => shouldCountTask(t) && t.assignedTo === currentUser.id).length;
            const generalTasks = Object.values(tasks).filter(t => shouldCountTask(t) && (t.isGeneral || t.assignedTo === 'general')).length;
            
            document.getElementById('pendingTasksCount').textContent = pending;
            document.getElementById('personalTasksCount').textContent = personal;
            document.getElementById('myTasksCount').textContent = myTasks;
            document.getElementById('generalTasksCount').textContent = generalTasks;
            
            if (filteredTasks.length === 0) {
                const emptyMessage = tasksSearchQuery 
                    ? `×œ× × ×ž×¦××• ×ª×•×¦××•×ª ×¢×‘×•×¨ "${tasksSearchQuery}"`
                    : '××™×Ÿ ×ž×©×™×ž×•×ª ×œ×”×¦×’×”';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ðŸ“‹</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredTasks.forEach((task, index) => {
                const taskEl = createTaskElement(task, index);
                container.appendChild(taskEl);
            });
        }
        
        function createTaskElement(task, index) {
            const div = document.createElement('div');
            div.className = `item ${task.isPinned ? 'pinned' : ''} ${task.status === 'completed' ? 'completed' : ''} ${task.isPersonal ? 'personal-task' : ''}`;
            div.setAttribute('data-task-id', task.id);
            div.dataset.itemId = task.id;
            
            const priorityLabels = {
                high: { emoji: 'ðŸ”´', class: 'badge-priority-high', text: '×’×‘×•×”×”' },
                medium: { emoji: 'ðŸŸ¡', class: 'badge-priority-medium', text: '×¨×’×™×œ×”' },
                low: { emoji: 'ðŸŸ¢', class: 'badge-priority-low', text: '× ×ž×•×›×”' }
            };
            
            const priority = priorityLabels[task.priority];
            const isAdmin = currentUser.isAdmin;
            
            const dueDate = task.dueDate ? new Date(task.dueDate) : null;
            
            // Build action buttons
            let actions = '';
            
            if (task.status === 'pending') {
                actions += `<button class="btn-icon btn-complete" onclick="completeTask('${task.id}')">âœ“</button>`;
            }
            
            if (isAdmin) {
                actions += `<button class="btn-icon btn-delete" onclick="deleteTask('${task.id}')">ðŸ—‘ï¸</button>`;
            }
            
            // Add to Calendar button - always show
            actions += `<button class="btn-icon btn-calendar" onclick="addToCalendar('${task.id}')" title="×”×•×¡×£ ×œ×™×•×ž×Ÿ">ðŸ“…</button>`;
            
            // Creator name (only if different from assignee)
            let creatorText = '';
            if (task.createdById && task.createdBy && task.createdById !== task.assignedTo) {
                creatorText = ` <span style="font-size: 0.75rem; color: #666;">(${task.createdBy})</span>`;
            }
            
            div.innerHTML = `
                <div class="swipe-indicator left">âœ“</div>
                <div class="swipe-indicator right">â†©ï¸</div>
                <div class="swipe-indicator up">â¬†ï¸</div>
                <div class="swipe-indicator down">â¬‡ï¸</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${task.isPinned ? 'ðŸ“Œ ' : ''}${task.isRecurring ? 'ðŸ”„ ' : ''}${task.isPersonal ? 'ðŸ”’ ' : ''}${task.title}${task.description ? ` (${task.description})` : ''} â€¢ ${task.assignedToIcon} ${task.assignedToName}${task.createdAt ? ` â€¢ ${new Date(task.createdAt).toLocaleDateString('he-IL')}${creatorText}` : ''}${task.status === 'completed' && task.completedBy ? ` â€¢ âœ“ ${task.completedBy}` : ''}
                </div>
                <div class="item-actions">${actions}</div>
            `;
            
            // Add touch handlers for swipe
            setupTaskSwipeHandlers(div, task);
            
            return div;
        }
        
        // Swipe Handler Setup for Tasks
        function setupTaskSwipeHandlers(element, task) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            let longPressTimer = null;
            let canSwipeVertical = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                canSwipeVertical = false;
                element.classList.add('swiping');
                
                // Start long press timer for vertical swipe (0.5 seconds)
                longPressTimer = setTimeout(() => {
                    canSwipeVertical = true;
                    // Vibrate if available
                    if (navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                }, 500);
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Cancel long press if moved horizontally
                if (Math.abs(diffX) > 10 && longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Horizontal swipe (immediate) - always block scroll for horizontal movement
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (canSwipeVertical && Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Vertical swipe after long press - show indicator only, don't move element
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swiping up - will move to TOP of list
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                        upIndicator.textContent = 'â¬†ï¸ ×œ×¨××©';
                    } else if (diffY > 30) {
                        // Swiping down - will move to BOTTOM of list
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                        downIndicator.textContent = 'â¬‡ï¸ ×œ×¡×•×£';
                    }
                }
                // If vertical movement but canSwipeVertical is false, allow normal scrolling
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as complete)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'pending') {
                        completeTask(task.id);
                    }
                }
                // Swipe right (uncomplete)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'completed') {
                        uncompleteTask(task.id);
                    }
                }
                // Swipe up - move to TOP of list
                else if (canSwipeVertical && diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveTaskUp(task.id);
                }
                // Swipe down - move to BOTTOM of list
                else if (canSwipeVertical && diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveTaskDown(task.id);
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                    canSwipeVertical = false;
                }
            });
        }
        
        // Move task up (increase priority by changing createdAt)
        function moveTaskUp(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set createdAt to future (moves to top)
            const newCreatedAt = Date.now() + 1000000;
            
            tasksRef.child(taskId).update({
                createdAt: newCreatedAt
            }).then(() => {
                showToast('â¬†ï¸ ×”×ž×©×™×ž×” ×¢×œ×ª×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        // Move task down (decrease priority by changing createdAt)
        function moveTaskDown(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set createdAt to very old (moves to bottom) - use 1 to ensure it's the oldest
            const newCreatedAt = 1;
            
            tasksRef.child(taskId).update({
                createdAt: newCreatedAt
            }).then(() => {
                showToast('â¬‡ï¸ ×”×ž×©×™×ž×” ×™×¨×“×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function completeTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            if (task.isRecurring) {
                // For recurring tasks, reset instead of marking as completed
                tasksRef.child(taskId).update({
                    lastCompletedAt: Date.now(),
                    lastCompletedBy: currentUser.name,
                    lastCompletedById: currentUser.id
                }).then(() => {
                    console.log('âœ… ×ž×©×™×ž×” ×ž×—×–×•×¨×™×ª ×”×•×©×œ×ž×” ×•××•×¤×¡×”');
                    // Show notification
                    showToast(`âœ… ${task.title} ×‘×•×¦×¢×”! ×”×ž×©×™×ž×” ×ª×—×–×•×¨ ${task.recurringType === 'daily' ? '×ž×—×¨' : '×‘×©×‘×•×¢ ×”×‘×'}`);
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            } else {
                // Regular task - mark as completed
                tasksRef.child(taskId).update({
                    status: 'completed',
                    completedAt: Date.now(),
                    completedBy: currentUser.name,
                    completedById: currentUser.id
                }).then(() => {
                    showToast('âœ… ×”×ž×©×™×ž×” ×”×•×©×œ×ž×”');
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            }
        }
        
        function uncompleteTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Set dueDate to today when uncompleting
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            tasksRef.child(taskId).update({
                status: 'pending',
                completedAt: null,
                completedBy: null,
                completedById: null,
                dueDate: today.getTime()
            }).then(() => {
                showToast('â†©ï¸ ×”×ž×©×™×ž×” ×—×–×¨×” ×œ×ž×¦×‘ ×ž×ž×ª×™×Ÿ ×¢× ×ª××¨×™×š ×”×™×•×');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #4CAF50, #66BB6A);
                color: white;
                padding: 15px 30px;
                border-radius: 12px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: slideUp 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function addToCalendar(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            // Use task's dueDate or today's date as default
            const dueDate = task.dueDate ? new Date(task.dueDate) : new Date();
            
            // Format task details for Google Calendar
            const title = task.title;
            const description = task.description || '';
            const priority = task.priority === 'high' ? 'ðŸ”´ ×¢×“×™×¤×•×ª ×’×‘×•×”×”' : task.priority === 'medium' ? 'ðŸŸ¡ ×¢×“×™×¤×•×ª ×¨×’×™×œ×”' : 'ðŸŸ¢ ×¢×“×™×¤×•×ª × ×ž×•×›×”';
            const assignedTo = `×ž×•×§×¦×” ×œ: ${task.assignedToName}`;
            
            const fullDescription = `${description}\n\n${priority}\n${assignedTo}`;
            
            // Format date for Google Calendar (YYYYMMDDTHHMMSS format)
            const startDate = new Date(dueDate);
            startDate.setHours(9, 0, 0); // Set to 9:00 AM
            
            const endDate = new Date(dueDate);
            endDate.setHours(10, 0, 0); // Set to 10:00 AM (1 hour duration)
            
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
            };
            
            const startDateFormatted = formatDate(startDate);
            const endDateFormatted = formatDate(endDate);
            
            // Build Google Calendar URL
            const baseUrl = 'https://calendar.google.com/calendar/render';
            const params = new URLSearchParams({
                action: 'TEMPLATE',
                text: title,
                dates: `${startDateFormatted}/${endDateFormatted}`,
                details: fullDescription,
                location: '',
                trp: 'false'
            });
            
            const calendarUrl = `${baseUrl}?${params.toString()}`;
            
            // Open in new window
            window.open(calendarUrl, '_blank');
            
            showToast('ðŸ“… × ×¤×ª×— Google Calendar!');
        }
        
        function deleteTask(taskId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×ž×—×•×§ ×ž×©×™×ž×•×ª');
                return;
            }
            
            const task = tasks[taskId];
            if (!task) return;
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×ž×—×•×§ ××ª ×”×ž×©×™×ž×” "${task.title}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'task',
                item: task.title,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: task
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                tasksRef.child(taskId).remove()
            ]).then(() => {
                console.log('âœ… ×ž×©×™×ž×” × ×ž×—×§×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).update({
                isPinned: !task.isPinned
            }).then(() => {
                console.log('ðŸ“Œ ×”×¦×ž×“×” ×©×•× ×ª×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function readTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            if (!('speechSynthesis' in window)) {
                alert('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•×ž×š ×‘×”×§×¨××”. × ×¡×” ×œ×”×©×ª×ž×© ×‘-Chrome ××• Edge.');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            let speechText = `×ž×©×™×ž×”: ${task.title}. `;
            
            if (task.description) {
                speechText += `${task.description}. `;
            }
            
            speechText += `××—×¨××™: ${task.assignedToName}. `;
            
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const formattedDate = dueDate.toLocaleDateString('he-IL');
                speechText += `×ª××¨×™×š ×™×¢×“: ${formattedDate}. `;
            }
            
            const priorityText = {
                high: '×¢×“×™×¤×•×ª ×’×‘×•×”×”',
                medium: '×¢×“×™×¤×•×ª ×¨×’×™×œ×”',
                low: '×¢×“×™×¤×•×ª × ×ž×•×›×”'
            };
            speechText += priorityText[task.priority] + '. ';
            
            if (task.status === 'completed') {
                speechText += `×”×ž×©×™×ž×” ×‘×•×¦×¢×” ×¢×œ ×™×“×™ ${task.completedBy}. `;
            } else {
                speechText += '×”×ž×©×™×ž×” ×ž×ž×ª×™× ×” ×œ×‘×™×¦×•×¢.';
            }
            
            const utterance = new SpeechSynthesisUtterance(speechText);
            utterance.lang = 'he-IL';
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            const readButton = taskElement ? taskElement.querySelector('.read-btn') : null;
            
            if (readButton) {
                readButton.classList.add('reading');
            }
            
            utterance.onend = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
            };
            
            utterance.onerror = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
                alert('×©×’×™××” ×‘×”×§×¨××ª ×”×ž×©×™×ž×”');
            };
            
            window.speechSynthesis.speak(utterance);
        }
        
        function filterTasks(filter, event) {
            currentFilter = filter;
            
            // Update filter buttons
            const tasksTab = document.getElementById('tasksTab');
            tasksTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadTasks();
        }
        
        function filterTasksBySearch() {
            tasksSearchQuery = document.getElementById('tasksSearchInput').value.trim();
            loadTasks();
        }
        
        function filterByMember(memberId) {
            // Switch to tasks tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab')[0].classList.add('active'); // First tab is tasks
            
            document.getElementById('tasksTab').classList.remove('hidden');
            document.getElementById('shoppingTab').classList.add('hidden');
            
            // Set filter to pending
            currentFilter = 'pending';
            document.querySelectorAll('#tasksTab .filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#tasksTab .filter-btn')[0].classList.add('active'); // First filter is pending
            
            // Set search to member name
            const member = familyMembers[memberId];
            if (member) {
                tasksSearchQuery = member.name;
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = member.name;
                }
                loadTasks();
            }
        }
        
        // ==================== NOTES ====================
        
        function openNotesModal(taskId) {
            currentTaskForNotes = taskId;
            const task = tasks[taskId];
            if (!task) return;
            
            const modal = document.getElementById('notesModal');
            const notesList = document.getElementById('notesList');
            const addNoteSection = document.getElementById('addNoteSection');
            
            // Check if user can add notes (only assigned user)
            const canAddNote = task.assignedTo === currentUser.id;
            addNoteSection.style.display = canAddNote ? 'block' : 'none';
            
            // Render existing notes
            notesList.innerHTML = '';
            if (task.notes && task.notes.length > 0) {
                task.notes.forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note-item';
                    noteEl.style.borderRightColor = note.authorColor || '#E0E0E0';
                    
                    const date = new Date(note.createdAt);
                    noteEl.innerHTML = `
                        <div class="note-header">
                            <span class="note-author">
                                ${note.authorIcon} ${note.authorName}
                            </span>
                            <span>${date.toLocaleDateString('he-IL')} ${date.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                        <div class="note-text">${note.text}</div>
                    `;
                    notesList.appendChild(noteEl);
                });
            } else {
                notesList.innerHTML = '<div class="empty-state"><div class="empty-icon">ðŸ’¬</div><div class="empty-text">××™×Ÿ ×”×¢×¨×•×ª ×œ×ž×©×™×ž×” ×–×•</div></div>';
            }
            
            modal.classList.add('active');
        }
        
        function closeNotesModal() {
            document.getElementById('notesModal').classList.remove('active');
            document.getElementById('newNoteText').value = '';
            currentTaskForNotes = null;
        }
        
        function addNote() {
            const text = document.getElementById('newNoteText').value.trim();
            if (!text) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×ª×•×›×Ÿ ×œ×”×¢×¨×”');
                return;
            }
            
            const task = tasks[currentTaskForNotes];
            if (!task) return;
            
            if (task.assignedTo !== currentUser.id) {
                alert('âŒ ×¨×§ ×ž×§×‘×œ ×”×ž×©×™×ž×” ×™×›×•×œ ×œ×”×•×¡×™×£ ×”×¢×¨×•×ª');
                return;
            }
            
            const note = {
                text,
                authorId: currentUser.id,
                authorName: currentUser.name,
                authorIcon: currentUser.icon,
                authorColor: currentUser.color,
                createdAt: Date.now()
            };
            
            const notes = task.notes || [];
            notes.push(note);
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(currentTaskForNotes).update({ notes })
                .then(() => {
                    console.log('âœ… ×”×¢×¨×” × ×•×¡×¤×”');
                    document.getElementById('newNoteText').value = '';
                    openNotesModal(currentTaskForNotes); // Refresh
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== SHOPPING ====================
        
        function quickAddItem(event) {
            event.preventDefault();
            
            const itemName = document.getElementById('quickItemInput').value.trim();
            if (!itemName) return;
            
            const itemId = 'item_' + Date.now();
            
            const item = {
                id: itemId,
                name: itemName,
                addedBy: currentUser.name,
                addedById: currentUser.id,
                addedByIcon: currentUser.icon,
                addedByColor: currentUser.color,
                addedAt: Date.now(),
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null,
                isPinned: false
            };
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).set(item)
                .then(() => {
                    console.log('âœ… ×¤×¨×™×˜ × ×•×¡×£');
                    document.getElementById('quickItemInput').value = '';
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadShopping() {
            const container = document.getElementById('shoppingList');
            container.innerHTML = '';
            
            let filteredItems = Object.values(shopping);
            
            // Apply search filter
            if (shoppingSearchQuery) {
                filteredItems = filteredItems.filter(item => 
                    item.name.toLowerCase().includes(shoppingSearchQuery.toLowerCase())
                );
            }
            
            // Apply status filter
            if (currentShoppingFilter === 'pending') {
                filteredItems = filteredItems.filter(item => item.status === 'pending');
            } else if (currentShoppingFilter === 'purchased') {
                filteredItems = filteredItems.filter(item => item.status === 'purchased');
            }
            
            // Sort: pinned first, then by status, then by date
            filteredItems.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                if (a.status === 'pending' && b.status === 'purchased') return -1;
                if (a.status === 'purchased' && b.status === 'pending') return 1;
                return b.addedAt - a.addedAt;
            });
            
            if (filteredItems.length === 0) {
                const emptyMessage = shoppingSearchQuery 
                    ? `×œ× × ×ž×¦××• ×ª×•×¦××•×ª ×¢×‘×•×¨ "${shoppingSearchQuery}"`
                    : '××™×Ÿ ×¤×¨×™×˜×™× ×œ×”×¦×’×”';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ðŸ›’</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredItems.forEach((item, index) => {
                const itemEl = createShoppingElement(item, index);
                container.appendChild(itemEl);
            });
        }
        
        function createShoppingElement(item, index) {
            const div = document.createElement('div');
            div.className = `item ${item.isPinned ? 'pinned' : ''} ${item.status === 'purchased' ? 'purchased' : ''}`;
            div.dataset.itemId = item.id;
            
            const isAdmin = currentUser.isAdmin;
            
            const addedDate = new Date(item.addedAt);
            
            // Build action buttons
            let actions = '';
            
            if (item.status === 'pending') {
                actions += `<button class="btn-icon btn-complete" onclick="purchaseItem('${item.id}')">âœ“</button>`;
            }
            
            if (isAdmin) {
                actions += `<button class="btn-icon btn-delete" onclick="deleteShoppingItem('${item.id}')">ðŸ—‘ï¸</button>`;
            }
            
            div.innerHTML = `
                <div class="swipe-indicator left">âœ“</div>
                <div class="swipe-indicator right">â†©ï¸</div>
                <div class="swipe-indicator up">â¬†ï¸</div>
                <div class="swipe-indicator down">â¬‡ï¸</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${item.isPinned ? 'ðŸ“Œ ' : ''}${item.name} â€¢ ${item.addedByIcon} ${item.addedBy} â€¢ ðŸ“… ${addedDate.toLocaleDateString('he-IL')}${item.status === 'purchased' && item.purchasedBy ? ` â€¢ âœ“ ${item.purchasedBy}` : ''}
                </div>
                <div class="item-actions">${actions}</div>
            `;
            
            // Add touch handlers for swipe
            setupSwipeHandlers(div, item);
            
            return div;
        }
        
        // Swipe Handler Setup
        function setupSwipeHandlers(element, item) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            let longPressTimer = null;
            let canSwipeVertical = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                canSwipeVertical = false;
                element.classList.add('swiping');
                
                // Start long press timer for vertical swipe (0.5 seconds)
                longPressTimer = setTimeout(() => {
                    canSwipeVertical = true;
                    // Vibrate if available
                    if (navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                }, 500);
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Cancel long press if moved horizontally
                if (Math.abs(diffX) > 10 && longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                // Horizontal swipe (immediate) - always block scroll for horizontal movement
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (canSwipeVertical && Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Vertical swipe after long press - show indicator only, don't move element
                    if (e.cancelable) e.preventDefault();
                    isSwiping = true;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swiping up - will move to TOP of list
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                        upIndicator.textContent = 'â¬†ï¸ ×œ×¨××©';
                    } else if (diffY > 30) {
                        // Swiping down - will move to BOTTOM of list
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                        downIndicator.textContent = 'â¬‡ï¸ ×œ×¡×•×£';
                    }
                }
                // If vertical movement but canSwipeVertical is false, allow normal scrolling
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                // Clear long press timer
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as purchased)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'pending') {
                        purchaseItem(item.id);
                    }
                }
                // Swipe right (unmark as purchased)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'purchased') {
                        unpurchaseItem(item.id);
                    }
                }
                // Swipe up - move to TOP of list
                else if (canSwipeVertical && diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemUp(item.id);
                }
                // Swipe down - move to BOTTOM of list
                else if (canSwipeVertical && diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemDown(item.id);
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                    canSwipeVertical = false;
                }
            });
        }
        
        // Move shopping item up in the list
        function moveShoppingItemUp(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Increase priority by setting addedAt to now
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: Date.now()
            })
                .then(() => {
                    showToast('â¬†ï¸ ×”×¤×¨×™×˜ ×”×•×¢×œ×” ×œ×ž×¢×œ×” ×‘×¨×©×™×ž×”');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×¢×œ××ª ×”×¤×¨×™×˜');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function moveShoppingItemDown(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Set addedAt to 1 (oldest possible) - moves to bottom
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: 1
            })
                .then(() => {
                    showToast('â¬‡ï¸ ×”×¤×¨×™×˜ ×”×•×¨×“ ×œ×¡×•×£ ×”×¨×©×™×ž×”');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×•×¨×“×ª ×”×¤×¨×™×˜');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function purchaseItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×¡×ž×Ÿ ×¤×¨×™×˜×™× ×›× ×§× ×•');
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'purchased',
                purchasedAt: Date.now(),
                purchasedBy: currentUser.name,
                purchasedById: currentUser.id
            }).then(() => {
                console.log('âœ… ×¤×¨×™×˜ ×¡×•×ž×Ÿ ×›× ×§× ×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function unpurchaseItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null
            }).then(() => {
                showToast('â†©ï¸ ×”×¤×¨×™×˜ ×—×–×¨ ×œ×¨×©×™×ž×ª ×”×§× ×™×•×ª');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function deleteShoppingItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×ž×—×•×§ ×¤×¨×™×˜×™×');
                return;
            }
            
            const item = shopping[itemId];
            if (!item) return;
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×ž×—×•×§ ××ª "${item.name}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'shopping',
                item: item.name,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: item
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                shoppingRef.child(itemId).remove()
            ]).then(() => {
                console.log('âœ… ×¤×¨×™×˜ × ×ž×—×§');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinShoppingItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                isPinned: !item.isPinned
            }).then(() => {
                console.log('ðŸ“Œ ×”×¦×ž×“×” ×©×•× ×ª×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function filterShopping(filter, event) {
            currentShoppingFilter = filter;
            
            // Update filter buttons
            const shoppingTab = document.getElementById('shoppingTab');
            shoppingTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadShopping();
        }
        
        function filterShoppingBySearch() {
            shoppingSearchQuery = document.getElementById('shoppingSearchInput').value.trim();
            loadShopping();
        }
        
        // ==================== DELETION HISTORY ====================
        
        function openDeletionHistoryModal() {
            const modal = document.getElementById('deletionHistoryModal');
            const tbody = document.getElementById('deletionHistoryBody');
            
            tbody.innerHTML = '';
            
            if (deletionHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 40px; color: var(--text-secondary);">××™×Ÿ ×¤×¨×™×˜×™× ×‘×ž×—×™×§×•×ª</td></tr>';
            } else {
                deletionHistory.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    const typeIcon = entry.type === 'task' ? 'ðŸ“‹' : 'ðŸ›’';
                    const typeText = entry.type === 'task' ? '×ž×©×™×ž×”' : '×§× ×™×™×”';
                    
                    const canRestore = currentUser.isAdmin;
                    
                    row.innerHTML = `
                        <td>${typeIcon} ${typeText}</td>
                        <td>${entry.item}</td>
                        <td>${entry.deletedBy}</td>
                        <td>${entry.deletedAt}</td>
                        <td>
                            ${canRestore ? `<button class="btn btn-secondary" onclick="restoreItem(${index})">â†©ï¸ ×©×—×–×¨</button>` : 'â€”'}
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            }
            
            modal.classList.add('active');
        }
        
        function closeDeletionHistoryModal() {
            document.getElementById('deletionHistoryModal').classList.remove('active');
        }
        
        function restoreItem(index) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×©×—×–×¨ ×¤×¨×™×˜×™×');
                return;
            }
            
            const entry = deletionHistory[index];
            if (!entry) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Restore the item
            const restorePromise = entry.type === 'task' 
                ? tasksRef.child(entry.originalItem.id).set(entry.originalItem)
                : shoppingRef.child(entry.originalItem.id).set(entry.originalItem);
            
            // Remove from deletion history
            const newHistory = deletionHistory.filter((_, i) => i !== index);
            
            Promise.all([
                restorePromise,
                deletionHistoryRef.set(newHistory)
            ]).then(() => {
                console.log('âœ… ×¤×¨×™×˜ ×©×•×—×–×¨');
                openDeletionHistoryModal(); // Refresh
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function clearDeletionHistory() {
            if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ× ×§×•×ª ××ª ×›×œ ×”×”×™×¡×˜×•×¨×™×”?')) {
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            deletionHistoryRef.set([])
                .then(() => {
                    console.log('âœ… ×”×™×¡×˜×•×¨×™×” × ×•×§×ª×”');
                    closeDeletionHistoryModal();
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== STATISTICS ====================
        
        function loadStats() {
            const allTasks = Object.values(tasks);
            const allShopping = Object.values(shopping);
            
            const hasTasks = allTasks.length > 0;
            const hasShopping = allShopping.length > 0;
            
            // Create tabs structure
            let statsHTML = `
                <div class="stat-tabs">
                    <button class="stat-tab active" onclick="switchStatTab('tasks-stat')">ðŸ“‹ ×ž×©×™×ž×•×ª</button>
                    <button class="stat-tab" onclick="switchStatTab('shopping-stat')">ðŸ›’ ×§× ×™×•×ª</button>
                </div>
            `;
            
            // Tasks stats content
            statsHTML += '<div id="tasks-stat" class="stat-content active">';
            
            if (hasTasks) {
                // Count pending tasks per member
                const memberTaskCounts = {};
                Object.keys(familyMembers).forEach(memberId => {
                    if (memberId !== 'everyone') {
                        memberTaskCounts[memberId] = 0;
                    }
                });
                
                allTasks.forEach(task => {
                    if (task.status === 'pending' && task.assignedTo) {
                        if (memberTaskCounts[task.assignedTo] !== undefined) {
                            memberTaskCounts[task.assignedTo]++;
                        }
                    }
                });
                
                // Display each member with their pending tasks count
                Object.entries(memberTaskCounts).forEach(([memberId, count]) => {
                    const member = familyMembers[memberId];
                    statsHTML += `
                        <div class="member-stat" onclick="filterByMember('${memberId}')">
                            <div class="member-info">
                                <span class="member-icon">${member.icon}</span>
                                <span class="member-name">${member.name}</span>
                            </div>
                            <div class="member-count ${count === 0 ? 'zero' : ''}" style="color: ${member.color}">
                                ${count}
                            </div>
                        </div>
                    `;
                });
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">××™×Ÿ ×¢×“×™×™×Ÿ ×ž×©×™×ž×•×ª</p>';
            }
            
            statsHTML += '</div>'; // Close tasks-stat
            
            // Shopping stats content
            statsHTML += '<div id="shopping-stat" class="stat-content">';
            
            if (hasShopping) {
                const totalItems = allShopping.length;
                const purchasedItems = allShopping.filter(i => i.status === 'purchased').length;
                const pendingItems = totalItems - purchasedItems;
                
                statsHTML += `
                    <div class="shopping-stats">
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number pending">${pendingItems}</div>
                            <div class="shopping-stat-label">×¦×¨×™×š ×œ×§× ×•×ª</div>
                        </div>
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number purchased">${purchasedItems}</div>
                            <div class="shopping-stat-label">× ×§× ×•</div>
                        </div>
                    </div>
                `;
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">××™×Ÿ ×¢×“×™×™×Ÿ ×¤×¨×™×˜×™ ×§× ×™×™×”</p>';
            }
            
            statsHTML += '</div>'; // Close shopping-stat
            
            document.getElementById('statsContainer').innerHTML = statsHTML;
            
            // Update top performers (only shown to Hagai)
            updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping);
        }
        
        function switchStatTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.stat-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.stat-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }
        
        function updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping) {
            // Top performers (for Hagai only)
            const memberStats = {};
            Object.keys(familyMembers).forEach(memberId => {
                if (memberId !== 'everyone') {
                    memberStats[memberId] = {
                        tasksCompleted: 0,
                        itemsAdded: 0,
                        itemsPurchased: 0,
                        total: 0
                    };
                }
            });
            
            // Count completed tasks
            if (hasTasks) {
                allTasks.forEach(task => {
                    if (task.status === 'completed' && task.completedById && memberStats[task.completedById]) {
                        memberStats[task.completedById].tasksCompleted++;
                        memberStats[task.completedById].total++;
                    }
                });
            }
            
            // Count purchased items
            if (hasShopping) {
                allShopping.forEach(item => {
                    if (item.status === 'purchased' && item.purchasedById && memberStats[item.purchasedById]) {
                        memberStats[item.purchasedById].itemsPurchased++;
                        memberStats[item.purchasedById].total++;
                    }
                });
            }
            
            // Sort by total
            const topPerformers = Object.entries(memberStats)
                .map(([id, stats]) => ({ id, ...stats, ...familyMembers[id] }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 3);
            
            let performersHTML = '';
            const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
            
            topPerformers.forEach((performer, index) => {
                if (performer.total === 0 && index > 0) return;
                
                performersHTML += `
                    <div class="performer-item">
                        <div class="performer-rank">${medals[index]}</div>
                        <div class="performer-info">
                            <div class="performer-name">${performer.icon} ${performer.name}</div>
                            <div class="performer-points">${performer.total} ×¤×¢×•×œ×•×ª ×”×©×‘×•×¢</div>
                        </div>
                    </div>
                `;
            });
            
            if (!performersHTML) {
                performersHTML = '<div class="empty-state"><div class="empty-icon">ðŸ†</div><div class="empty-text">×¢×“×™×™×Ÿ ××™×Ÿ × ×ª×•× ×™× ×”×©×‘×•×¢</div></div>';
            }
            
            const topPerformersEl = document.getElementById('topPerformers');
            if (topPerformersEl) {
                topPerformersEl.innerHTML = performersHTML;
            }
        }
        
        // ==================== BACKUP SYSTEM (Hagai only) ====================
        
        async function setupAutoBackup() {
            if (!currentUser.canBackup) return;
            
            // Check if File System Access API is supported (Desktop only)
            if (!('showDirectoryPicker' in window)) {
                console.log('ðŸ“± × ×™×™×“: ×’×™×‘×•×™ ××•×˜×•×ž×˜×™ ×œ× ×–×ž×™×Ÿ - ×”×©×ª×ž×© ×‘×›×¤×ª×•×¨ ðŸ’¾ ×œ×’×™×‘×•×™ ×™×“× ×™');
                return;
            }
            
            console.log('âœ… ×ž×¢×¨×›×ª ×’×™×‘×•×™ ××•×˜×•×ž×˜×™ ×–×ž×™× ×” (Desktop)');
            
            // Check if this is first time
            const autoBackupEnabled = localStorage.getItem('autoBackupEnabled');
            
            if (autoBackupEnabled === null) {
                const confirmed = confirm('×”×™×™ ×—×’×™! ðŸ”\n\n×”×× ×œ×”×¤×¢×™×œ ×’×™×‘×•×™ ××•×˜×•×ž×˜×™?\n\n×”×ž×¢×¨×›×ª ×ª×©×ž×•×¨ ××ª ×›×œ ×”× ×ª×•× ×™× ×‘×ª×™×§×™×™×” ×©×ª×‘×—×¨ ×‘×›×œ ×›× ×™×¡×” ×•×™×¦×™××”.\n\nðŸ’» ×–×ž×™×Ÿ ×¨×§ ×‘×ž×—×©×‘!');
                
                if (confirmed) {
                    localStorage.setItem('autoBackupEnabled', 'true');
                    const success = await requestBackupDirectory();
                    if (success) {
                        await performBackup(true);
                    }
                } else {
                    localStorage.setItem('autoBackupEnabled', 'false');
                }
            } else if (autoBackupEnabled === 'true') {
                try {
                    const savedHandle = await loadDirectoryHandle();
                    
                    if (savedHandle) {
                        if (typeof savedHandle.queryPermission === 'function') {
                            const permission = await savedHandle.queryPermission({ mode: 'readwrite' });
                            
                            if (permission === 'granted') {
                                backupDirectoryHandle = savedHandle;
                                console.log('âœ… × ×ª×™×‘ ×’×™×‘×•×™ ×˜×¢×•×Ÿ ×ž×”×–×™×›×¨×•×Ÿ');
                                await performBackup(true);
                            } else if (typeof savedHandle.requestPermission === 'function') {
                                const newPermission = await savedHandle.requestPermission({ mode: 'readwrite' });
                                if (newPermission === 'granted') {
                                    backupDirectoryHandle = savedHandle;
                                    console.log('âœ… ×”×¨×©××ª ×’×™×‘×•×™ ×—×•×“×©×”');
                                    await performBackup(true);
                                } else {
                                    console.log('âš ï¸ ×”×¨×©××” × ×“×—×ª×” - ×’×™×‘×•×™ ××•×˜×•×ž×˜×™ ×œ× ×¤×¢×™×œ');
                                }
                            }
                        }
                    } else {
                        console.log('âš ï¸ ×œ× × ×ž×¦× × ×ª×™×‘ ×©×ž×•×¨ - ×ž×‘×§×© × ×ª×™×‘ ×—×“×©');
                        const success = await requestBackupDirectory();
                        if (success) {
                            await performBackup(true);
                        }
                    }
                } catch (err) {
                    console.log('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×™×‘ ×’×™×‘×•×™:', err);
                }
            }
            
            // Auto backup every 5 minutes
            setInterval(() => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            }, 5 * 60 * 1000);
            
            // Auto backup on page unload
            window.addEventListener('beforeunload', () => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            });
        }
        
        async function requestBackupDirectory() {
            try {
                backupDirectoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });
                
                await saveDirectoryHandle(backupDirectoryHandle);
                console.log('âœ… × ×ª×™×‘ ×’×™×‘×•×™ × ×©×ž×¨');
                return true;
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('×©×’×™××” ×‘×‘×—×™×¨×ª ×ª×™×§×™×™×”:', err);
                }
                return false;
            }
        }
        
        async function performBackup(silent = true) {
            if (!backupDirectoryHandle) {
                if (!silent) console.log('××™×Ÿ × ×ª×™×‘ ×’×™×‘×•×™');
                return false;
            }
            
            try {
                // Check permission silently - only if queryPermission is supported
                if (typeof backupDirectoryHandle.queryPermission === 'function') {
                    try {
                        const permission = await backupDirectoryHandle.queryPermission({ mode: 'readwrite' });
                        if (permission !== 'granted') {
                            // Permission lost - don't show any dialog, just skip silently
                            if (!silent) console.warn('Backup folder permission not granted, skipping backup');
                            return false;
                        }
                    } catch (permErr) {
                        // queryPermission might fail on some mobile browsers - continue anyway
                        console.log('âš ï¸ queryPermission failed, attempting backup anyway:', permErr.message);
                    }
                }
                
                const backupData = {
                    timestamp: new Date().toISOString(),
                    user: currentUser.name,
                    tasks: tasks,
                    shopping: shopping,
                    deletionHistory: deletionHistory,
                    version: '9.2'
                };
                
                // Daily backup - one file per day (overwrites previous)
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const todayFilename = `family-tasks-backup-${dateStr}.json`;
                
                // Get yesterday's date for cleanup
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayDateStr = yesterday.toISOString().split('T')[0];
                const yesterdayFilename = `family-tasks-backup-${yesterdayDateStr}.json`;
                
                try {
                    // Delete yesterday's backup if exists
                    const yesterdayHandle = await backupDirectoryHandle.getFileHandle(yesterdayFilename);
                    await backupDirectoryHandle.removeEntry(yesterdayFilename);
                    console.log(`ðŸ—‘ï¸ ×ž×—×§ ×’×™×‘×•×™ ×©×œ ××ª×ž×•×œ: ${yesterdayFilename}`);
                } catch (err) {
                    // File doesn't exist, that's ok
                }
                
                // Create/overwrite today's backup
                const fileHandle = await backupDirectoryHandle.getFileHandle(todayFilename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(backupData, null, 2));
                await writable.close();
                
                if (!silent) console.log('âœ… ×’×™×‘×•×™ ×‘×•×¦×¢ ×‘×”×¦×œ×—×”:', todayFilename);
                return true;
            } catch (err) {
                console.error('×©×’×™××” ×‘×’×™×‘×•×™:', err);
                return false;
            }
        }
        
        async function performManualBackup() {
            console.log('ðŸ”µ performManualBackup × ×§×¨×');
            console.log('ðŸ“± User Agent:', navigator.userAgent);
            
            // Force mobile backup on mobile devices - no permissions needed, just download
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            console.log('ðŸ“± ×–×•×”×” ×›× ×™×™×“:', isMobile);
            
            if (isMobile) {
                console.log('ðŸ“± ×ž×›×©×™×¨ × ×™×™×“ - ×”×•×¨×“×ª ×§×•×‘×¥ ×™×©×™×¨×”');
                performMobileBackup();
                return;
            }
            
            // Desktop only: use File System Access API
            if (!window.showDirectoryPicker) {
                console.log('ðŸ–¥ï¸ ×“×¤×“×¤×Ÿ ×œ× ×ª×•×ž×š - ×”×•×¨×“×ª ×§×•×‘×¥');
                performMobileBackup();
                return;
            }
            
            console.log('ðŸ’» ×ž×¦×‘ Desktop - ×ž×©×ª×ž×© ×‘-File System Access API');
            
            try {
                if (!backupDirectoryHandle) {
                    backupDirectoryHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });
                    await saveDirectoryHandle(backupDirectoryHandle);
                }
                
                const success = await performBackup(false);
                if (success) {
                    const taskCount = Object.keys(tasks).length;
                    const shoppingCount = Object.keys(shopping || {}).length;
                    alert(`âœ… ×”×’×™×‘×•×™ ×‘×•×¦×¢ ×‘×”×¦×œ×—×”!\n\nðŸ“‹ ${taskCount} ×ž×©×™×ž×•×ª\nðŸ›’ ${shoppingCount} ×¤×¨×™×˜×™ ×§× ×™×™×”`);
                } else {
                    alert('âŒ ×©×’×™××” ×‘×‘×™×¦×•×¢ ×’×™×‘×•×™ - × ×¡×” ×©×•×‘');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('×‘×™×˜×•×œ ×‘×—×™×¨×ª ×ª×™×§×™×™×”');
                    return;
                }
                console.error('Desktop backup error:', error);
                // Fallback to download
                performMobileBackup();
            }
        }
        
        function performMobileBackup() {
            console.log('ðŸ”„ ×ž×ª×—×™×œ ×’×™×‘×•×™ × ×™×™×“...');
            
            try {
                // Simple validation
                if (!currentUser || !currentUser.name) {
                    alert('âŒ ×× × ×”×ª×—×‘×¨ ×ª×—×™×œ×”');
                    return;
                }
                
                if (!tasks) {
                    alert('â³ ×˜×•×¢×Ÿ × ×ª×•× ×™×... × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×©× ×™×™×”');
                    return;
                }
                
                // Create backup object
                const backupData = {
                    timestamp: new Date().toISOString(),
                    user: currentUser.name,
                    tasks: tasks || {},
                    shopping: shopping || {},
                    deletionHistory: deletionHistory || [],
                    familyMembers: familyMembers || {},
                    version: '9.7'
                };
                
                // Convert to JSON
                const dataStr = JSON.stringify(backupData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                
                // Create filename with date and time
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                const filename = `LOBALI-backup-${dateStr}-${timeStr}.json`;
                
                // Create download link and trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                // Success message
                const taskCount = Object.keys(tasks).length;
                const shoppingCount = Object.keys(shopping || {}).length;
                
                console.log('âœ… ×’×™×‘×•×™ ×”×•×©×œ× ×‘×”×¦×œ×—×”:', filename);
                alert(`âœ… ×”×’×™×‘×•×™ ×”×•×¨×“ ×‘×”×¦×œ×—×”!\n\nðŸ“‹ ${taskCount} ×ž×©×™×ž×•×ª\nðŸ›’ ${shoppingCount} ×¤×¨×™×˜×™×\n\nðŸ“‚ ×§×•×‘×¥: ${filename}\nâœ”ï¸ ×‘×“×•×§ ×‘×ª×™×§×™×™×ª ×”×”×•×¨×“×•×ª`);
                
            } catch (error) {
                console.error('âŒ ×©×’×™××ª ×’×™×‘×•×™ × ×™×™×“:', error);
                alert('âŒ ×©×’×™××” ×‘×‘×™×¦×•×¢ ×’×™×‘×•×™:\n\n' + error.message + '\n\n× ×¡×” ×©×•×‘ ××• ×¤× ×” ×œ×ª×ž×™×›×”');
            }
        }
        
        async function performRestore() {
            try {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] }
                    }],
                    multiple: false
                });
                
                const file = await fileHandle.getFile();
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×©×—×–×¨ ×’×™×‘×•×™? ×¤×¢×•×œ×” ×–×• ×ª×“×¨×•×¡ ××ª ×”× ×ª×•× ×™× ×”× ×•×›×—×™×™×!')) {
                    return;
                }
                
                isSyncing = true;
                updateSyncStatus();
                
                await Promise.all([
                    data.tasks ? tasksRef.set(data.tasks) : Promise.resolve(),
                    data.shopping ? shoppingRef.set(data.shopping) : Promise.resolve(),
                    data.deletionHistory ? deletionHistoryRef.set(data.deletionHistory) : Promise.resolve()
                ]);
                
                alert('âœ… ×”×’×™×‘×•×™ ×©×•×—×–×¨ ×‘×”×¦×œ×—×”!');
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Restore error:', error);
                    alert('âŒ ×©×’×™××” ×‘×©×—×–×•×¨ ×’×™×‘×•×™');
                }
            } finally {
                isSyncing = false;
                updateSyncStatus();
            }
        }
        
        async function openBackupDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        
        async function saveDirectoryHandle(handle) {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.put(handle, 'backupDirectory');
                
                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        db.close();
                        resolve(true);
                    };
                    transaction.onerror = () => {
                        db.close();
                        reject(transaction.error);
                    };
                });
            } catch (err) {
                console.error('Error saving directory handle:', err);
                return false;
            }
        }
        
        async function loadDirectoryHandle() {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('backupDirectory');
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('Error loading directory handle:', err);
                return null;
            }
        }
        // ==================== VOICE INPUT ====================
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let voiceRecognition = null;
        let voiceInputMode = null; // 'task' or 'shopping'
        let voiceFinalText = '';
        let voiceInterimText = '';
        
        // Hide mic button if speech not supported
        if (!SpeechRecognition) {
            const fabMic = document.getElementById('fabMicBtn');
            if (fabMic) fabMic.style.display = 'none';
        }
        
        if (SpeechRecognition) {
            voiceRecognition = new SpeechRecognition();
            voiceRecognition.lang = 'he-IL';
            voiceRecognition.continuous = false;
            voiceRecognition.interimResults = true;
            
            voiceRecognition.onstart = () => {
                document.getElementById('voiceModalIcon').textContent = 'ðŸ”´';
                document.getElementById('voiceModalStatus').textContent = 'ðŸŽ¤ ×ž×§×©×™×‘... ×“×‘×¨ ×¢×›×©×™×•';
                document.getElementById('voiceModalStatus').classList.add('recording');
                document.getElementById('voiceModalActions').style.display = 'none';
                voiceFinalText = '';
                voiceInterimText = '';
            };
            
            voiceRecognition.onresult = (event) => {
                voiceInterimText = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        voiceFinalText += event.results[i][0].transcript + ' ';
                    } else {
                        voiceInterimText += event.results[i][0].transcript;
                    }
                }
                document.getElementById('voiceModalText').textContent = (voiceFinalText + voiceInterimText).trim();
            };
            
            voiceRecognition.onerror = (event) => {
                console.error('Voice error:', event.error);
                if (event.error === 'no-speech') {
                    document.getElementById('voiceModalStatus').textContent = 'ðŸ¤« ×œ× ×©×ž×¢×ª×™, × ×¡×” ×©×•×‘';
                    document.getElementById('voiceModalStatus').classList.remove('recording');
                    document.getElementById('voiceModalActions').style.display = 'flex';
                } else if (event.error === 'not-allowed') {
                    document.getElementById('voiceModalStatus').textContent = 'âš ï¸ ×× × ××©×¨ ×’×™×©×” ×œ×ž×™×§×¨×•×¤×•×Ÿ';
                    document.getElementById('voiceModalStatus').classList.remove('recording');
                }
            };
            
            voiceRecognition.onend = () => {
                const text = (voiceFinalText + voiceInterimText).trim();
                document.getElementById('voiceModalIcon').textContent = 'ðŸŽ™ï¸';
                document.getElementById('voiceModalStatus').classList.remove('recording');
                
                if (text) {
                    document.getElementById('voiceModalStatus').textContent = 'ðŸ”Š ×ž×§×¨×™×...';
                    document.getElementById('voiceModalActions').style.display = 'flex';
                    
                    // Read back the text using TTS
                    speakText(text, () => {
                        document.getElementById('voiceModalStatus').textContent = '×”×× ×”×˜×§×¡×˜ × ×›×•×Ÿ?';
                    });
                } else {
                    document.getElementById('voiceModalStatus').textContent = '×œ× ×–×•×”×” ×˜×§×¡×˜, × ×¡×” ×©×•×‘';
                    document.getElementById('voiceModalActions').style.display = 'flex';
                }
                
                // Reset mic button style
                document.getElementById('fabMicBtn').classList.remove('recording');
            };
        }
        
        function startVoiceInputSmart() {
            // Auto-detect mode based on active tab
            const shoppingTab = document.getElementById('shoppingTab');
            const tasksTab = document.getElementById('tasksTab');
            
            if (!shoppingTab.classList.contains('hidden')) {
                startVoiceInput('shopping');
            } else if (!tasksTab.classList.contains('hidden')) {
                startVoiceInput('task');
            } else {
                startVoiceInput('task'); // default
            }
        }
        
        function startVoiceInput(mode) {
            if (!voiceRecognition) {
                alert('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•×ž×š ×‘×”×§×œ×˜×” ×§×•×œ×™×ª. × ×¡×” Chrome.');
                return;
            }
            
            voiceInputMode = mode;
            voiceFinalText = '';
            voiceInterimText = '';
            
            // Open modal
            document.getElementById('voiceModal').classList.add('active');
            document.getElementById('voiceModalText').textContent = '';
            document.getElementById('voiceModalActions').style.display = 'none';
            
            // Set fab mic button style
            document.getElementById('fabMicBtn').classList.add('recording');
            
            // Start recognition
            try {
                voiceRecognition.start();
            } catch(e) {
                console.error('Voice start error:', e);
            }
        }
        
        function speakText(text, onDone) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'he-IL';
                utterance.rate = 0.9;
                
                // Try to find Hebrew voice
                const voices = speechSynthesis.getVoices();
                const hebrewVoice = voices.find(v => v.lang.startsWith('he'));
                if (hebrewVoice) utterance.voice = hebrewVoice;
                
                utterance.onend = () => { if (onDone) onDone(); };
                utterance.onerror = () => { if (onDone) onDone(); };
                
                speechSynthesis.speak(utterance);
            } else {
                if (onDone) onDone();
            }
        }
        
        function confirmVoiceInput() {
            const text = document.getElementById('voiceModalText').textContent.trim();
            speechSynthesis.cancel();
            
            if (!text) {
                cancelVoiceInput();
                return;
            }
            
            if (voiceInputMode === 'task') {
                // Try to auto-detect assignee from text
                let taskText = text;
                let detectedAssignee = null;
                
                Object.values(familyMembers).forEach(m => {
                    if (text.includes(m.name)) {
                        detectedAssignee = m;
                        taskText = text.replace(m.name, '').replace(/\s+/g, ' ').trim();
                    }
                });
                
                if (detectedAssignee) {
                    // Add task to specific person
                    const newTask = {
                        id: 'task_' + Date.now(),
                        title: taskText || text,
                        description: '',
                        assignedTo: detectedAssignee.id,
                        assignedToName: detectedAssignee.name,
                        assignedToIcon: detectedAssignee.icon,
                        assignedToColor: detectedAssignee.color,
                        priority: 'medium',
                        status: 'pending',
                        createdAt: Date.now(),
                        createdBy: currentUser.name,
                        createdById: currentUser.id,
                        isPinned: false,
                        isPersonal: detectedAssignee.id === currentUser.id,
                        isGeneral: false,
                        isRecurring: false,
                        dueDate: null
                    };
                    
                    tasksRef.child(newTask.id).set(newTask).then(() => {
                        showToast('âœ… ×ž×©×™×ž×” × ×•×¡×¤×” ×œ-' + detectedAssignee.name + ': ' + (taskText || text));
                    });
                } else {
                    // No name detected - create general task
                    const newTask = {
                        id: 'task_' + Date.now(),
                        title: taskText,
                        description: '',
                        assignedTo: 'general',
                        assignedToName: '×›×•×œ×',
                        assignedToIcon: 'ðŸ‘¥',
                        assignedToColor: '#9C27B0',
                        priority: 'medium',
                        status: 'pending',
                        createdAt: Date.now(),
                        createdBy: currentUser.name,
                        createdById: currentUser.id,
                        isPinned: false,
                        isPersonal: false,
                        isGeneral: true,
                        isRecurring: false,
                        dueDate: null
                    };
                    
                    tasksRef.child(newTask.id).set(newTask).then(() => {
                        showToast('âœ… ×ž×©×™×ž×” ×›×œ×œ×™×ª × ×•×¡×¤×”: ' + taskText);
                    });
                }
                
            } else if (voiceInputMode === 'shopping') {
                // Add shopping item directly to Firebase
                const itemId = 'item_' + Date.now();
                const item = {
                    id: itemId,
                    name: text,
                    addedBy: currentUser.name,
                    addedById: currentUser.id,
                    addedByIcon: currentUser.icon,
                    addedByColor: currentUser.color,
                    addedAt: Date.now(),
                    status: 'pending',
                    purchasedAt: null,
                    purchasedBy: null,
                    purchasedById: null,
                    isPinned: false
                };
                
                shoppingRef.child(itemId).set(item).then(() => {
                    showToast('ðŸ›’ × ×•×¡×£: ' + text);
                });
            }
            
            closeVoiceModal();
        }
        
        function autoDetectAssignee(text) {
            const textLower = text.trim();
            
            // Check if any family member name is mentioned
            const nameMap = {};
            Object.values(familyMembers).forEach(m => {
                nameMap[m.name] = m.id;
            });
            
            for (const [name, id] of Object.entries(nameMap)) {
                if (textLower.includes(name)) {
                    // Select this assignee
                    quickSelectedAssignee = id;
                    const grid = document.getElementById('quickAssigneeGrid');
                    grid.querySelectorAll('.assignee-btn').forEach(btn => {
                        btn.classList.toggle('selected', btn.dataset.id === id);
                    });
                    
                    // Remove the name from the task text
                    const cleanText = textLower.replace(name, '').replace(/\s+/g, ' ').trim();
                    if (cleanText) {
                        document.getElementById('quickTaskInput').value = cleanText;
                    }
                    
                    showToast(`ðŸ‘¤ ×©×•×™×š ×œ-${name}`);
                    return;
                }
            }
        }
        
        function retryVoiceInput() {
            speechSynthesis.cancel();
            document.getElementById('voiceModalText').textContent = '';
            voiceFinalText = '';
            voiceInterimText = '';
            
            try {
                voiceRecognition.start();
            } catch(e) {
                console.error('Voice retry error:', e);
            }
        }
        
        function cancelVoiceInput() {
            speechSynthesis.cancel();
            try { voiceRecognition.stop(); } catch(e) {}
            closeVoiceModal();
        }
        
        function closeVoiceModal() {
            document.getElementById('voiceModal').classList.remove('active');
            document.getElementById('fabMicBtn').classList.remove('recording');
        }
        
        // Load voices (needed for some browsers)
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }
        
    </script>
</body>
</html>