<!DOCTYPE html>
<!--
    ××©×™××•×ª ××©×¤×—×ª×™×•×ª - ××©×¤×—×ª ×—×’×™ ×•×œ×™××ª
    
    ×”×™×¡×˜×•×¨×™×™×ª ×’×¨×¡××•×ª:
    v5.3 (09/02/2026) - ğŸ‘¥ User Management: × ×™×”×•×œ ××©×ª××©×™× ××œ× - ×”×•×¡×£, ×¢×¨×•×š, ××—×§ ××©×ª××©×™×!
    v5.2 (09/02/2026) - âš¡ Quick Add Task: ×§××¨×“ ×”×•×¡×¤×ª ××©×™××” ××”×™×¨×” ×—×–×¨ ×œ××¡×š! ×‘×—×¨ ××“× ×•×”×•×¡×£ ×‘×§×œ×™×§
    v5.1 (09/02/2026) - ğŸ“… Google Calendar Integration: ×›×¤×ª×•×¨ "×”×•×¡×£ ×œ×™×•××Ÿ" ×œ××©×™××•×ª ×¢× ×ª××¨×™×š!
    v5.0 (09/02/2026) - ğŸŒŸ Bottom Nav Revolution: 3 ××¡×›×™× × ×¤×¨×“×™× (ğŸ“‹ğŸ›’ğŸ“Š), Swipe ×’× ×œ××©×™××•×ª, ×¡×˜×˜×™×¡×˜×™×§×” × ×¤×¨×“×ª
    v4.2 (09/02/2026) - ğŸ‘† Swipe Perfect: â† × ×§× ×”, â†’ ×‘×™×˜×•×œ (×‘×œ×™ ××™×©×•×¨!), â†‘ ×”×¢×œ××”, â†“ ×”×•×¨×“×”
    v4.1 (09/02/2026) - ğŸ¨ Professional Design: ×¢×™×¦×•×‘ × ×§×™, Swipe Actions (â†â†’â†‘), × ×™×”×•×œ ××©×ª××©×™×, ×¨×©×•××” × ×§× ×ª×” ×¢× ×§×•
    v4.0 (09/02/2026) - ğŸš€ Mobile First Revolution: Header ×“×§ (50px), FAB ×¦×£, "×”××©×™××•×ª ×©×œ×™" ×‘×¨×™×¨×ª ××—×“×œ, ×¢×™×¦×•×‘ ××•×“×¨× ×™
    v3.4 (09/02/2026) - ×¢×™×¦×•×‘ ×¡×•×¤×¨ ×§×•××¤×§×˜×™: ×©×•×¨×” ××—×ª ×“×§×” (×’× ××©×™××•×ª ×•×’× ×§× ×™×•×ª, ×›×•×œ×œ ××•×‘×™×™×œ)
    v3.3 (09/02/2026) - ×¢×™×¦×•×‘ ×§×•××¤×§×˜×™: ×©×•×¨×•×ª ×“×§×•×ª ×œ×¤×¨×™×˜×™ ×§× ×™×™×” (×©×•×¨×” ××—×ª ×¢× ×›×œ ×”××™×“×¢)
    v3.2 (09/02/2026) - ×ª×™×§×•×Ÿ ×‘××’: ×”×¡×ª×¨×ª ×›×¤×ª×•×¨×™ ××—×™×§×•×ª/×’×™×‘×•×™/×©×—×–×•×¨ ××›×•×œ× ×—×•×¥ ××—×’×™
    v3.1 (09/02/2026) - ×¡×™×¡××” ×œ×—×’×™ (cochag12), ×’×™×‘×•×™ ××•×˜×•××˜×™ ×¨×§ ×‘××—×©×‘
    v3.0 (08/02/2026) - ×ª×™×§×•×Ÿ: ×× ×”×œ×™× ×¨×•××™× ×›×œ ×”××©×™××•×ª, ××©×™××•×ª ××—×–×•×¨×™×•×ª (×™×•××™/×©×‘×•×¢×™)
    v2.7 (08/02/2026) - ×›×¤×ª×•×¨×™ ××—×™×§×•×ª/×’×™×‘×•×™/×©×—×–×•×¨ ×¨×§ ×œ×—×’×™ (×œ× ×œ×œ×™××ª)
    v2.6 (08/02/2026) - ×§×œ×™×§ ×¢×œ ××©×ª××© ×‘×¡×˜×˜×™×¡×˜×™×§×•×ª ××¢×‘×¨ ×œ××©×™××•×ª ×©×œ×•, ×—×™×¤×•×© ×’× ×œ×¤×™ ×©×
    v2.5 (08/02/2026) - ×—×™×¤×•×© ××©×™××•×ª ×œ×¤×™ ×©× ××• ×ª×™××•×¨
    v2.4 (08/02/2026) - ×ª×™×§×•×Ÿ ×‘××’: ××©×™××•×ª ×¢×¦×××™×•×ª ×œ× × ×¨××•×ª ×œ××™ ×©×œ× ×××•×¨
    v2.3 (08/02/2026) - ×¡×˜×˜×™×¡×˜×™×§×•×ª ××¤×•×¨×˜×•×ª ×¨×§ ×œ×× ×”×œ×™×, ×œ×©×•× ×™×•×ª ××©×™××•×ª/×§× ×™×•×ª
    v2.2 (08/02/2026) - ××¡×¤×•×¨ ×‘×˜××‘×™×, ×”×¡×¨×ª ×¤×™×œ×˜×¨ '×”×›×œ', ×‘×¨×™×¨×ª ××—×“×œ ×œ×××ª×™× ×•×ª
    v2.1 (08/02/2026) - ×¨×©×™××” ××¡×•×“×¨×ª ×¢× ××¡×¤×•×¨, ×—×™×¤×•×© ××•×¦×¨×™×, ×›×•×›×‘×™ ×©×‘×•×¢ ×¨×§ ×œ×—×’×™
    v2.0 (08/02/2026) - Firebase Realtime Database - ×¡× ×›×¨×•×Ÿ ×‘×–××Ÿ ×××ª
    v1.6 (×§×•×“×)      - ×’×¨×¡×” ××§×•×¨×™×ª ×¢× localStorage
-->
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××©×™××•×ª ××©×¤×—×ª×™×•×ª - ××©×¤×—×ª ×—×’×™ ×•×œ×™××ª v5.3 ğŸŒŸ</title>
    
    <!-- Version Info -->
    <meta name="version" content="5.3">
    <meta name="last-updated" content="2026-02-09">
    <meta name="sync" content="firebase-realtime">
    <meta name="changelog" content="User Management: × ×™×”×•×œ ××©×ª××©×™× ××œ× - ×”×•×¡×£, ×¢×¨×•×š, ××—×§! ğŸ‘¥">
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;600;700;800&family=Varela+Round&family=Alef:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --color-liat: #E91E63;
            --color-hagai: #2196F3;
            --color-maya: #00BCD4;
            --color-ariel: #4CAF50;
            --color-ann: #FF9800;
            
            --bg-main: #F5F5F5;
            --bg-card: #FFFFFF;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border-color: #E0E0E0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 2px 6px rgba(0,0,0,0.15);
            --shadow-lg: 0 4px 12px rgba(0,0,0,0.18);
            
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rubik', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 0;
            position: relative;
            overflow-x: hidden;
        }
            z-index: 0;
            animation: float 20s ease-in-out infinite;
        }
        
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            to {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding-bottom: 100px;
            position: relative;
            z-index: 1;
        }
        
        /* Header */
        header {
            background: white;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .header-compact {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .user-info-compact {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .user-avatar-small {
            font-size: 1.8rem;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .user-details-compact {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .user-name-small {
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .user-role-small {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .header-actions-compact {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sync-compact {
            display: flex;
            align-items: center;
            padding: 4px;
        }
        
        .btn-icon-only {
            padding: 6px 10px;
            border: none;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
        }
        
        .btn-icon-only:hover {
            background: rgba(0,0,0,0.1);
            transform: scale(1.05);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .header-user {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .user-avatar {
            font-size: 3rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        .user-info h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .user-info p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        #syncStatus {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(0,0,0,0.03);
            border-radius: var(--radius-sm);
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--radius-sm);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95rem;
            font-family: 'Rubik', sans-serif;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #E91E63, #FF6B9D);
            color: white;
            box-shadow: 0 4px 12px rgba(233, 30, 99, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.4);
        }
        
        .btn-secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }
        
        .btn-secondary:hover {
            background: rgba(0,0,0,0.08);
        }
        
        .btn-logout {
            background: transparent;
            color: var(--text-secondary);
            border: 2px solid currentColor;
        }
        
        .btn-logout:hover {
            background: var(--text-secondary);
            color: white;
        }
        
        /* FAB - Floating Action Button */
        .fab {
            position: fixed;
            bottom: 24px;
            left: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #2196F3;
            color: white;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            background: #1976D2;
        }
        
        .fab:active {
            transform: scale(0.95);
        }
        
        /* Tabs */
        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 8px 0 calc(8px + env(safe-area-inset-bottom));
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            border: none;
            background: none;
            color: var(--text-secondary);
        }
        
        .nav-item:active {
            transform: scale(0.95);
        }
        
        .nav-item.active {
            color: #2196F3;
        }
        
        .nav-icon {
            font-size: 1.5rem;
            transition: transform 0.2s;
        }
        
        .nav-item.active .nav-icon {
            transform: scale(1.1);
        }
        
        .nav-label {
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .nav-badge {
            position: absolute;
            top: 4px;
            right: 20%;
            background: #E91E63;
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }
        
        /* Main Layout */
        .main-layout {
            padding-bottom: 80px;
        }
        
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        /* Cards */
        .card {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 30px;
            box-shadow: var(--shadow-md);
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Filters */
        .filters {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 10px 18px;
            background: rgba(0,0,0,0.04);
            border: 2px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.9rem;
            font-family: 'Rubik', sans-serif;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-btn:hover {
            background: rgba(0,0,0,0.06);
        }
        
        .filter-btn.active {
            background: linear-gradient(135deg, #00BCD4, #00E5FF);
            color: white;
            border-color: #00BCD4;
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.3);
        }
        
        .filter-count {
            background: rgba(255,255,255,0.9);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 700;
        }
        
        .filter-btn.active .filter-count {
            background: rgba(255,255,255,0.95);
            color: #00BCD4;
        }
        
        /* Task/Shopping Item */
        .item {
            background: white;
            border-radius: var(--radius-sm);
            padding: 12px 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            touch-action: pan-y;
            user-select: none;
        }
        
        .item:active {
            box-shadow: var(--shadow-md);
        }
        
        .item.swiping {
            transition: none;
        }
        
        .item.swipe-left {
            background: #E8F5E9;
        }
        
        .item.swipe-right {
            background: #FFF3E0;
        }
        
        .item.swipe-up {
            background: #E3F2FD;
        }
        
        .item.swipe-down {
            background: #FFF9C4;
        }
        
        .item.pinned {
            border-left: 4px solid #E91E63;
            background: #FFF0F5;
        }
        
        .item.completed {
            opacity: 0.6;
            background: #F5F5F5;
        }
        
        .item.completed .item-content {
            text-decoration: line-through;
            color: var(--text-secondary);
        }
        
        .item.purchased {
            opacity: 0.5;
            background: #FAFAFA;
        }
        
        .item.purchased .item-content {
            text-decoration: line-through;
            color: #9E9E9E;
        }
        
        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        .swipe-indicator.left {
            right: 20px;
        }
        
        .swipe-indicator.right {
            left: 20px;
        }
        
        .swipe-indicator.up {
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .swipe-indicator.down {
            left: 50%;
            top: auto;
            bottom: 50%;
            transform: translate(-50%, 50%);
        }
        
        .swipe-indicator.visible {
            opacity: 1;
        }
        
        .item-number {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-secondary);
            min-width: 25px;
            text-align: center;
        }
        
        .item-content {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 0;
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.4;
        }
        
        .item-header {
            flex: 1;
            min-width: 0;
        }
        
        .item-title {
            font-size: 1.05rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .item-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
        }
        
        .badge-priority-high {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .badge-priority-medium {
            background: #FFF3E0;
            color: #E65100;
        }
        
        .badge-priority-low {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .badge-pinned {
            background: linear-gradient(135deg, #E91E63, #9C27B0);
            color: white;
        }
        
        .badge-personal {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .item-description {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .item-meta {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.85rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--text-secondary);
        }
        
        .user-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        
        .item-actions {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }
        
        .btn-icon {
            padding: 5px 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.7rem;
            font-family: 'Rubik', sans-serif;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            position: relative;
            white-space: nowrap;
        }
        
        .btn-icon:hover {
            transform: translateY(-2px);
        }
        
        .btn-complete {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .btn-delete {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .btn-pin {
            background: #FCE4EC;
            color: #C2185B;
        }
        
        .btn-notes {
            background: #E3F2FD;
            color: #1565C0;
        }
        
        .btn-calendar {
            background: #FFF9C4;
            color: #F57C00;
        }
        
        .btn-calendar:hover {
            background: #FFF59D;
            box-shadow: 0 2px 8px rgba(245, 124, 0, 0.3);
        }
        
        .btn-read {
            background: #F3E5F5;
            color: #7B1FA2;
        }
        
        .btn-read.reading {
            animation: reading-pulse 1s infinite;
        }
        
        @keyframes reading-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .note-badge {
            position: absolute;
            top: -6px;
            left: -6px;
            background: #C62828;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 700;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: #E91E63;
            box-shadow: 0 0 0 3px rgba(233, 30, 99, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        
        .form-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        /* Assignee Selection */
        .assignee-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }
        
        .assignee-btn {
            padding: 15px;
            border: 3px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-family: 'Rubik', sans-serif;
        }
        
        .assignee-btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-sm);
        }
        
        .assignee-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .assignee-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .assignee-name {
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        /* Priority Selection */
        .priority-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }
        
        .priority-btn {
            padding: 15px;
            border: 3px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: rgba(0,0,0,0.03);
            font-weight: 600;
            font-family: 'Rubik', sans-serif;
        }
        
        .priority-btn:hover {
            transform: translateY(-3px);
        }
        
        .priority-btn.selected {
            border-color: currentColor;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 35px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
            animation: modalSlide 0.3s ease;
        }
        
        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .modal-title {
            font-size: 1.6rem;
            font-weight: 700;
        }
        
        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(0,0,0,0.05);
            cursor: pointer;
            font-size: 1.3rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: rgba(0,0,0,0.1);
            transform: rotate(90deg);
        }
        
        /* Statistics */
        .stat-card {
            background: linear-gradient(135deg, #FFF 0%, #F8F8F8 100%);
            border-radius: var(--radius-md);
            padding: 25px;
            margin-bottom: 20px;
            border-right: 5px solid;
        }
        
        .stat-card.tasks {
            border-right-color: #E91E63;
        }
        
        .stat-card.shopping {
            border-right-color: #FF9800;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-name {
            font-weight: 600;
        }
        
        .stat-count {
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        /* Statistics Tabs */
        .stat-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
        }
        
        .stat-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-secondary);
            transition: all 0.3s;
            font-family: 'Rubik', sans-serif;
        }
        
        .stat-tab:hover {
            color: var(--text-primary);
        }
        
        .stat-tab.active {
            color: #E91E63;
            border-bottom-color: #E91E63;
        }
        
        .stat-content {
            display: none;
        }
        
        .stat-content.active {
            display: block;
        }
        
        .member-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #F9FAFB;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .member-stat:hover {
            background: #E5E7EB;
            transform: translateX(-3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .member-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .member-icon {
            font-size: 1.5rem;
        }
        
        .member-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .member-count {
            font-size: 1.3rem;
            font-weight: 700;
            padding: 5px 12px;
            background: white;
            border-radius: 10px;
        }
        
        .member-count.zero {
            opacity: 0.5;
            color: var(--text-secondary);
        }
        
        .shopping-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .shopping-stat-box {
            background: #F9FAFB;
            padding: 20px;
            border-radius: var(--radius-sm);
            text-align: center;
        }
        
        .shopping-stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 8px;
        }
        
        .shopping-stat-number.pending {
            color: #2196F3;
        }
        
        .shopping-stat-number.purchased {
            color: #4CAF50;
        }
        
        .shopping-stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        /* Top Performers */
        .performer-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #FFF 0%, #FAFAFA 100%);
            border-radius: var(--radius-sm);
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        
        .performer-item:hover {
            transform: translateX(-5px);
            box-shadow: var(--shadow-sm);
        }
        
        .performer-rank {
            font-size: 1.8rem;
            width: 50px;
            text-align: center;
        }
        
        .performer-info {
            flex: 1;
        }
        
        .performer-name {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }
        
        .performer-points {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        /* Notes */
        .notes-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .note-item {
            background: #F8F8F8;
            padding: 18px;
            border-radius: var(--radius-sm);
            margin-bottom: 15px;
            border-right: 4px solid #E0E0E0;
        }
        
        .note-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .note-author {
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .note-text {
            line-height: 1.6;
        }
        
        /* Deletion History */
        .history-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .history-table th,
        .history-table td {
            padding: 15px;
            text-align: right;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .history-table th {
            background: rgba(0,0,0,0.03);
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .history-table tr:hover {
            background: rgba(0,0,0,0.02);
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .empty-icon {
            font-size: 4rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .empty-text {
            font-size: 1.1rem;
        }
        
        /* Quick Add */
        .quick-add {
            display: flex;
            gap: 12px;
            margin-bottom: 25px;
        }
        
        .quick-add input {
            flex: 1;
        }
        
        /* Search Box */
        .search-box {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 18px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: var(--radius-sm);
            font-size: 1rem;
            font-family: 'Rubik', sans-serif;
            transition: all 0.3s;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 3px rgba(0, 188, 212, 0.1);
        }
        
        .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }
        
        /* Hidden */
        .hidden {
            display: none !important;
        }
        
        /* Login Screen */
        .login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        .login-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 15px;
            text-align: center;
            background: linear-gradient(135deg, #E91E63, #FF9800);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .login-subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }
        
        .login-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            max-width: 900px;
            width: 100%;
        }
        
        .login-card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 35px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: var(--shadow-md);
            border: 3px solid transparent;
        }
        
        .login-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-lg);
        }
        
        .login-icon {
            font-size: 4rem;
            margin-bottom: 15px;
        }
        
        .login-name {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .login-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .login-badge.pending {
            background: #FFEBEE;
            color: #C62828;
        }
        
        .login-badge.complete {
            background: #E8F5E9;
            color: #2E7D32;
        }
        
        .user-management {
            margin-top: 30px;
            text-align: center;
        }
        
        .btn-manage {
            padding: 12px 24px;
            background: white;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Rubik', sans-serif;
            color: var(--text-primary);
        }
        
        .btn-manage:hover {
            background: #F5F5F5;
            border-color: #2196F3;
            color: #2196F3;
        }
        
        /* User List in Modal */
        .user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--bg-light);
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }
        
        .user-item-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .user-item-icon {
            font-size: 1.8rem;
        }
        
        .user-item-details {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .user-item-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .user-item-role {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .user-item-actions {
            display: flex;
            gap: 8px;
        }
        
        .user-item .btn-icon {
            padding: 6px 10px;
            font-size: 0.75rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-right {
                width: 100%;
                justify-content: space-between;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .assignee-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .item {
                flex-wrap: nowrap;
                padding: 6px 10px;
                font-size: 0.8rem;
            }
            
            .item-content {
                font-size: 0.8rem;
                line-height: 1.3;
            }
            
            .item-actions {
                flex-wrap: nowrap;
                gap: 4px;
            }
            
            .btn-icon {
                font-size: 0.65rem;
                padding: 4px 6px;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.03);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <h1 class="login-title">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ××©×™××•×ª ××©×¤×—×ª×™×•×ª</h1>
        <p class="login-subtitle">×‘×—×¨×• ××ª ×—×‘×¨ ×”××©×¤×—×”</p>
        <div class="login-grid" id="loginGrid"></div>
        
        <!-- User Management -->
        <div class="user-management">
            <button class="btn-manage" onclick="openUserManagementModal()">
                ğŸ‘¥ × ×™×”×•×œ ××©×ª××©×™×
            </button>
        </div>
    </div>

    <!-- User Management Modal -->
    <div id="userManagementModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ğŸ‘¥ × ×™×”×•×œ ××©×ª××©×™×</h3>
                <button class="modal-close" onclick="closeUserManagementModal()">âœ•</button>
            </div>
            
            <div class="modal-body">
                <!-- Current Users -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ××©×ª××©×™× ×§×™×™××™×:</h4>
                <div id="currentUsersList" style="margin-bottom: 25px;"></div>
                
                <!-- Add New User -->
                <h4 style="margin-bottom: 15px; color: var(--text-primary);">â• ×”×•×¡×£ ××©×ª××© ×—×“×©:</h4>
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <input type="text" id="newUserName" class="form-input" placeholder="×©× ×”××©×ª××©...">
                    <input type="text" id="newUserIcon" class="form-input" placeholder="××™××•×’'×™ (×œ×“×•×’××”: ğŸ‘¶)" maxlength="2">
                    <select id="newUserRole" class="form-input">
                        <option value="child">×™×œ×“/×”</option>
                        <option value="admin">×× ×”×œ/×ª</option>
                    </select>
                    <button class="btn btn-primary" onclick="addNewUser()">â• ×”×•×¡×£ ××©×ª××©</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="container hidden">
        <!-- Header -->
        <header>
            <div class="header-compact">
                <div class="user-info-compact">
                    <span class="user-avatar-small" id="userAvatar">ğŸ‘¨</span>
                    <div class="user-details-compact">
                        <span class="user-name-small" id="userName">××©×ª××©</span>
                        <span class="user-role-small" id="userRole">×ª×¤×§×™×“</span>
                    </div>
                </div>
                
                <div class="header-actions-compact">
                    <div id="syncStatus" class="sync-compact">
                        <span class="sync-dot" style="background: #FFA500;"></span>
                    </div>
                    
                    <button class="btn-icon-only hidden" id="btnDeletionHistory" onclick="openDeletionHistoryModal()" title="××—×™×§×•×ª">
                        ğŸ—‘ï¸
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnBackup" onclick="performManualBackup()" title="×’×™×‘×•×™">
                        ğŸ’¾
                    </button>
                    
                    <button class="btn-icon-only hidden" id="btnRestore" onclick="performRestore()" title="×©×—×–×•×¨">
                        ğŸ“¥
                    </button>
                    
                    <button class="btn-icon-only btn-logout" onclick="logout()" title="×™×¦×™××”">
                        ğŸšª
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Main Content -->
            <div class="main-content">
                <!-- Tasks Tab -->
                <div id="tasksTab" class="tab-content hidden">
                    <!-- Quick Add Task Card -->
                    <div class="card">
                        <h3 class="card-title">â• ×”×•×¡×£ ××©×™××” ××”×¨</h3>
                        <input type="text" class="form-input" id="quickTaskInput" placeholder="×©× ×”××©×™××”..." style="margin-bottom: 15px;" onkeypress="if(event.key === 'Enter') addQuickTask()">
                        
                        <div class="assignee-grid" id="quickAssigneeGrid"></div>
                        
                        <button class="btn btn-primary" onclick="addQuickTask()" style="width: 100%; margin-top: 15px;">
                            â• ×”×•×¡×£ ××©×™××”
                        </button>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="tasksSearchInput" placeholder="ğŸ” ×—×™×¤×•×© ××©×™××”..." oninput="filterTasksBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterTasks('pending', event)">
                            ×××ª×™× ×•×ª
                            <span class="filter-count" id="pendingTasksCount">0</span>
                        </button>
                        <button class="filter-btn" onclick="filterTasks('completed', event)">
                            ×”×•×©×œ××•
                        </button>
                        <button class="filter-btn" onclick="filterTasks('personal', event)">
                            ××©×™××•×ª ×¢×¦×××™×•×ª
                            <span class="filter-count" id="personalTasksCount">0</span>
                        </button>
                        <button class="filter-btn" id="myTasksFilter" onclick="filterTasks('my-tasks', event)">
                            ×”××©×™××•×ª ×©×œ×™
                            <span class="filter-count" id="myTasksCount">0</span>
                        </button>
                    </div>

                    <!-- Tasks List -->
                    <div id="tasksList"></div>
                </div>

                <!-- Shopping Tab -->
                <div id="shoppingTab" class="tab-content">
                    <div class="card">
                        <h3 class="card-title">â• ×”×•×¡×¤×ª ×¤×¨×™×˜</h3>
                        <form class="quick-add" onsubmit="quickAddItem(event)">
                            <input type="text" class="form-input" id="quickItemInput" placeholder="×©× ×”×¤×¨×™×˜..." required>
                            <button type="submit" class="btn btn-primary">â• ×”×•×¡×£</button>
                        </form>
                    </div>
                    
                    <!-- Search Box -->
                    <div class="search-box">
                        <input type="text" class="search-input" id="shoppingSearchInput" placeholder="ğŸ” ×—×™×¤×•×© ××•×¦×¨..." oninput="filterShoppingBySearch()">
                    </div>

                    <!-- Filters -->
                    <div class="filters">
                        <button class="filter-btn active" onclick="filterShopping('pending', event)">
                            ×¦×¨×™×š ×œ×§× ×•×ª
                        </button>
                        <button class="filter-btn" onclick="filterShopping('purchased', event)">
                            × ×§× ×•
                        </button>
                    </div>

                    <!-- Shopping List -->
                    <div id="shoppingList"></div>
                </div>
                
                <!-- Stats Screen -->
                <div id="statsScreen" class="tab-content hidden">
                    <div class="card">
                        <h3 class="card-title">ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª</h3>
                        <div id="statsContainer"></div>
                    </div>

                    <div class="card" id="topPerformersCard">
                        <h3 class="card-title">ğŸ† ×›×•×›×‘×™ ×”×©×‘×•×¢</h3>
                        <div id="topPerformers"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- FAB - Floating Action Button -->
        <button class="fab" onclick="openFABModal()" title="×”×•×¡×£ ×¤×¨×™×˜ ×—×“×©">
            â•
        </button>
        
        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <button class="nav-item active" onclick="switchScreen('shopping')" id="navShopping">
                <span class="nav-badge" id="navShoppingBadge">0</span>
                <div class="nav-icon">ğŸ›’</div>
                <div class="nav-label">×§× ×™×•×ª</div>
            </button>
            <button class="nav-item" onclick="switchScreen('tasks')" id="navTasks">
                <span class="nav-badge" id="navTasksBadge">0</span>
                <div class="nav-icon">ğŸ“‹</div>
                <div class="nav-label">××©×™××•×ª</div>
            </button>
            <button class="nav-item" onclick="switchScreen('stats')" id="navStats">
                <div class="nav-icon">ğŸ“Š</div>
                <div class="nav-label">×¡×˜×˜×™×¡×˜×™×§×”</div>
            </button>
        </div>
    </div>

    <!-- Add Task Modal -->
    <div id="addTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">â• ××©×™××” ×—×“×©×”</h3>
                <button class="modal-close" onclick="closeAddTaskModal()">âœ•</button>
            </div>
            
            <form id="addTaskForm" onsubmit="submitTask(event)">
                <div class="form-group">
                    <label class="form-label">×©× ×”××©×™××” *</label>
                    <input type="text" class="form-input" id="taskTitle" required>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×ª×™××•×¨</label>
                    <textarea class="form-textarea" id="taskDescription"></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×”×§×¦××” ×œ××©×ª××© *</label>
                    <div class="assignee-grid" id="assigneeGrid"></div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">×ª××¨×™×š ×™×¢×“</label>
                    <input type="date" class="form-input" id="taskDueDate">
                </div>
                
                <div class="form-group">
                    <label class="form-label">×¢×“×™×¤×•×ª</label>
                    <div class="priority-grid">
                        <button type="button" class="priority-btn" style="background: #FFEBEE; color: #C62828;" onclick="selectPriority('high', event)">
                            ğŸ”´ ×’×‘×•×”×”
                        </button>
                        <button type="button" class="priority-btn selected" style="background: #FFF3E0; color: #E65100;" onclick="selectPriority('medium', event)">
                            ğŸŸ¡ ×¨×’×™×œ×”
                        </button>
                        <button type="button" class="priority-btn" style="background: #E8F5E9; color: #2E7D32;" onclick="selectPriority('low', event)">
                            ğŸŸ¢ × ××•×›×”
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsPersonal">
                        <span>ğŸ”’ ××©×™××” ×¢×¦×××™×ª (×¨×§ ×”××©×ª××© ×©×”×•×§×¦×ª×” ×œ×• ×™×¨××” ××•×ª×”)</span>
                    </label>
                </div>
                
                <div class="form-group" id="recurringGroup" style="display: none;">
                    <label class="form-label">ğŸ”„ ××©×™××” ××—×–×•×¨×™×ª</label>
                    <label class="form-checkbox">
                        <input type="checkbox" id="taskIsRecurring" onchange="toggleRecurringOptions()">
                        <span>××©×™××” ×—×•×–×¨×ª (××ª××¤×¡×ª ××•×˜×•××˜×™×ª ×œ××—×¨ ×”×©×œ××”)</span>
                    </label>
                    <div id="recurringOptions" style="display: none; margin-top: 15px;">
                        <select class="form-select" id="recurringType">
                            <option value="daily">×™×•××™×ª</option>
                            <option value="weekly">×©×‘×•×¢×™×ª</option>
                        </select>
                    </div>
                </div>
                
                <button type="submit" class="btn btn-primary" style="width: 100%;">
                    â• ×”×•×¡×£ ××©×™××”
                </button>
            </form>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">ğŸ’¬ ×”×¢×¨×•×ª ×œ××©×™××”</h3>
                <button class="modal-close" onclick="closeNotesModal()">âœ•</button>
            </div>
            
            <div class="notes-list" id="notesList"></div>
            
            <div id="addNoteSection">
                <div class="form-group">
                    <label class="form-label">×”×•×¡×£ ×”×¢×¨×”</label>
                    <textarea class="form-textarea" id="newNoteText" placeholder="×›×ª×•×‘ ×”×¢×¨×”..."></textarea>
                </div>
                <button class="btn btn-primary" onclick="addNote()">ğŸ’¬ ×”×•×¡×£ ×”×¢×¨×”</button>
            </div>
        </div>
    </div>

    <!-- Deletion History Modal -->
    <div id="deletionHistoryModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3 class="modal-title">ğŸ—‘ï¸ ×”×™×¡×˜×•×¨×™×™×ª ××—×™×§×•×ª</h3>
                <button class="modal-close" onclick="closeDeletionHistoryModal()">âœ•</button>
            </div>
            
            <table class="history-table">
                <thead>
                    <tr>
                        <th>×¡×•×’</th>
                        <th>×©×</th>
                        <th>× ××—×§ ×¢×œ ×™×“×™</th>
                        <th>×ª××¨×™×š</th>
                        <th>×¤×¢×•×œ×•×ª</th>
                    </tr>
                </thead>
                <tbody id="deletionHistoryBody"></tbody>
            </table>
            
            <div style="margin-top: 25px; text-align: left;">
                <button class="btn btn-delete" onclick="clearDeletionHistory()">
                    ğŸ—‘ï¸ × ×§×” ×”×›×œ
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== FIREBASE CONFIGURATION ====================
        
        const firebaseConfig = {
            apiKey: "AIzaSyAkOH2RMig-uUYqPGfpB_ECVGQ6sSty-RQ",
            authDomain: "family-tasks-b3460.firebaseapp.com",
            databaseURL: "https://family-tasks-b3460-default-rtdb.firebaseio.com",
            projectId: "family-tasks-b3460",
            storageBucket: "family-tasks-b3460.firebasestorage.app",
            messagingSenderId: "679268328049",
            appId: "1:679268328049:web:e8b0a3e8f5c8d9e0a8b0a3"
        };
        
        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();
        
        // Firebase references
        const tasksRef = db.ref('tasks');
        const shoppingRef = db.ref('shopping');
        const deletionHistoryRef = db.ref('deletionHistory');
        
        // ==================== GLOBAL VARIABLES ====================
        
        // Family members
        // Family Members - Load from localStorage or use defaults
        let familyMembers = JSON.parse(localStorage.getItem('familyMembers')) || {
            liat: { id: 'liat', name: '×œ×™××ª', icon: 'ğŸ‘©', color: '#E91E63', role: '×× ×”×œ×ª', isAdmin: true },
            hagai: { id: 'hagai', name: '×—×’×™', icon: 'ğŸ‘¨', color: '#2196F3', role: '×× ×”×œ', isAdmin: true, canBackup: true },
            maya: { id: 'maya', name: '××™×”', icon: 'ğŸ‘§', color: '#00BCD4', role: '××©×ª××©×ª' },
            ariel: { id: 'ariel', name: '××¨×™××œ', icon: 'ğŸ§’', color: '#4CAF50', role: '××©×ª××©' },
            ann: { id: 'ann', name: '××Ÿ', icon: 'ğŸ‘§', color: '#FF9800', role: '××©×ª××©×ª', canSpeak: true }
        };
        
        // Save default familyMembers if not exists
        if (!localStorage.getItem('familyMembers')) {
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
        }
        
        // Current state
        let currentUser = null;
        let selectedAssignee = null;
        let selectedPriority = 'medium';
        let currentFilter = 'pending';
        let currentShoppingFilter = 'pending';
        let currentTaskForNotes = null;
        let shoppingSearchQuery = '';
        let tasksSearchQuery = '';
        
        // Data (will be populated from Firebase)
        let tasks = {};
        let shopping = {};
        let deletionHistory = [];
        
        // Sync status
        let isOnline = false;
        let isSyncing = false;
        
        // Backup system (for Hagai)
        let backupDirectoryHandle = null;
        const DB_NAME = 'FamilyTasksDB';
        const STORE_NAME = 'backupSettings';
        
        // ==================== INITIALIZATION ====================
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
        
        function initializeApp() {
            // Check if user is logged in
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser && familyMembers[savedUser]) {
                loginUser(savedUser);
            } else {
                showLoginScreen();
            }
        }
        
        // ==================== LOGIN ====================
        
        function showLoginScreen() {
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.add('hidden');
            renderLoginCards();
        }
        
        function renderLoginCards() {
            const grid = document.getElementById('loginGrid');
            grid.innerHTML = '';
            
            // Get pending tasks count for each user from Firebase
            tasksRef.once('value', (snapshot) => {
                const tasksData = snapshot.val() || {};
                
                Object.values(familyMembers).forEach(member => {
                    const pendingCount = Object.values(tasksData).filter(task => 
                        task.assignedTo === member.id && task.status === 'pending'
                    ).length;
                    
                    const card = document.createElement('div');
                    card.className = 'login-card';
                    card.style.borderColor = member.color;
                    card.onclick = () => loginUser(member.id);
                    
                    card.innerHTML = `
                        <div class="login-icon">${member.icon}</div>
                        <div class="login-name">${member.name}</div>
                        <div class="login-badge ${pendingCount > 0 ? 'pending' : 'complete'}">
                            ${pendingCount > 0 ? `${pendingCount} ××©×™××•×ª` : 'âœ“ ××™×Ÿ ××©×™××•×ª'}
                        </div>
                    `;
                    
                    grid.appendChild(card);
                });
            });
        }
        
        function loginUser(userId) {
            // For Hagai - require password
            if (userId === 'hagai') {
                const password = prompt('ğŸ” ×”×›× ×¡ ×¡×™×¡××” ×¢×‘×•×¨ ×—×’×™:');
                if (password !== 'cochag12') {
                    alert('âŒ ×¡×™×¡××” ×©×’×•×™×”!');
                    return;
                }
            }
            
            currentUser = familyMembers[userId];
            localStorage.setItem('currentUser', userId);
            showMainApp();
        }
        
        // User Management Modal
        function openUserManagementModal() {
            document.getElementById('userManagementModal').classList.remove('hidden');
            loadCurrentUsers();
        }
        
        function closeUserManagementModal() {
            document.getElementById('userManagementModal').classList.add('hidden');
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
        }
        
        function loadCurrentUsers() {
            const container = document.getElementById('currentUsersList');
            container.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                
                const roleText = member.isAdmin ? 'ğŸ‘‘ ×× ×”×œ/×ª' : 'ğŸ‘¶ ×™×œ×“/×”';
                
                userItem.innerHTML = `
                    <div class="user-item-info">
                        <div class="user-item-icon">${member.icon}</div>
                        <div class="user-item-details">
                            <div class="user-item-name">${member.name}</div>
                            <div class="user-item-role">${roleText}</div>
                        </div>
                    </div>
                    <div class="user-item-actions">
                        <button class="btn-icon" style="background: #FFF3E0; color: #F57C00;" onclick="editUser('${member.id}')">âœï¸</button>
                        <button class="btn-icon btn-delete" onclick="deleteUser('${member.id}')">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                container.appendChild(userItem);
            });
        }
        
        function addNewUser() {
            const name = document.getElementById('newUserName').value.trim();
            const icon = document.getElementById('newUserIcon').value.trim();
            const role = document.getElementById('newUserRole').value;
            
            if (!name) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×©× ××©×ª××©');
                return;
            }
            
            if (!icon) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ××™××•×’\'×™');
                return;
            }
            
            // Check if name already exists
            const nameExists = Object.values(familyMembers).some(m => m.name === name);
            if (nameExists) {
                alert('âŒ ×©× ××©×ª××© ×›×‘×¨ ×§×™×™×');
                return;
            }
            
            const userId = name.toLowerCase().replace(/\s/g, '');
            const isAdmin = role === 'admin';
            
            const colors = ['#E91E63', '#9C27B0', '#3F51B5', '#00BCD4', '#4CAF50', '#FF9800', '#795548'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const newUser = {
                id: userId,
                name: name,
                icon: icon,
                role: isAdmin ? '×× ×”×œ/×ª' : '×™×œ×“/×”',
                color: randomColor,
                isAdmin: isAdmin,
                canSpeak: false
            };
            
            // Add to familyMembers
            familyMembers[userId] = newUser;
            
            // Save to localStorage for persistence
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Clear inputs
            document.getElementById('newUserName').value = '';
            document.getElementById('newUserIcon').value = '';
            document.getElementById('newUserRole').value = 'child';
            
            // Reload list
            loadCurrentUsers();
            
            // Update login grid
            renderLoginCards();
            
            showToast(`âœ… ${name} × ×•×¡×£/×” ×‘×”×¦×œ×—×”!`);
        }
        
        function editUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            const newName = prompt(`âœï¸ ×©× ×—×“×© ×¢×‘×•×¨ ${user.name}:`, user.name);
            if (!newName || newName.trim() === '') return;
            
            const newIcon = prompt(`âœï¸ ××™××•×’'×™ ×—×“×© ×¢×‘×•×¨ ${user.name}:`, user.icon);
            if (!newIcon || newIcon.trim() === '') return;
            
            // Update user
            familyMembers[userId].name = newName.trim();
            familyMembers[userId].icon = newIcon.trim();
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`âœ… ${newName} ×¢×•×“×›×Ÿ/×” ×‘×”×¦×œ×—×”!`);
        }
        
        function deleteUser(userId) {
            const user = familyMembers[userId];
            if (!user) return;
            
            // Prevent deletion of admins
            if (user.isAdmin) {
                alert('âŒ ×œ× × ×™×ª×Ÿ ×œ××—×•×§ ×× ×”×œ×™× (×—×’×™ ×•×œ×™××ª)');
                return;
            }
            
            if (!confirm(`ğŸ—‘ï¸ ×”×× ×œ××—×•×§ ××ª ${user.name}?\n\nâš ï¸ ×–×” ×™××—×§ ×’× ××ª ×›×œ ×”××©×™××•×ª ×”××•×§×¦×•×ª ×œ×•/×œ×”!`)) {
                return;
            }
            
            // Delete from familyMembers
            delete familyMembers[userId];
            
            // Save to localStorage
            localStorage.setItem('familyMembers', JSON.stringify(familyMembers));
            
            // Delete all tasks assigned to this user
            tasksRef.once('value', (snapshot) => {
                const tasksData = snapshot.val() || {};
                Object.keys(tasksData).forEach(taskId => {
                    if (tasksData[taskId].assignedTo === userId) {
                        tasksRef.child(taskId).remove();
                    }
                });
            });
            
            // Reload
            loadCurrentUsers();
            renderLoginCards();
            
            showToast(`ğŸ—‘ï¸ ${user.name} × ××—×§/×” ×‘×”×¦×œ×—×”`);
        }
        
        function showMainApp() {
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            
            // Update header
            document.getElementById('userAvatar').textContent = currentUser.icon;
            document.getElementById('userName').textContent = currentUser.name;
            document.getElementById('userRole').textContent = currentUser.role;
            
            // Show/hide stats screen navigation - only for admins
            const navStats = document.getElementById('navStats');
            if (currentUser.isAdmin) {
                navStats.style.display = 'flex';
            } else {
                navStats.style.display = 'none';
            }
            
            // Show/hide top performers card - only for Hagai
            const topPerformersCard = document.getElementById('topPerformersCard');
            if (currentUser.id === 'hagai') {
                topPerformersCard.classList.remove('hidden');
            } else {
                topPerformersCard.classList.add('hidden');
            }
            
            // Show deletion history, backup, restore buttons ONLY for Hagai
            if (currentUser.id === 'hagai') {
                document.getElementById('btnDeletionHistory').classList.remove('hidden');
                document.getElementById('btnBackup').classList.remove('hidden');
                document.getElementById('btnRestore').classList.remove('hidden');
                setupAutoBackup();
            } else {
                // Hide for all other users
                document.getElementById('btnDeletionHistory').classList.add('hidden');
                document.getElementById('btnBackup').classList.add('hidden');
                document.getElementById('btnRestore').classList.add('hidden');
            }
            
            // Set default filter based on user role
            if (currentUser.isAdmin) {
                // Admins see "pending" by default
                currentFilter = 'pending';
                document.querySelector('.filter-btn[onclick*="pending"]').classList.add('active');
            } else {
                // Regular users see "my tasks" by default
                currentFilter = 'my-tasks';
                const myTasksBtn = document.getElementById('myTasksFilter');
                // Remove active from pending
                document.querySelector('.filter-btn[onclick*="pending"]').classList.remove('active');
                // Add active to my-tasks
                myTasksBtn.classList.add('active');
            }
            
            // Setup Firebase listeners
            setupFirebaseListeners();
            
            // Monitor connection status
            monitorConnection();
            
            // Populate assignee grid
            populateAssigneeGrid();
            populateQuickAssigneeGrid();
        }
        
        function logout() {
            currentUser = null;
            localStorage.removeItem('currentUser');
            
            // Remove Firebase listeners
            tasksRef.off();
            shoppingRef.off();
            deletionHistoryRef.off();
            
            showLoginScreen();
        }
        
        // ==================== FIREBASE LISTENERS ====================
        
        function setupFirebaseListeners() {
            // Tasks listener
            tasksRef.on('value', (snapshot) => {
                tasks = snapshot.val() || {};
                loadTasks();
                loadStats();
                updateTabCounts();
            });
            
            // Shopping listener
            shoppingRef.on('value', (snapshot) => {
                shopping = snapshot.val() || {};
                loadShopping();
                loadStats();
                updateTabCounts();
            });
            
            // Deletion history listener
            deletionHistoryRef.on('value', (snapshot) => {
                deletionHistory = snapshot.val() || [];
            });
        }
        
        function updateTabCounts() {
            // Count pending tasks for current user
            const allTasks = Object.values(tasks);
            const visibleTasks = allTasks.filter(t => !t.isPersonal || t.assignedTo === currentUser.id || currentUser.id === 'hagai');
            const pendingTasks = visibleTasks.filter(t => t.status === 'pending').length;
            
            // Count pending shopping items
            const allShopping = Object.values(shopping);
            const pendingShopping = allShopping.filter(i => i.status === 'pending').length;
            
            // Update bottom nav badges
            const navTasksBadge = document.getElementById('navTasksBadge');
            const navShoppingBadge = document.getElementById('navShoppingBadge');
            
            if (navTasksBadge) {
                navTasksBadge.textContent = pendingTasks;
                navTasksBadge.style.display = pendingTasks > 0 ? 'block' : 'none';
            }
            
            if (navShoppingBadge) {
                navShoppingBadge.textContent = pendingShopping;
                navShoppingBadge.style.display = pendingShopping > 0 ? 'block' : 'none';
            }
        }
        
        function monitorConnection() {
            const connectedRef = db.ref('.info/connected');
            connectedRef.on('value', (snap) => {
                isOnline = snap.val() === true;
                updateSyncStatus();
            });
        }
        
        function updateSyncStatus() {
            const statusDiv = document.getElementById('syncStatus');
            if (!statusDiv) return;
            
            if (isSyncing) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #FFA500;"></span> ××¡× ×›×¨×Ÿ...';
            } else if (isOnline) {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #4CAF50;"></span> ××—×•×‘×¨';
            } else {
                statusDiv.innerHTML = '<span class="sync-dot" style="background: #f44336;"></span> ×œ× ××—×•×‘×¨';
            }
        }
        
        // ==================== TABS ====================
        
        function switchScreen(screenName) {
            // Update bottom nav buttons
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('nav' + screenName.charAt(0).toUpperCase() + screenName.slice(1)).classList.add('active');
            
            // Update screen content
            document.getElementById('tasksTab').classList.toggle('hidden', screenName !== 'tasks');
            document.getElementById('shoppingTab').classList.toggle('hidden', screenName !== 'shopping');
            document.getElementById('statsScreen').classList.toggle('hidden', screenName !== 'stats');
            
            // Show/hide FAB based on screen
            const fab = document.querySelector('.fab');
            if (screenName === 'stats') {
                fab.style.display = 'none';
            } else {
                fab.style.display = 'flex';
            }
            
            // Clear search when leaving tabs
            if (screenName !== 'shopping') {
                shoppingSearchQuery = '';
                const searchInput = document.getElementById('shoppingSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
            
            if (screenName !== 'tasks') {
                tasksSearchQuery = '';
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
        }
        
        // Keep old switchTab for compatibility
        function switchTab(tabName) {
            switchScreen(tabName);
        }
        
        // ==================== TASKS ====================
        
        function populateAssigneeGrid() {
            const grid = document.getElementById('assigneeGrid');
            grid.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.style.color = member.color;
                btn.onclick = (e) => selectAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectAssignee(memberId, event) {
            selectedAssignee = memberId;
            
            // Update UI
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function selectPriority(priority, event) {
            selectedPriority = priority;
            
            // Update UI
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        // Quick Assignee Grid for Quick Add
        let quickSelectedAssignee = null;
        
        function populateQuickAssigneeGrid() {
            const grid = document.getElementById('quickAssigneeGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            Object.values(familyMembers).forEach(member => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'assignee-btn';
                btn.style.color = member.color;
                btn.onclick = (e) => selectQuickAssignee(member.id, e);
                
                btn.innerHTML = `
                    <div class="assignee-icon">${member.icon}</div>
                    <div class="assignee-name">${member.name}</div>
                `;
                
                grid.appendChild(btn);
            });
        }
        
        function selectQuickAssignee(memberId, event) {
            quickSelectedAssignee = memberId;
            
            // Update UI
            const grid = document.getElementById('quickAssigneeGrid');
            grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            event.currentTarget.classList.add('selected');
        }
        
        function addQuickTask() {
            const input = document.getElementById('quickTaskInput');
            const taskName = input.value.trim();
            
            if (!taskName) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×©× ××©×™××”');
                return;
            }
            
            if (!quickSelectedAssignee) {
                alert('âŒ × × ×œ×‘×—×•×¨ ×œ××™ ×œ×”×§×¦×•×ª ××ª ×”××©×™××”');
                return;
            }
            
            const assignee = familyMembers[quickSelectedAssignee];
            
            const newTask = {
                id: 'task_' + Date.now(),
                title: taskName,
                description: '',
                assignedTo: assignee.id,
                assignedToName: assignee.name,
                assignedToIcon: assignee.icon,
                assignedToColor: assignee.color,
                priority: 'medium',
                status: 'pending',
                createdAt: Date.now(),
                createdBy: currentUser.name,
                createdById: currentUser.id,
                isPinned: false,
                isPersonal: false,
                isRecurring: false,
                dueDate: null
            };
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(newTask.id).set(newTask)
                .then(() => {
                    input.value = '';
                    quickSelectedAssignee = null;
                    
                    // Reset selection
                    const grid = document.getElementById('quickAssigneeGrid');
                    grid.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
                    
                    showToast(`âœ… ××©×™××” × ×•×¡×¤×” ×œ-${assignee.name}!`);
                })
                .catch(error => {
                    console.error('Error adding task:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×•×¡×¤×ª ×”××©×™××”');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // FAB - Smart modal opener based on active tab
        function openFABModal() {
            const tasksTab = document.getElementById('tasksTab');
            const shoppingTab = document.getElementById('shoppingTab');
            
            if (!tasksTab.classList.contains('hidden')) {
                // Tasks tab is active - open task modal
                openAddTaskModal();
            } else if (!shoppingTab.classList.contains('hidden')) {
                // Shopping tab is active - open shopping modal
                openAddShoppingModal();
            } else {
                // Default to task modal
                openAddTaskModal();
            }
        }
        
        function openAddTaskModal() {
            document.getElementById('addTaskModal').classList.add('active');
            
            // Show recurring option only for admins
            const recurringGroup = document.getElementById('recurringGroup');
            if (currentUser.isAdmin) {
                recurringGroup.style.display = 'block';
            } else {
                recurringGroup.style.display = 'none';
            }
        }
        
        function closeAddTaskModal() {
            document.getElementById('addTaskModal').classList.remove('active');
            document.getElementById('addTaskForm').reset();
            selectedAssignee = null;
            selectedPriority = 'medium';
            
            // Reset recurring options
            document.getElementById('recurringOptions').style.display = 'none';
            
            // Reset selections
            document.querySelectorAll('.assignee-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.priority-btn[onclick*="medium"]').classList.add('selected');
        }
        
        function toggleRecurringOptions() {
            const isRecurring = document.getElementById('taskIsRecurring').checked;
            const options = document.getElementById('recurringOptions');
            options.style.display = isRecurring ? 'block' : 'none';
        }
        
        function submitTask(event) {
            event.preventDefault();
            
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const dueDate = document.getElementById('taskDueDate').value;
            const isPersonal = document.getElementById('taskIsPersonal').checked;
            const isRecurring = document.getElementById('taskIsRecurring') ? document.getElementById('taskIsRecurring').checked : false;
            const recurringType = isRecurring ? document.getElementById('recurringType').value : null;
            
            if (!title || !selectedAssignee) {
                alert('× × ×œ××œ× ××ª ×›×œ ×”×©×“×•×ª ×”×—×•×‘×”');
                return;
            }
            
            const assignedUser = familyMembers[selectedAssignee];
            const taskId = 'task_' + Date.now();
            
            const task = {
                id: taskId,
                title,
                description,
                assignedTo: selectedAssignee,
                assignedToName: assignedUser.name,
                assignedToIcon: assignedUser.icon,
                assignedToColor: assignedUser.color,
                dueDate,
                priority: selectedPriority,
                status: 'pending',
                createdAt: Date.now(),
                createdBy: currentUser.name,
                createdById: currentUser.id,
                completedAt: null,
                completedBy: null,
                completedById: null,
                isPersonal,
                isPinned: false,
                notes: [],
                isRecurring,
                recurringType,
                lastCompletedAt: null
            };
            
            // Add to Firebase
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).set(task)
                .then(() => {
                    console.log('âœ… ××©×™××” × ×•×¡×¤×” ×œ-Firebase');
                    closeAddTaskModal();
                })
                .catch(error => {
                    console.error('âŒ ×©×’×™××”:', error);
                    alert('×©×’×™××” ×‘×”×•×¡×¤×ª ×”××©×™××”');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadTasks() {
            const container = document.getElementById('tasksList');
            container.innerHTML = '';
            
            let filteredTasks = Object.values(tasks);
            
            // Filter by visibility based on user role
            if (currentUser.isAdmin) {
                // Admins (Liat and Hagai) see all non-personal tasks + their own personal tasks
                // Hagai sees everything including all personal tasks
                if (currentUser.id !== 'hagai') {
                    // Liat sees all tasks except personal tasks of others
                    filteredTasks = filteredTasks.filter(task => 
                        !task.isPersonal || task.assignedTo === currentUser.id
                    );
                }
                // Hagai sees ALL tasks (no filter)
            } else {
                // Regular users see: their own tasks only (both personal and regular)
                filteredTasks = filteredTasks.filter(task => 
                    task.assignedTo === currentUser.id
                );
            }
            
            // Apply search filter
            if (tasksSearchQuery) {
                filteredTasks = filteredTasks.filter(task => 
                    task.title.toLowerCase().includes(tasksSearchQuery.toLowerCase()) ||
                    (task.description && task.description.toLowerCase().includes(tasksSearchQuery.toLowerCase())) ||
                    (task.assignedToName && task.assignedToName.toLowerCase().includes(tasksSearchQuery.toLowerCase()))
                );
            }
            
            // Apply status/type filter
            if (currentFilter === 'pending') {
                filteredTasks = filteredTasks.filter(t => t.status === 'pending');
            } else if (currentFilter === 'completed') {
                filteredTasks = filteredTasks.filter(t => t.status === 'completed');
            } else if (currentFilter === 'personal') {
                // Show only personal tasks that the user can see
                filteredTasks = filteredTasks.filter(t => {
                    if (!t.isPersonal) return false;
                    // Hagai sees all personal tasks
                    if (currentUser.id === 'hagai') return true;
                    // Others see only their own personal tasks
                    return t.assignedTo === currentUser.id;
                });
            } else if (currentFilter === 'my-tasks') {
                // Show only tasks assigned to me
                filteredTasks = filteredTasks.filter(t => t.assignedTo === currentUser.id);
            }
            
            // Sort: pinned first, then by status, then by date
            filteredTasks.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                if (a.status === 'pending' && b.status === 'completed') return -1;
                if (a.status === 'completed' && b.status === 'pending') return 1;
                return b.createdAt - a.createdAt;
            });
            
            // Update filter counts
            const allTasks = Object.values(tasks).filter(t => {
                if (currentUser.isAdmin) {
                    if (currentUser.id === 'hagai') return true; // Hagai sees all
                    return !t.isPersonal || t.assignedTo === currentUser.id; // Liat sees all except others' personal
                }
                return t.assignedTo === currentUser.id; // Regular users see only their tasks
            });
            const pending = allTasks.filter(t => t.status === 'pending').length;
            const personal = allTasks.filter(t => t.isPersonal).length;
            const myTasks = allTasks.filter(t => t.assignedTo === currentUser.id).length;
            
            document.getElementById('pendingTasksCount').textContent = pending;
            document.getElementById('personalTasksCount').textContent = personal;
            document.getElementById('myTasksCount').textContent = myTasks;
            
            if (filteredTasks.length === 0) {
                const emptyMessage = tasksSearchQuery 
                    ? `×œ× × ××¦××• ×ª×•×¦××•×ª ×¢×‘×•×¨ "${tasksSearchQuery}"`
                    : '××™×Ÿ ××©×™××•×ª ×œ×”×¦×’×”';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ğŸ“‹</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredTasks.forEach((task, index) => {
                const taskEl = createTaskElement(task, index);
                container.appendChild(taskEl);
            });
        }
        
        function createTaskElement(task, index) {
            const div = document.createElement('div');
            div.className = `item ${task.isPinned ? 'pinned' : ''} ${task.status === 'completed' ? 'completed' : ''}`;
            div.setAttribute('data-task-id', task.id);
            div.dataset.itemId = task.id;
            
            const priorityLabels = {
                high: { emoji: 'ğŸ”´', class: 'badge-priority-high', text: '×’×‘×•×”×”' },
                medium: { emoji: 'ğŸŸ¡', class: 'badge-priority-medium', text: '×¨×’×™×œ×”' },
                low: { emoji: 'ğŸŸ¢', class: 'badge-priority-low', text: '× ××•×›×”' }
            };
            
            const priority = priorityLabels[task.priority];
            const isAdmin = currentUser.isAdmin;
            
            const dueDate = task.dueDate ? new Date(task.dueDate) : null;
            
            // Build action buttons
            let actions = '';
            
            if (task.status === 'pending') {
                actions += `<button class="btn-icon btn-complete" onclick="completeTask('${task.id}')">âœ“</button>`;
            }
            
            if (isAdmin) {
                actions += `<button class="btn-icon btn-delete" onclick="deleteTask('${task.id}')">ğŸ—‘ï¸</button>`;
            }
            
            actions += `<button class="btn-icon btn-pin" onclick="togglePinTask('${task.id}')">${task.isPinned ? 'ğŸ“Œ' : 'ğŸ“Œ'}</button>`;
            
            const notesCount = task.notes ? task.notes.length : 0;
            actions += `<button class="btn-icon btn-notes" onclick="openNotesModal('${task.id}')">
                ${notesCount > 0 ? `<span class="note-badge">${notesCount}</span>` : ''}
                ğŸ’¬
            </button>`;
            
            // Add to Calendar button (only if task has due date)
            if (task.dueDate) {
                actions += `<button class="btn-icon btn-calendar" onclick="addToCalendar('${task.id}')" title="×”×•×¡×£ ×œ×™×•××Ÿ">ğŸ“…</button>`;
            }
            
            div.innerHTML = `
                <div class="swipe-indicator left">âœ“</div>
                <div class="swipe-indicator right">â†©ï¸</div>
                <div class="swipe-indicator up">â¬†ï¸</div>
                <div class="swipe-indicator down">â¬‡ï¸</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${task.isPinned ? 'ğŸ“Œ ' : ''}${task.isRecurring ? 'ğŸ”„ ' : ''}${task.isPersonal ? 'ğŸ”’ ' : ''}${task.title}${task.description ? ` (${task.description})` : ''} â€¢ ${priority.emoji} â€¢ ${task.assignedToIcon} ${task.assignedToName}${dueDate ? ` â€¢ ğŸ“… ${dueDate.toLocaleDateString('he-IL')}` : ''}${task.status === 'completed' && task.completedBy ? ` â€¢ âœ“ ${task.completedBy}` : ''}
                </div>
                <div class="item-actions">${actions}</div>
            `;
            
            // Add touch handlers for swipe
            setupTaskSwipeHandlers(div, task);
            
            return div;
        }
        
        // Swipe Handler Setup for Tasks
        function setupTaskSwipeHandlers(element, task) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                element.classList.add('swiping');
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Only swipe if horizontal movement is dominant
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    // Show indicators
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Swipe vertical
                    e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateY(${diffY}px)`;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swipe up
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                    } else if (diffY > 30) {
                        // Swipe down
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                    }
                }
            });
            
            element.addEventListener('touchend', (e) => {
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as complete)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'pending') {
                        completeTask(task.id);
                    }
                }
                // Swipe right (uncomplete)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (task.status === 'completed') {
                        uncompleteTask(task.id);
                    }
                }
                // Swipe up (priority up - not implemented for tasks)
                else if (diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    // Could implement priority increase here
                }
                // Swipe down (priority down - not implemented for tasks)
                else if (diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    // Could implement priority decrease here
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                }
            });
        }
        
        function completeTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            if (task.isRecurring) {
                // For recurring tasks, reset instead of marking as completed
                tasksRef.child(taskId).update({
                    lastCompletedAt: Date.now(),
                    lastCompletedBy: currentUser.name,
                    lastCompletedById: currentUser.id
                }).then(() => {
                    console.log('âœ… ××©×™××” ××—×–×•×¨×™×ª ×”×•×©×œ××” ×•××•×¤×¡×”');
                    // Show notification
                    showToast(`âœ… ${task.title} ×‘×•×¦×¢×”! ×”××©×™××” ×ª×—×–×•×¨ ${task.recurringType === 'daily' ? '××—×¨' : '×‘×©×‘×•×¢ ×”×‘×'}`);
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            } else {
                // Regular task - mark as completed
                tasksRef.child(taskId).update({
                    status: 'completed',
                    completedAt: Date.now(),
                    completedBy: currentUser.name,
                    completedById: currentUser.id
                }).then(() => {
                    showToast('âœ… ×”××©×™××” ×”×•×©×œ××”');
                }).finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
            }
        }
        
        function uncompleteTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).update({
                status: 'pending',
                completedAt: null,
                completedBy: null,
                completedById: null
            }).then(() => {
                showToast('â†©ï¸ ×”××©×™××” ×—×–×¨×” ×œ××¦×‘ ×××ª×™×Ÿ');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #4CAF50, #66BB6A);
                color: white;
                padding: 15px 30px;
                border-radius: 12px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                animation: slideUp 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideDown 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function addToCalendar(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            if (!task.dueDate) {
                alert('âŒ ×œ××©×™××” ××™×Ÿ ×ª××¨×™×š ×™×¢×“');
                return;
            }
            
            // Format task details for Google Calendar
            const title = task.title;
            const description = task.description || '';
            const priority = task.priority === 'high' ? 'ğŸ”´ ×¢×“×™×¤×•×ª ×’×‘×•×”×”' : task.priority === 'medium' ? 'ğŸŸ¡ ×¢×“×™×¤×•×ª ×¨×’×™×œ×”' : 'ğŸŸ¢ ×¢×“×™×¤×•×ª × ××•×›×”';
            const assignedTo = `××•×§×¦×” ×œ: ${task.assignedToName}`;
            
            const fullDescription = `${description}\n\n${priority}\n${assignedTo}`;
            
            // Format date for Google Calendar (YYYYMMDDTHHMMSS format)
            const dueDate = new Date(task.dueDate);
            const startDate = new Date(dueDate);
            startDate.setHours(9, 0, 0); // Set to 9:00 AM
            
            const endDate = new Date(dueDate);
            endDate.setHours(10, 0, 0); // Set to 10:00 AM (1 hour duration)
            
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}`;
            };
            
            const startDateFormatted = formatDate(startDate);
            const endDateFormatted = formatDate(endDate);
            
            // Build Google Calendar URL
            const baseUrl = 'https://calendar.google.com/calendar/render';
            const params = new URLSearchParams({
                action: 'TEMPLATE',
                text: title,
                dates: `${startDateFormatted}/${endDateFormatted}`,
                details: fullDescription,
                location: '',
                trp: 'false'
            });
            
            const calendarUrl = `${baseUrl}?${params.toString()}`;
            
            // Open in new window
            window.open(calendarUrl, '_blank');
            
            showToast('ğŸ“… × ×¤×ª×— Google Calendar!');
        }
        
        function deleteTask(taskId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ××—×•×§ ××©×™××•×ª');
                return;
            }
            
            const task = tasks[taskId];
            if (!task) return;
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”××©×™××” "${task.title}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'task',
                item: task.title,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: task
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                tasksRef.child(taskId).remove()
            ]).then(() => {
                console.log('âœ… ××©×™××” × ××—×§×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(taskId).update({
                isPinned: !task.isPinned
            }).then(() => {
                console.log('ğŸ“Œ ×”×¦××“×” ×©×•× ×ª×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function readTask(taskId) {
            const task = tasks[taskId];
            if (!task) return;
            
            if (!('speechSynthesis' in window)) {
                alert('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×”×§×¨××”. × ×¡×” ×œ×”×©×ª××© ×‘-Chrome ××• Edge.');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            let speechText = `××©×™××”: ${task.title}. `;
            
            if (task.description) {
                speechText += `${task.description}. `;
            }
            
            speechText += `××—×¨××™: ${task.assignedToName}. `;
            
            if (task.dueDate) {
                const dueDate = new Date(task.dueDate);
                const formattedDate = dueDate.toLocaleDateString('he-IL');
                speechText += `×ª××¨×™×š ×™×¢×“: ${formattedDate}. `;
            }
            
            const priorityText = {
                high: '×¢×“×™×¤×•×ª ×’×‘×•×”×”',
                medium: '×¢×“×™×¤×•×ª ×¨×’×™×œ×”',
                low: '×¢×“×™×¤×•×ª × ××•×›×”'
            };
            speechText += priorityText[task.priority] + '. ';
            
            if (task.status === 'completed') {
                speechText += `×”××©×™××” ×‘×•×¦×¢×” ×¢×œ ×™×“×™ ${task.completedBy}. `;
            } else {
                speechText += '×”××©×™××” ×××ª×™× ×” ×œ×‘×™×¦×•×¢.';
            }
            
            const utterance = new SpeechSynthesisUtterance(speechText);
            utterance.lang = 'he-IL';
            utterance.rate = 0.9;
            utterance.pitch = 1;
            
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            const readButton = taskElement ? taskElement.querySelector('.read-btn') : null;
            
            if (readButton) {
                readButton.classList.add('reading');
            }
            
            utterance.onend = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
            };
            
            utterance.onerror = () => {
                if (readButton) {
                    readButton.classList.remove('reading');
                }
                alert('×©×’×™××” ×‘×”×§×¨××ª ×”××©×™××”');
            };
            
            window.speechSynthesis.speak(utterance);
        }
        
        function filterTasks(filter, event) {
            currentFilter = filter;
            
            // Update filter buttons
            const tasksTab = document.getElementById('tasksTab');
            tasksTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadTasks();
        }
        
        function filterTasksBySearch() {
            tasksSearchQuery = document.getElementById('tasksSearchInput').value.trim();
            loadTasks();
        }
        
        function filterByMember(memberId) {
            // Switch to tasks tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab')[0].classList.add('active'); // First tab is tasks
            
            document.getElementById('tasksTab').classList.remove('hidden');
            document.getElementById('shoppingTab').classList.add('hidden');
            
            // Set filter to pending
            currentFilter = 'pending';
            document.querySelectorAll('#tasksTab .filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#tasksTab .filter-btn')[0].classList.add('active'); // First filter is pending
            
            // Set search to member name
            const member = familyMembers[memberId];
            if (member) {
                tasksSearchQuery = member.name;
                const searchInput = document.getElementById('tasksSearchInput');
                if (searchInput) {
                    searchInput.value = member.name;
                }
                loadTasks();
            }
        }
        
        // ==================== NOTES ====================
        
        function openNotesModal(taskId) {
            currentTaskForNotes = taskId;
            const task = tasks[taskId];
            if (!task) return;
            
            const modal = document.getElementById('notesModal');
            const notesList = document.getElementById('notesList');
            const addNoteSection = document.getElementById('addNoteSection');
            
            // Check if user can add notes (only assigned user)
            const canAddNote = task.assignedTo === currentUser.id;
            addNoteSection.style.display = canAddNote ? 'block' : 'none';
            
            // Render existing notes
            notesList.innerHTML = '';
            if (task.notes && task.notes.length > 0) {
                task.notes.forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'note-item';
                    noteEl.style.borderRightColor = note.authorColor || '#E0E0E0';
                    
                    const date = new Date(note.createdAt);
                    noteEl.innerHTML = `
                        <div class="note-header">
                            <span class="note-author">
                                ${note.authorIcon} ${note.authorName}
                            </span>
                            <span>${date.toLocaleDateString('he-IL')} ${date.toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                        <div class="note-text">${note.text}</div>
                    `;
                    notesList.appendChild(noteEl);
                });
            } else {
                notesList.innerHTML = '<div class="empty-state"><div class="empty-icon">ğŸ’¬</div><div class="empty-text">××™×Ÿ ×”×¢×¨×•×ª ×œ××©×™××” ×–×•</div></div>';
            }
            
            modal.classList.add('active');
        }
        
        function closeNotesModal() {
            document.getElementById('notesModal').classList.remove('active');
            document.getElementById('newNoteText').value = '';
            currentTaskForNotes = null;
        }
        
        function addNote() {
            const text = document.getElementById('newNoteText').value.trim();
            if (!text) {
                alert('âŒ × × ×œ×”×–×™×Ÿ ×ª×•×›×Ÿ ×œ×”×¢×¨×”');
                return;
            }
            
            const task = tasks[currentTaskForNotes];
            if (!task) return;
            
            if (task.assignedTo !== currentUser.id) {
                alert('âŒ ×¨×§ ××§×‘×œ ×”××©×™××” ×™×›×•×œ ×œ×”×•×¡×™×£ ×”×¢×¨×•×ª');
                return;
            }
            
            const note = {
                text,
                authorId: currentUser.id,
                authorName: currentUser.name,
                authorIcon: currentUser.icon,
                authorColor: currentUser.color,
                createdAt: Date.now()
            };
            
            const notes = task.notes || [];
            notes.push(note);
            
            isSyncing = true;
            updateSyncStatus();
            
            tasksRef.child(currentTaskForNotes).update({ notes })
                .then(() => {
                    console.log('âœ… ×”×¢×¨×” × ×•×¡×¤×”');
                    document.getElementById('newNoteText').value = '';
                    openNotesModal(currentTaskForNotes); // Refresh
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== SHOPPING ====================
        
        function quickAddItem(event) {
            event.preventDefault();
            
            const itemName = document.getElementById('quickItemInput').value.trim();
            if (!itemName) return;
            
            const itemId = 'item_' + Date.now();
            
            const item = {
                id: itemId,
                name: itemName,
                addedBy: currentUser.name,
                addedById: currentUser.id,
                addedByIcon: currentUser.icon,
                addedByColor: currentUser.color,
                addedAt: Date.now(),
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null,
                isPinned: false
            };
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).set(item)
                .then(() => {
                    console.log('âœ… ×¤×¨×™×˜ × ×•×¡×£');
                    document.getElementById('quickItemInput').value = '';
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function loadShopping() {
            const container = document.getElementById('shoppingList');
            container.innerHTML = '';
            
            let filteredItems = Object.values(shopping);
            
            // Apply search filter
            if (shoppingSearchQuery) {
                filteredItems = filteredItems.filter(item => 
                    item.name.toLowerCase().includes(shoppingSearchQuery.toLowerCase())
                );
            }
            
            // Apply status filter
            if (currentShoppingFilter === 'pending') {
                filteredItems = filteredItems.filter(item => item.status === 'pending');
            } else if (currentShoppingFilter === 'purchased') {
                filteredItems = filteredItems.filter(item => item.status === 'purchased');
            }
            
            // Sort: pinned first, then by status, then by date
            filteredItems.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                if (a.status === 'pending' && b.status === 'purchased') return -1;
                if (a.status === 'purchased' && b.status === 'pending') return 1;
                return b.addedAt - a.addedAt;
            });
            
            if (filteredItems.length === 0) {
                const emptyMessage = shoppingSearchQuery 
                    ? `×œ× × ××¦××• ×ª×•×¦××•×ª ×¢×‘×•×¨ "${shoppingSearchQuery}"`
                    : '××™×Ÿ ×¤×¨×™×˜×™× ×œ×”×¦×’×”';
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ğŸ›’</div>
                        <div class="empty-text">${emptyMessage}</div>
                    </div>
                `;
                return;
            }
            
            filteredItems.forEach((item, index) => {
                const itemEl = createShoppingElement(item, index);
                container.appendChild(itemEl);
            });
        }
        
        function createShoppingElement(item, index) {
            const div = document.createElement('div');
            div.className = `item ${item.isPinned ? 'pinned' : ''} ${item.status === 'purchased' ? 'purchased' : ''}`;
            div.dataset.itemId = item.id;
            
            const isAdmin = currentUser.isAdmin;
            
            const addedDate = new Date(item.addedAt);
            
            div.innerHTML = `
                <div class="swipe-indicator left">âœ“</div>
                <div class="swipe-indicator right">â†©ï¸</div>
                <div class="swipe-indicator up">â¬†ï¸</div>
                <div class="swipe-indicator down">â¬‡ï¸</div>
                <div class="item-number">${index + 1}.</div>
                <div class="item-content">
                    ${item.isPinned ? 'ğŸ“Œ ' : ''}${item.name} â€¢ ${item.addedByIcon} ${item.addedBy} â€¢ ğŸ“… ${addedDate.toLocaleDateString('he-IL')}${item.status === 'purchased' && item.purchasedBy ? ` â€¢ âœ“ ${item.purchasedBy}` : ''}
                </div>
            `;
            
            // Add touch handlers for swipe
            setupSwipeHandlers(div, item);
            
            return div;
        }
        
        // Swipe Handler Setup
        function setupSwipeHandlers(element, item) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isSwiping = false;
            
            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isSwiping = false;
                element.classList.add('swiping');
            });
            
            element.addEventListener('touchmove', (e) => {
                if (!startX || !startY) return;
                
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Only swipe if horizontal movement is dominant
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateX(${diffX}px)`;
                    
                    // Show indicators
                    const leftIndicator = element.querySelector('.swipe-indicator.left');
                    const rightIndicator = element.querySelector('.swipe-indicator.right');
                    
                    if (diffX < -50) {
                        element.classList.add('swipe-left');
                        leftIndicator.classList.add('visible');
                        rightIndicator.classList.remove('visible');
                    } else if (diffX > 50) {
                        element.classList.add('swipe-right');
                        rightIndicator.classList.add('visible');
                        leftIndicator.classList.remove('visible');
                    } else {
                        element.classList.remove('swipe-left', 'swipe-right');
                        leftIndicator.classList.remove('visible');
                        rightIndicator.classList.remove('visible');
                    }
                } else if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 30) {
                    // Swipe vertical
                    e.preventDefault();
                    isSwiping = true;
                    element.style.transform = `translateY(${diffY}px)`;
                    
                    const upIndicator = element.querySelector('.swipe-indicator.up');
                    const downIndicator = element.querySelector('.swipe-indicator.down');
                    
                    if (diffY < -30) {
                        // Swipe up
                        element.classList.add('swipe-up');
                        element.classList.remove('swipe-down');
                        upIndicator.classList.add('visible');
                        downIndicator.classList.remove('visible');
                    } else if (diffY > 30) {
                        // Swipe down
                        element.classList.add('swipe-down');
                        element.classList.remove('swipe-up');
                        downIndicator.classList.add('visible');
                        upIndicator.classList.remove('visible');
                    }
                }
            });
            
            element.addEventListener('touchend', (e) => {
                if (!isSwiping) {
                    resetSwipe();
                    return;
                }
                
                const diffX = currentX - startX;
                const diffY = currentY - startY;
                
                // Swipe left (mark as purchased)
                if (diffX < -100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'pending') {
                        purchaseItem(item.id);
                    }
                }
                // Swipe right (unmark as purchased)
                else if (diffX > 100 && Math.abs(diffX) > Math.abs(diffY)) {
                    if (item.status === 'purchased') {
                        unpurchaseItem(item.id);
                    }
                }
                // Swipe up (move up in list)
                else if (diffY < -100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemUp(item.id);
                }
                // Swipe down (move down in list)
                else if (diffY > 100 && Math.abs(diffY) > Math.abs(diffX)) {
                    moveShoppingItemDown(item.id);
                }
                
                resetSwipe();
                
                function resetSwipe() {
                    element.classList.remove('swiping', 'swipe-left', 'swipe-right', 'swipe-up', 'swipe-down');
                    element.style.transform = '';
                    element.querySelectorAll('.swipe-indicator').forEach(ind => ind.classList.remove('visible'));
                    startX = 0;
                    startY = 0;
                    currentX = 0;
                    currentY = 0;
                    isSwiping = false;
                }
            });
        }
        
        // Move shopping item up in the list
        function moveShoppingItemUp(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Increase priority by setting addedAt to now
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: Date.now()
            })
                .then(() => {
                    showToast('â¬†ï¸ ×”×¤×¨×™×˜ ×”×•×¢×œ×” ×œ××¢×œ×” ×‘×¨×©×™××”');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×¢×œ××ª ×”×¤×¨×™×˜');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function moveShoppingItemDown(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            // Decrease priority by setting addedAt to past
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                addedAt: Date.now() - (7 * 24 * 60 * 60 * 1000) // ×©×‘×•×¢ ××—×•×¨×”
            })
                .then(() => {
                    showToast('â¬‡ï¸ ×”×¤×¨×™×˜ ×”×•×¨×“ ×œ××˜×” ×‘×¨×©×™××”');
                })
                .catch(error => {
                    console.error('Error moving item:', error);
                    alert('âŒ ×©×’×™××” ×‘×”×•×¨×“×ª ×”×¤×¨×™×˜');
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        function purchaseItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×¡××Ÿ ×¤×¨×™×˜×™× ×›× ×§× ×•');
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'purchased',
                purchasedAt: Date.now(),
                purchasedBy: currentUser.name,
                purchasedById: currentUser.id
            }).then(() => {
                console.log('âœ… ×¤×¨×™×˜ ×¡×•××Ÿ ×›× ×§× ×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function unpurchaseItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                status: 'pending',
                purchasedAt: null,
                purchasedBy: null,
                purchasedById: null
            }).then(() => {
                showToast('â†©ï¸ ×”×¤×¨×™×˜ ×—×–×¨ ×œ×¨×©×™××ª ×”×§× ×™×•×ª');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function deleteShoppingItem(itemId) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ××—×•×§ ×¤×¨×™×˜×™×');
                return;
            }
            
            const item = shopping[itemId];
            if (!item) return;
            
            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª "${item.name}"?`)) {
                return;
            }
            
            // Add to deletion history
            const deletionEntry = {
                type: 'shopping',
                item: item.name,
                deletedBy: currentUser.name,
                deletedAt: new Date().toLocaleString('he-IL'),
                originalItem: item
            };
            
            const newHistory = [...deletionHistory, deletionEntry];
            
            isSyncing = true;
            updateSyncStatus();
            
            Promise.all([
                deletionHistoryRef.set(newHistory),
                shoppingRef.child(itemId).remove()
            ]).then(() => {
                console.log('âœ… ×¤×¨×™×˜ × ××—×§');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function togglePinShoppingItem(itemId) {
            const item = shopping[itemId];
            if (!item) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            shoppingRef.child(itemId).update({
                isPinned: !item.isPinned
            }).then(() => {
                console.log('ğŸ“Œ ×”×¦××“×” ×©×•× ×ª×”');
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function filterShopping(filter, event) {
            currentShoppingFilter = filter;
            
            // Update filter buttons
            const shoppingTab = document.getElementById('shoppingTab');
            shoppingTab.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            loadShopping();
        }
        
        function filterShoppingBySearch() {
            shoppingSearchQuery = document.getElementById('shoppingSearchInput').value.trim();
            loadShopping();
        }
        
        // ==================== DELETION HISTORY ====================
        
        function openDeletionHistoryModal() {
            const modal = document.getElementById('deletionHistoryModal');
            const tbody = document.getElementById('deletionHistoryBody');
            
            tbody.innerHTML = '';
            
            if (deletionHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 40px; color: var(--text-secondary);">××™×Ÿ ×¤×¨×™×˜×™× ×‘××—×™×§×•×ª</td></tr>';
            } else {
                deletionHistory.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    const typeIcon = entry.type === 'task' ? 'ğŸ“‹' : 'ğŸ›’';
                    const typeText = entry.type === 'task' ? '××©×™××”' : '×§× ×™×™×”';
                    
                    const canRestore = currentUser.isAdmin;
                    
                    row.innerHTML = `
                        <td>${typeIcon} ${typeText}</td>
                        <td>${entry.item}</td>
                        <td>${entry.deletedBy}</td>
                        <td>${entry.deletedAt}</td>
                        <td>
                            ${canRestore ? `<button class="btn btn-secondary" onclick="restoreItem(${index})">â†©ï¸ ×©×—×–×¨</button>` : 'â€”'}
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            }
            
            modal.classList.add('active');
        }
        
        function closeDeletionHistoryModal() {
            document.getElementById('deletionHistoryModal').classList.remove('active');
        }
        
        function restoreItem(index) {
            if (!currentUser.isAdmin) {
                alert('âŒ ×¨×§ ×—×’×™ ×•×œ×™××ª ×™×›×•×œ×™× ×œ×©×—×–×¨ ×¤×¨×™×˜×™×');
                return;
            }
            
            const entry = deletionHistory[index];
            if (!entry) return;
            
            isSyncing = true;
            updateSyncStatus();
            
            // Restore the item
            const restorePromise = entry.type === 'task' 
                ? tasksRef.child(entry.originalItem.id).set(entry.originalItem)
                : shoppingRef.child(entry.originalItem.id).set(entry.originalItem);
            
            // Remove from deletion history
            const newHistory = deletionHistory.filter((_, i) => i !== index);
            
            Promise.all([
                restorePromise,
                deletionHistoryRef.set(newHistory)
            ]).then(() => {
                console.log('âœ… ×¤×¨×™×˜ ×©×•×—×–×¨');
                openDeletionHistoryModal(); // Refresh
            }).finally(() => {
                isSyncing = false;
                updateSyncStatus();
            });
        }
        
        function clearDeletionHistory() {
            if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ× ×§×•×ª ××ª ×›×œ ×”×”×™×¡×˜×•×¨×™×”?')) {
                return;
            }
            
            isSyncing = true;
            updateSyncStatus();
            
            deletionHistoryRef.set([])
                .then(() => {
                    console.log('âœ… ×”×™×¡×˜×•×¨×™×” × ×•×§×ª×”');
                    closeDeletionHistoryModal();
                })
                .finally(() => {
                    isSyncing = false;
                    updateSyncStatus();
                });
        }
        
        // ==================== STATISTICS ====================
        
        function loadStats() {
            const allTasks = Object.values(tasks);
            const allShopping = Object.values(shopping);
            
            const hasTasks = allTasks.length > 0;
            const hasShopping = allShopping.length > 0;
            
            // Create tabs structure
            let statsHTML = `
                <div class="stat-tabs">
                    <button class="stat-tab active" onclick="switchStatTab('tasks-stat')">ğŸ“‹ ××©×™××•×ª</button>
                    <button class="stat-tab" onclick="switchStatTab('shopping-stat')">ğŸ›’ ×§× ×™×•×ª</button>
                </div>
            `;
            
            // Tasks stats content
            statsHTML += '<div id="tasks-stat" class="stat-content active">';
            
            if (hasTasks) {
                // Count pending tasks per member
                const memberTaskCounts = {};
                Object.keys(familyMembers).forEach(memberId => {
                    if (memberId !== 'everyone') {
                        memberTaskCounts[memberId] = 0;
                    }
                });
                
                allTasks.forEach(task => {
                    if (task.status === 'pending' && task.assignedTo) {
                        if (memberTaskCounts[task.assignedTo] !== undefined) {
                            memberTaskCounts[task.assignedTo]++;
                        }
                    }
                });
                
                // Display each member with their pending tasks count
                Object.entries(memberTaskCounts).forEach(([memberId, count]) => {
                    const member = familyMembers[memberId];
                    statsHTML += `
                        <div class="member-stat" onclick="filterByMember('${memberId}')">
                            <div class="member-info">
                                <span class="member-icon">${member.icon}</span>
                                <span class="member-name">${member.name}</span>
                            </div>
                            <div class="member-count ${count === 0 ? 'zero' : ''}" style="color: ${member.color}">
                                ${count}
                            </div>
                        </div>
                    `;
                });
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">××™×Ÿ ×¢×“×™×™×Ÿ ××©×™××•×ª</p>';
            }
            
            statsHTML += '</div>'; // Close tasks-stat
            
            // Shopping stats content
            statsHTML += '<div id="shopping-stat" class="stat-content">';
            
            if (hasShopping) {
                const totalItems = allShopping.length;
                const purchasedItems = allShopping.filter(i => i.status === 'purchased').length;
                const pendingItems = totalItems - purchasedItems;
                
                statsHTML += `
                    <div class="shopping-stats">
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number pending">${pendingItems}</div>
                            <div class="shopping-stat-label">×¦×¨×™×š ×œ×§× ×•×ª</div>
                        </div>
                        <div class="shopping-stat-box">
                            <div class="shopping-stat-number purchased">${purchasedItems}</div>
                            <div class="shopping-stat-label">× ×§× ×•</div>
                        </div>
                    </div>
                `;
            } else {
                statsHTML += '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">××™×Ÿ ×¢×“×™×™×Ÿ ×¤×¨×™×˜×™ ×§× ×™×™×”</p>';
            }
            
            statsHTML += '</div>'; // Close shopping-stat
            
            document.getElementById('statsContainer').innerHTML = statsHTML;
            
            // Update top performers (only shown to Hagai)
            updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping);
        }
        
        function switchStatTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.stat-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.stat-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
        }
        
        function updateTopPerformers(hasTasks, hasShopping, allTasks, allShopping) {
            // Top performers (for Hagai only)
            const memberStats = {};
            Object.keys(familyMembers).forEach(memberId => {
                if (memberId !== 'everyone') {
                    memberStats[memberId] = {
                        tasksCompleted: 0,
                        itemsAdded: 0,
                        itemsPurchased: 0,
                        total: 0
                    };
                }
            });
            
            // Count completed tasks
            if (hasTasks) {
                allTasks.forEach(task => {
                    if (task.status === 'completed' && task.completedById && memberStats[task.completedById]) {
                        memberStats[task.completedById].tasksCompleted++;
                        memberStats[task.completedById].total++;
                    }
                });
            }
            
            // Count purchased items
            if (hasShopping) {
                allShopping.forEach(item => {
                    if (item.status === 'purchased' && item.purchasedById && memberStats[item.purchasedById]) {
                        memberStats[item.purchasedById].itemsPurchased++;
                        memberStats[item.purchasedById].total++;
                    }
                });
            }
            
            // Sort by total
            const topPerformers = Object.entries(memberStats)
                .map(([id, stats]) => ({ id, ...stats, ...familyMembers[id] }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 3);
            
            let performersHTML = '';
            const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
            
            topPerformers.forEach((performer, index) => {
                if (performer.total === 0 && index > 0) return;
                
                performersHTML += `
                    <div class="performer-item">
                        <div class="performer-rank">${medals[index]}</div>
                        <div class="performer-info">
                            <div class="performer-name">${performer.icon} ${performer.name}</div>
                            <div class="performer-points">${performer.total} ×¤×¢×•×œ×•×ª ×”×©×‘×•×¢</div>
                        </div>
                    </div>
                `;
            });
            
            if (!performersHTML) {
                performersHTML = '<div class="empty-state"><div class="empty-icon">ğŸ†</div><div class="empty-text">×¢×“×™×™×Ÿ ××™×Ÿ × ×ª×•× ×™× ×”×©×‘×•×¢</div></div>';
            }
            
            const topPerformersEl = document.getElementById('topPerformers');
            if (topPerformersEl) {
                topPerformersEl.innerHTML = performersHTML;
            }
        }
        
        // ==================== BACKUP SYSTEM (Hagai only) ====================
        
        async function setupAutoBackup() {
            if (!currentUser.canBackup) return;
            
            // Allow backup on all devices (including mobile)
            console.log('âœ… ××¢×¨×›×ª ×’×™×‘×•×™ ×–××™× ×”');
            
            if (!('showDirectoryPicker' in window)) {
                console.log('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×’×™×‘×•×™ ××•×˜×•××˜×™');
                return;
            }
            
            // Check if this is first time
            const autoBackupEnabled = localStorage.getItem('autoBackupEnabled');
            
            if (autoBackupEnabled === null) {
                const confirmed = confirm('×”×™×™ ×—×’×™! ğŸ”\n\n×”×× ×œ×”×¤×¢×™×œ ×’×™×‘×•×™ ××•×˜×•××˜×™?\n\n×”××¢×¨×›×ª ×ª×©××•×¨ ××ª ×›×œ ×”× ×ª×•× ×™× ×‘×ª×™×§×™×™×” ×©×ª×‘×—×¨ ×‘×›×œ ×›× ×™×¡×” ×•×™×¦×™××”.\n\nğŸ“± ×¢×•×‘×“ ×’× ×‘× ×™×™×“!');
                
                if (confirmed) {
                    localStorage.setItem('autoBackupEnabled', 'true');
                    const success = await requestBackupDirectory();
                    if (success) {
                        await performBackup(true);
                    }
                } else {
                    localStorage.setItem('autoBackupEnabled', 'false');
                }
            } else if (autoBackupEnabled === 'true') {
                try {
                    const savedHandle = await loadDirectoryHandle();
                    
                    if (savedHandle) {
                        const permission = await savedHandle.queryPermission({ mode: 'readwrite' });
                        
                        if (permission === 'granted') {
                            backupDirectoryHandle = savedHandle;
                            console.log('âœ… × ×ª×™×‘ ×’×™×‘×•×™ ×˜×¢×•×Ÿ ××”×–×™×›×¨×•×Ÿ');
                            await performBackup(true);
                        } else {
                            const newPermission = await savedHandle.requestPermission({ mode: 'readwrite' });
                            if (newPermission === 'granted') {
                                backupDirectoryHandle = savedHandle;
                                console.log('âœ… ×”×¨×©××ª ×’×™×‘×•×™ ×—×•×“×©×”');
                                await performBackup(true);
                            }
                        }
                    } else {
                        console.log('âš ï¸ ×œ× × ××¦× × ×ª×™×‘ ×©××•×¨');
                        const success = await requestBackupDirectory();
                        if (success) {
                            await performBackup(true);
                        }
                    }
                } catch (err) {
                    console.log('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×™×‘ ×’×™×‘×•×™:', err);
                }
            }
            
            // Auto backup every 5 minutes
            setInterval(() => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            }, 5 * 60 * 1000);
            
            // Auto backup on page unload
            window.addEventListener('beforeunload', () => {
                if (backupDirectoryHandle) {
                    performBackup(true);
                }
            });
        }
        
        async function requestBackupDirectory() {
            try {
                backupDirectoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });
                
                await saveDirectoryHandle(backupDirectoryHandle);
                console.log('âœ… × ×ª×™×‘ ×’×™×‘×•×™ × ×©××¨');
                return true;
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('×©×’×™××” ×‘×‘×—×™×¨×ª ×ª×™×§×™×™×”:', err);
                }
                return false;
            }
        }
        
        async function performBackup(silent = true) {
            if (!backupDirectoryHandle) {
                if (!silent) console.log('××™×Ÿ × ×ª×™×‘ ×’×™×‘×•×™');
                return false;
            }
            
            try {
                const permission = await backupDirectoryHandle.queryPermission({ mode: 'readwrite' });
                if (permission !== 'granted') {
                    const newPermission = await backupDirectoryHandle.requestPermission({ mode: 'readwrite' });
                    if (newPermission !== 'granted') {
                        console.log('××™×Ÿ ×”×¨×©××” ×œ×ª×™×§×™×™×ª ×”×’×™×‘×•×™');
                        return false;
                    }
                }
                
                const backupData = {
                    timestamp: new Date().toISOString(),
                    user: currentUser.name,
                    tasks: tasks,
                    shopping: shopping,
                    deletionHistory: deletionHistory,
                    version: '5.1'
                };
                
                // Daily backup - one file per day (overwrites previous)
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                const todayFilename = `family-tasks-backup-${dateStr}.json`;
                
                // Get yesterday's date for cleanup
                const yesterday = new Date(now);
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayDateStr = yesterday.toISOString().split('T')[0];
                const yesterdayFilename = `family-tasks-backup-${yesterdayDateStr}.json`;
                
                try {
                    // Delete yesterday's backup if exists
                    const yesterdayHandle = await backupDirectoryHandle.getFileHandle(yesterdayFilename);
                    await backupDirectoryHandle.removeEntry(yesterdayFilename);
                    console.log(`ğŸ—‘ï¸ ××—×§ ×’×™×‘×•×™ ×©×œ ××ª××•×œ: ${yesterdayFilename}`);
                } catch (err) {
                    // File doesn't exist, that's ok
                }
                
                // Create/overwrite today's backup
                const fileHandle = await backupDirectoryHandle.getFileHandle(todayFilename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(backupData, null, 2));
                await writable.close();
                
                if (!silent) console.log('âœ… ×’×™×‘×•×™ ×‘×•×¦×¢ ×‘×”×¦×œ×—×”:', todayFilename);
                return true;
            } catch (err) {
                console.error('×©×’×™××” ×‘×’×™×‘×•×™:', err);
                return false;
            }
        }
        
        async function performManualBackup() {
            const success = await performBackup(false);
            if (success) {
                alert('âœ… ×”×’×™×‘×•×™ ×‘×•×¦×¢ ×‘×”×¦×œ×—×”!');
            } else {
                alert('âŒ ×©×’×™××” ×‘×‘×™×¦×•×¢ ×’×™×‘×•×™');
            }
        }
        
        async function performRestore() {
            try {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] }
                    }],
                    multiple: false
                });
                
                const file = await fileHandle.getFile();
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×©×—×–×¨ ×’×™×‘×•×™? ×¤×¢×•×œ×” ×–×• ×ª×“×¨×•×¡ ××ª ×”× ×ª×•× ×™× ×”× ×•×›×—×™×™×!')) {
                    return;
                }
                
                isSyncing = true;
                updateSyncStatus();
                
                await Promise.all([
                    data.tasks ? tasksRef.set(data.tasks) : Promise.resolve(),
                    data.shopping ? shoppingRef.set(data.shopping) : Promise.resolve(),
                    data.deletionHistory ? deletionHistoryRef.set(data.deletionHistory) : Promise.resolve()
                ]);
                
                alert('âœ… ×”×’×™×‘×•×™ ×©×•×—×–×¨ ×‘×”×¦×œ×—×”!');
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Restore error:', error);
                    alert('âŒ ×©×’×™××” ×‘×©×—×–×•×¨ ×’×™×‘×•×™');
                }
            } finally {
                isSyncing = false;
                updateSyncStatus();
            }
        }
        
        async function openBackupDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        
        async function saveDirectoryHandle(handle) {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.put(handle, 'backupDirectory');
                
                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        db.close();
                        resolve(true);
                    };
                    transaction.onerror = () => {
                        db.close();
                        reject(transaction.error);
                    };
                });
            } catch (err) {
                console.error('Error saving directory handle:', err);
                return false;
            }
        }
        
        async function loadDirectoryHandle() {
            try {
                const db = await openBackupDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('backupDirectory');
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('Error loading directory handle:', err);
                return null;
            }
        }
    </script>
</body>
</html>